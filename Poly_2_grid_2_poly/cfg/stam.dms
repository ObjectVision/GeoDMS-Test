container Poly_2_grid_2_poly
{
	#include <eenheden.dms>
	#include <geografie.dms>

	container SourceData{
		unit<uint16> gemeente : StorageName = "%CbsSourceDatadir%/gemeente.shp", StorageType = "gdal.vect", StorageReadOnly = "True"
		{
			attribute<geografie/point_rd> geometry (poly);
			attribute<string> label := GM_NAAM;
		}
	}
	
	container GridData
	{
		attribute<SourceData/gemeente> m100 (Geografie/gridcel_100m/domain) := poly2grid(SourceData/gemeente/geometry, Geografie/gridcel_100m/domain);
		attribute<SourceData/gemeente> m25  (Geografie/gridcel_25m/domain)  := poly2grid(SourceData/gemeente/geometry, Geografie/gridcel_25m/domain);
		attribute<SourceData/gemeente> m10  (Geografie/gridcel_10m/domain)  := poly2grid(SourceData/gemeente/geometry, Geografie/gridcel_10m/domain);

	}
	container districts
	{
		unit<uint16> m100 := district_uint16(GridData/m100) { attribute<SourceData/Gemeente> Regio_rel := first(GridData/m100, Districts); }
		unit<uint16> m25  := district_uint16(GridData/m25)  { attribute<SourceData/Gemeente> Regio_rel := first(GridData/m25 , Districts); }
		unit<uint16> m10  := district_uint16(GridData/m10)  { attribute<SourceData/Gemeente> Regio_rel := first(GridData/m10 , Districts); }
	}
	
	template grid2poly_T {
		unit<spoint> domain_grid;
		unit<uint16> Zone;
		attribute<Zone> zone_rel(domain_grid);
		parameter<float64> simplifyFactor;
		
		parameter<Zone> NoZone := uint16(#Zone)+lowerbound(Zone); // outside study area indicator
		
		// Segments := horizontale raster-randjes met ongelijke boven en onder zones + verticale raster-randjes met ongelijke linker en rechter zones
		unit<int16> rows := range(uint32, pointrow(lowerbound(domain_grid)), pointrow(upperbound(domain_grid)));
		unit<int16> cols := range(uint32, pointcol(lowerbound(domain_grid)), pointcol(upperbound(domain_grid)));
		
		unit<int16>  HorizontalLine := range(int16, lowerbound(rows), upperbound(rows)+1s);
		unit<int16>  VerticalLine   := range(int16, lowerbound(cols), upperbound(cols)+1s);
		
		unit<uint32> Point := combine(VerticalLine, HorizontalLine)
		{
			attribute<geografie/point_rd> geometry := domain_grid_rel[geografie/point_rd];
			attribute<domain_grid> domain_grid_rel := point_xy(first_rel, second_rel, domain_grid); // the RasterCell NorthEast of this Point
			attribute<bool> isBoundaryPoint := has_any(BoundarySegment/F1) || has_any(BoundarySegment/F2);
			attribute<BoundaryPoint> BoundaryPoint_rel := invert(BoundaryPoint/org_rel);
		}
		unit<uint32> BoundaryPoint := select_with_org_rel(Point/isBoundaryPoint)
		{
			attribute<geografie/point_rd> geometry := org_rel->geometry;
			attribute<uint32> NrBoundarySegments := pcount(BoundarySegment/bp_F1) + pcount(BoundarySegment/bp_F2);
			attribute<bool>   isJunction := NrBoundarySegments != 2; // Junction := raster-hoekpunt waarop meer dan 2 segmenten uit komen (1 kan niet voor komen)
			
			attribute<uint32> NrJFSegment := pcount(JFSegment/F1) + pcount(JFSegment/F2);
		}
		
		unit<uint32> HorizontalSegment := combine(cols, HorizontalLine)
		{
			attribute<domain_grid> North  := point_xy(first_rel, second_rel-1s, domain_grid);
			attribute<domain_grid> South  := point_xy(first_rel, second_rel   , domain_grid);
			attribute<bool> isBoundarySegment := MakeDefined(south->zone_rel, NoZone) != MakeDefined(North->zone_rel, NoZone);
			attribute<Point> F1 := combine_data(Point,  first_rel    [VerticalLine], second_rel);
			attribute<Point> F2 := combine_data(Point, (first_rel+1s)[VerticalLine], second_rel);
		}
		
		unit<uint32> VerticalSegment := combine(VerticalLine, rows)
		{
			attribute<domain_grid> West := point_xy(first_rel-1s, second_rel, domain_grid);
			attribute<domain_grid> East := point_xy(first_rel   , second_rel, domain_grid);
			attribute<bool> isBoundarySegment := MakeDefined(West->zone_rel, max(zone_rel)+1w) != MakeDefined(East->zone_rel, max(zone_rel)+1w);
			attribute<Point> F1 := combine_data(Point, first_rel,  second_rel    [HorizontalLine]);
			attribute<Point> F2 := combine_data(Point, first_rel, (second_rel+1s)[HorizontalLine]);
		}
		
		unit<uint32> HorizontalBoundarySegment := select(HorizontalSegment/isBoundarySegment)
		{
			attribute<domain_grid> North := collect_by_cond(., HorizontalSegment/North);
			attribute<domain_grid> South := collect_by_cond(., HorizontalSegment/South);
			attribute<Point>       F1    := collect_by_cond(., HorizontalSegment/F1);
			attribute<Point>       F2    := collect_by_cond(., HorizontalSegment/F2);
		}
		unit<uint32> VerticalBoundarySegment := select(verticalSegment/isBoundarySegment)
		{
			attribute<domain_grid> East  := collect_by_cond(., VerticalSegment/East);
			attribute<domain_grid> West  := collect_by_cond(., VerticalSegment/West);
			attribute<Point>       F1    := collect_by_cond(., VerticalSegment/F1);
			attribute<Point>       F2    := collect_by_cond(., VerticalSegment/F2);
		}
		
		unit<uint2> Direction {
			attribute<string> Label : [ 'North', 'East', 'South', 'West'];
			container V:= for_each_nedv(Label, string(ID(.))+'[..]', void, .);
			attribute<.> Next    := union_data(., V/West, V/North, V/East, V/South);
			attribute<.> Reverse := union_data(., V/South, V/West, V/North, V/East);
		}
		unit<uint32> BoundarySegment := union_unit(HorizontalBoundarySegment, VerticalBoundarySegment)
		{
			unit<uint32> BS_Point := union_unit(BoundarySegment, BoundarySegment)
			{				
				attribute<Geografie/point_rd> geometry   := union_data(BS_Point, F1->geometry, F2->geometry);
				attribute<BoundarySegment> BoundarySegment_rel := union_data(BS_Point, ID(BoundarySegment), ID(BoundarySegment));
			}
			
			attribute<Geografie/point_rd> geometry(arc) := points2sequence(BS_Point/geometry, BS_Point/BoundarySegment_rel);
			attribute<domain_grid> left  := union_data(., HorizontalBoundarySegment/North, VerticalBoundarySegment/East);
			attribute<domain_grid> right := union_data(., HorizontalBoundarySegment/South, VerticalBoundarySegment/West);
			attribute<Direction> Dir_rel := union_data(., const(Direction/V/East ,HorizontalBoundarySegment), const(Direction/V/South ,VerticalBoundarySegment));
			attribute<Point> F1 := union_data(., HorizontalBoundarySegment/F1, VerticalBoundarySegment/F1);
			attribute<Point> F2 := union_data(., HorizontalBoundarySegment/F2, VerticalBoundarySegment/F2);
			attribute<BoundaryPoint> bp_F1 := F1->BoundaryPoint_rel; 
			attribute<BoundaryPoint> bp_F2 := F2->BoundaryPoint_rel; 
			attribute<bool> f1IsJunction := bp_F1->isJunction;
			attribute<bool> f2IsJunction := bp_F2->isJunction;
			attribute<bool> isJFSegment := not(f1IsJunction) && not(f2IsJunction); // intermediate in linestring
			
			attribute<Zone> left_Zone_rel := zone_rel[left];
			attribute<Zone> rightZone_rel := zone_rel[right];
		}
		
		unit<uint32> Junction := select_with_org_rel(BoundaryPoint/isJunction)
		{
			attribute<geografie/point_rd> geometry := collect_by_cond(Junction, BoundaryPoint/geometry);
			attribute<.> per_node(BoundaryPoint) := invert(org_rel);
		}
		
		// JFSegment (aka Junction Free Links) := Segments die 2 JFN verbinden
		unit<uint32> JFSegment := select(BoundarySegment/isJFSegment)
		{
			attribute<BoundaryPoint> F1 := collect_by_cond(JFSegment, BoundarySegment/bp_F1);
			attribute<BoundaryPoint> F2 := collect_by_cond(JFSegment, BoundarySegment/bp_F2);
			
			attribute<Zone> left_Zone_rel := collect_by_cond(JFSegment, BoundarySegment/left_Zone_rel);
			attribute<Zone> rightZone_rel := collect_by_cond(JFSegment, BoundarySegment/rightZone_rel);
		}
		
		// Connector := Segment tussen een Junction en een JFN of een andere Junction
		unit<uint32> FromJunctionLink := select(BoundarySegment/f1IsJunction)
		{
			attribute<BoundaryPoint> F1 := collect_by_cond(FromJunctionLink, BoundarySegment/bp_F1);
			attribute<BoundaryPoint> F2 := collect_by_cond(FromJunctionLink, BoundarySegment/bp_F2);
			attribute<Direction>     Dir_rel := collect_by_cond(FromJunctionLink, BoundarySegment/Dir_rel);
			
			attribute<Junction> Junction_rel := Junction/per_node[F1];
			
			attribute<Zone> left_Zone_rel := collect_by_cond(FromJunctionLink, BoundarySegment/left_Zone_rel);
			attribute<Zone> rightZone_rel := collect_by_cond(FromJunctionLink, BoundarySegment/rightZone_rel);
		}
		unit<uint32> ToJunctionLink := select(BoundarySegment/f2IsJunction)
		{
			attribute<BoundaryPoint> F1 := collect_by_cond(ToJunctionLink, BoundarySegment/bp_F1);
			attribute<BoundaryPoint> F2 := collect_by_cond(ToJunctionLink, BoundarySegment/bp_F2);
			attribute<Direction>     Org_dir_rel := collect_by_cond(ToJunctionLink, BoundarySegment/Dir_rel);
			attribute<Direction>     Dir_rel := Org_dir_rel->Direction/Reverse;
			
			attribute<Junction> Junction_rel := Junction/per_node[F2];
			attribute<Zone> left_Zone_rel := collect_by_cond(ToJunctionLink, BoundarySegment/left_Zone_rel);
			attribute<Zone> rightZone_rel := collect_by_cond(ToJunctionLink, BoundarySegment/rightZone_rel);
		}
		
		unit<uint32> JunctionDirection := combine_unit(Junction, Direction);
		
		unit<uint32> JunctionLink := union_unit(FromJunctionLink, ToJunctionLink)
		{
			attribute<Geografie/point_rd> Junction_geometry := Junction_rel->Geometry;
			
			unit<uint32> JL_Point := union_unit(JunctionLink, JunctionLink)
			{				
				attribute<Geografie/point_rd> geometry   := union_data(JL_Point, F1->geometry, F2->geometry);
				attribute<JunctionLink> JunctionLink_rel := union_data(JL_Point, ID(JunctionLink), ID(JunctionLink));
			}
			
			attribute<Geografie/point_rd> geometry(arc) := points2sequence(JL_Point/geometry, JL_Point/JunctionLink_rel);
			
			attribute<BoundaryPoint> F1   := union_data(., FromJunctionLink/F1, ToJunctionLink/F2);
			attribute<BoundaryPoint> F2   := union_data(., FromJunctionLink/F2, ToJunctionLink/F1);
			attribute<Direction>     Dir_rel := union_data(., FromJunctionLink/Dir_rel, ToJunctionLink/Dir_rel);
			attribute<Direction>     NextDir_rel := Dir_rel->Next;
			attribute<Direction>     NextNextDir_rel := Dir_rel->Reverse;
			attribute<Junction>      Junction_rel := rlookup(F1, Junction/org_rel);
			
			attribute<Zone> left_Zone_rel := union_data(., FromJunctionLink/left_Zone_rel, ToJunctionLink/rightZone_rel);
			attribute<Zone> rightZone_rel := union_data(., FromJunctionLink/rightZone_rel, ToJunctionLink/left_Zone_rel );
			
			attribute<JunctionDirection> JunctionDirection_rel := combine_data(JunctionDirection, Junction_rel, Dir_rel);
			attribute<JunctionDirection> NextJunctionDirection_rel := combine_data(JunctionDirection, Junction_rel, NextDir_rel);
			attribute<JunctionDirection> NextNextJunctionDirection_rel := combine_data(JunctionDirection, Junction_rel, NextNextDir_rel);
			attribute<JunctionLink> n1_JL := rlookup(NextJunctionDirection_rel, JunctionDirection_rel);
			attribute<JunctionLink> n2_JL := rlookup(NextNextJunctionDirection_rel, JunctionDirection_rel);
			attribute<JunctionLink> next_JL := MakeDefined(n1_JL, n2_JL);
			
			attribute<JFLS2> outJFLS2 := invert(JFLS2/JL_rel);
			
			attribute<.> other_rel_ls := outJFLS2->Other_rel;
			attribute<.> other_rel_direct := rlookup(combine_data(JunctionDirection, rlookup(F2, Junction/org_rel), Dir_rel->Reverse), JunctionLink/JunctionDirection_rel);
			attribute<bool> has_other_rel_ls := IsDefined(other_rel_ls);
			attribute<bool> has_other_rel_direct := IsDefined(other_rel_direct);
			attribute<bool> has_other_rel_by_2   := not(or(has_other_rel_ls, has_other_rel_direct));
			
			unit<uint32> doubleton_link := select_with_org_rel(has_other_rel_by_2)
			{
				attribute<BoundaryPoint> unsorted_F2 := collect_by_cond(., F2);
				attribute<Geografie/point_rd> unsorted_geometry := unsorted_F2->geometry;
								
				attribute<doubleton_link> index := index(unsorted_F2);
				attribute<BoundaryPoint> sorted_F2 := index->unsorted_F2;
				attribute<Geografie/point_rd> sorted_geometry := sorted_F2->geometry;
				
				attribute<doubleton_link> sorted_other_rel := bitxor(ID(.), 1);

				// org_rel[index[order->sorted_other_rel]]
				attribute<doubleton_link> order := invert(index);
				attribute<doubleton_link> reindex := index[order->sorted_other_rel];
				
				
				attribute<JunctionLink> other_org_rel := reindex->org_rel;
				
				attribute<BoundaryPoint> unsorted_other_F2a := reindex->unsorted_F2;
				attribute<BoundaryPoint> unsorted_other_F2b := other_org_rel->F2;
				
				parameter<bool> Check0   := GeoDmsVersion() >= 14.13;
				parameter<bool> Check1   := (nrofrows(.) % 2) == 0;
				
				attribute<bool> Check2(BoundaryPoint) := pcount(unsorted_F2) == 0 || pcount(unsorted_F2) == 2; // time&space complexity: O(BoundaryPoint)
				attribute<bool> Check3a  := unsorted_other_F2a == unsorted_F2; 
				attribute<bool> Check3b  := unsorted_other_F2b == unsorted_F2; 
				attribute<bool> Check3c  := other_org_rel != org_rel; 
				attribute<bool> Check3   := Check3a && Check3b && Check3c; 
//				parameter<bool> CheckAll := and(Check0, Check1, all(Check2), all(Check3));
				parameter<bool> CheckAll := and(Check0, Check1, all(Check3));
			}
			
 			attribute<.> other_rel_with2 := recollect_by_cond(has_other_rel_by_2, doubleton_link/other_org_rel), IntegrityCheck = "doubleton_link/CheckAll";
			
			attribute<.> other_rel := MakeDefined(other_rel_ls, other_rel_direct, other_rel_with2);
			attribute<.> next_rel  := other_rel->next_JL;
		}
		
		
		// Junction Free Section := clusters van BoundaryPoints, verbonden door JFSegments, of losse BoundaryPoints
		// TODO: make dual of segment(F1m F2) for JFP: JFP(Link1, Link2) and absorb handling of doubleton_links
		unit<uint32> JFSection := connected_parts(JFSegment/F1, JFSegment/F2)
		{
			attribute<uint32> nrParts := pcount(PartNr);
		}
		
		unit<uint32> JFPath := select_with_org_rel(JFSection/nrParts > 1)
		{
			attribute<JFSection> JFSection_rel := org_rel;
			attribute<.> PartNr(BoundaryPoint) := invert(org_rel)[JFSection/PartNr];
			
			unit<uint32> JFLP := union_unit(JFSegment, JFSegment) 
			{ 
				attribute<BoundaryPoint> BP_rel  := union_data(., JFSegment/F1, JFSegment/F2);
				attribute<JFPath>          JFSS_rel := PartNr[BP_rel];
				attribute<bool> isEndOfJSF := BP_rel->NrJFSegment == 1;
			} 
			attribute<uint8> NrEnds := sum_uint8(JFLP/isEndOfJSF, JFLP/JFSS_rel);
			attribute<bool> isLineString := NrEnds == 2b; // it could also be a ring without any Junction
			
			unit<uint32> Connector := select_with_org_rel(JFLP/isEndOfJSF);
		
			attribute<uint32> nrParts := pcount(PartNr);
			attribute<BoundaryPoint> firstBP_rel := first(Connector/org_rel->BP_rel, Connector/org_rel->JFSS_rel);
			attribute<BoundaryPoint> last_BP_rel := last (Connector/org_rel->BP_rel, Connector/org_rel->JFSS_rel);
			
				
		}
		unit<uint32> JFRing  := select_with_org_rel(not(JFPath/isLineString))
		{
			attribute<JFPath> JFPath_rel := org_rel;
			attribute<JFSection>  JFSection_rel  := JFPath_rel->JFSection_rel;
			
			attribute<BoundaryPoint> firstBP_rel := min(ID(BoundaryPoint), JFPath_rel->PartNr);
//			attribute<BoundaryPoint> last_BP_rel := collect_by_cond(JFLineString, JFPath/last_BP_rel); // null
			
			// abuse the fact that the first segment of a ring is always West to East and therefore right is inside.
			attribute<Zone> left_Zone_rel := first(BoundarySegment/left_Zone_rel, JFPath_rel->PartNr[BoundarySegment/F1]);
			attribute<Zone> rightZone_rel := first(BoundarySegment/rightZone_rel, JFPath_rel->PartNr[BoundarySegment/F1]);
			
//			attribute<BoundaryPoint> firstBP_rel := min(JFPath/BoundaryPoint_rel, org_rel);
			
			attribute<uint32> dist_from_first_BP(BoundaryPoint) := impedance_table('bidirectional;startPoint(Node_rel);node:TraceBack'
					, const(1, JFSegment), JFSegment/F1, JFSegment/F2, JFLS/firstBP_rel);
					
			unit<uint32> JFLSP := select(IsDefined(dist_from_first_BP))
			{
				attribute<Geografie/point_rd> geometry := collect_by_cond(JFLSP, BoundaryPoint/Geometry);
				attribute<JFLS> sequence_rel := collect_by_cond(JFLSP, PartNr);
				attribute<uint32> ordinal := collect_by_cond(JFLSP, dist_from_first_BP);
			}
			
			attribute<uint32> NrSimplifiedPoints := union_data(path, JFLS/NrSimplifiedPoints, JFRing/NrSimplifiedPoints);
		}
		
		unit<uint32> JFLineString := select_with_org_rel(JFPath/isLineString) // JunctionFree LineString
		{
			attribute<BoundaryPoint> firstBP_rel := collect_by_cond(JFLineString, JFPath/firstBP_rel);
			attribute<BoundaryPoint> last_BP_rel := collect_by_cond(JFLineString, JFPath/last_BP_rel);
			attribute<JunctionLink>  firstJL_rel := rlookup(firstBP_rel, JunctionLink/F2);
			attribute<JunctionLink>  last_JL_rel := rlookup(last_BP_rel, JunctionLink/F2);
			
			attribute<.> PartNr(BoundaryPoint) := invert(org_rel)[JFPath/PartNr];
			// JFSection/Linestring := d.m.v. impedance_single van alle begin JFSection naar eind JFSection routes t.b.v. points2sequence
			attribute<uint32> dist_from_first_BP(BoundaryPoint) := impedance_table('bidirectional;startPoint(Node_rel);node:TraceBack'
					, const(1, JFSegment), JFSegment/F1, JFSegment/F2, JFLineString/firstBP_rel);
					
			unit<uint32> JFLSP := select(IsDefined(dist_from_first_BP))
			{
				attribute<Geografie/point_rd> geometry := collect_by_cond(JFLSP, BoundaryPoint/Geometry);
				attribute<JFLineString> sequence_rel := collect_by_cond(JFLSP, PartNr);
				attribute<uint32> ordinal := collect_by_cond(JFLSP, dist_from_first_BP);
			}
			unit<uint32> JFLSPwithConnectors := union_unit(JFLineString, JFLSP, JFLineString)
			{
				attribute<Geografie/point_rd> geometry := union_data(., firstJL_rel->Junction_geometry, JFLSP/geometry, last_JL_rel->Junction_geometry);
				attribute<JFLineString>   sequence_rel := union_data(., id(JFLineString), JFLSP/sequence_rel, id(JFLineString));
				attribute<uint32> ordinal      := union_data(., const(0, JFLineString), JFLSP/ordinal+1, max(JFLSP/ordinal, JFLSP/sequence_rel)+2);
			}
			
			attribute<Geografie/point_rd> LineString(arc) := points2sequence(JFLSP/geometry, JFLSP/sequence_rel, JFLSP/ordinal);
			attribute<Geografie/point_rd> LineStringWithConnectors(arc) := points2sequence(JFLSPwithConnectors/geometry, JFLSPwithConnectors/sequence_rel, JFLSPwithConnectors/ordinal);
			attribute<Geografie/point_rd> SimplifiedLineStringWithConnectors(arc) := bg_simplify_linestring(LineStringWithConnectors, simplifyFactor);
			unit<uint32> SimplifiedPoints := sequence2points(SimplifiedLineStringWithConnectors);
			attribute<uint32> SimplifiedPointOrdinalMax := max(SimplifiedPoints/ordinal, SimplifiedPoints/Sequence_rel);
			attribute<uint32> NrSimplifiedPoints := SimplifiedPointOrdinalMax+1;
			attribute<SimplifiedPoints> SimplifiedPointBase := value(cumulate(NrSimplifiedPoints) - NrSimplifiedPoints, SimplifiedPoints);
		}
		unit<uint32> Path := union_unit(JFLineString, JFRing)
		{
			attribute<JunctionLink> firstJL_rel := union_data(Path, JFLineString/firstJL_rel, const(null_u, JFRing));
			attribute<JunctionLink> last_JL_rel := union_data(Path, JFLineString/last_JL_rel, const(null_u, JFRing));
			attribute<uint32>       NrSimplifiedPoints := union_data(path, JFLineString/NrSimplifiedPoints, JFRing/NrSimplifiedPoints);
		}
		
		unit<uint32>  pathSrc := path; // JFLineString;
		
		unit<uint32>  JFLS2 := union_unit(pathSrc, pathSrc)
		{
			attribute<JunctionLink> JL_rel    := union_data(., pathSrc/firstJL_rel, pathSrc/last_JL_rel);
			attribute<uint32>       NrSimplifiedPoints := union_data(., pathSrc/NrSimplifiedPoints, pathSrc/NrSimplifiedPoints);
			attribute<JunctionLink> Other_rel := union_data(., pathSrc/last_JL_rel, pathSrc/firstJL_rel);
			attribute<JFLS2_Point>  JFLS2_Point_Base := cumulate(NrSimplifiedPoints) - NrSimplifiedPoints;
		}
		unit<uint32> JFLS2_Point := range(uint32, 0, sum(JFLS2/NrSimplifiedPoints))
		{
			attribute<JFLS2> JFLS2_rel := classify(ID(.), JFLS2/JFLS2_Point_Base);
			attribute<uint32> ordinal := ID(.) - JFLS2_rel;
			attribute<JFLineString/SimplifiedPoints> SimplifiedPoint_rel := union_data(.
				, JFLineString/SimplifiedPointBase[JFLineString/SimplifiedPoints/Sequence_rel] + JFLineString/SimplifiedPoints/ordinal
				, (JFLineString/SimplifiedPointBase+JFLineString/SimplifiedPointOrdinalMax)[JFLineString/SimplifiedPoints/Sequence_rel] - JFLineString/SimplifiedPoints/ordinal);
			attribute<Geografie/point_rd> geometry  := SimplifiedPoint_rel->Point;
		}
		unit<uint32> ZoneRing := connected_parts(ID(JunctionLink), JunctionLink/next_rel)
		{
			attribute<.> per_JunctionLink(JunctionLink) := PartNr;
			attribute<JunctionLink> index(JunctionLink) := index(PartNr);
			attribute<JunctionLink> order(JunctionLink) := invert(index);
			
			attribute<Zone> FirstZone_rel := first(JunctionLink/rightZone_rel, per_JunctionLink);
			attribute<Zone> FirstZone_per_JunctionLink(JunctionLink) := per_JunctionLink->FirstZone_rel;
			attribute<bool> CheckUniqueZonePerRing(JunctionLink) := or(JunctionLink/rightZone_rel == FirstZone_per_JunctionLink,  not(or(IsDefined(JunctionLink/rightZone_rel), IsDefined(FirstZone_per_JunctionLink))));
			
			attribute<JunctionLink> FirstJunctionLink_rel := min(order, per_JunctionLink);
			
			attribute<uint32> nrJunctions := pcount(per_JunctionLink);
			
			attribute<ZoneRingJunction> ZoneRingJunctionBase := cumulate(nrJunctions) - nrJunctions;
			
			attribute<ZoneRingPoint> ZoneRingPointBase := ZoneRingJunctionBase->ZoneRingPointBase;
			
			attribute<Geografie/point_rd> geometry(poly) := points2polygon(ClosedZoneRingPoint/geometry, ClosedZoneRingPoint/ZoneRing_rel, ClosedZoneRingPoint/Ring_ordinal);
			attribute<Float32> area := area(geometry, float32);
		}
		unit<uint32> ZoneRingJunction := range(uint32, 0, sum(ZoneRing/nrJunctions)) 
		{
			attribute<ZoneRing> ZoneRing_rel := classify(ID(.), ZoneRing/ZoneRingJunctionBase);
			attribute<uint32> ordinal := ID(.) - ZoneRing_rel->ZoneRingJunctionBase;
			
			attribute<JunctionLink> OrderedJunctionLink_rel := rlookup(ZoneRing_rel->FirstJunctionLink_rel + ordinal, ZoneRing/order);
			attribute<.> NextOrderedZoneRing_rel := invert(OrderedJunctionLink_rel)[OrderedJunctionLink_rel->next_rel];

			attribute<uint32> dist_from_first_JL := impedance_table('directed;startPoint(Node_rel);node:TraceBack'
					, const(1, ZoneRingJunction), ID(ZoneRingJunction), NextOrderedZoneRing_rel
					, ZoneRing/ZoneRingJunctionBase);
					
					
			attribute<JunctionLink> JunctionLink_rel := OrderedJunctionLink_rel[invert(ZoneRing_rel->ZoneRingJunctionBase + dist_from_first_JL)];
			
			attribute<JFLS2> JFLS2_rel := JunctionLink_rel->outJFLS2;
			attribute<bool> IsJFLS := IsDefined(JFLS2_rel);
			
			attribute<uint32> nrPoints := 
				IsJFLS 
					? sub_or_null(JFLS2_rel->NrSimplifiedPoints, 1)
					: IsDefined(JunctionLink_rel->other_rel_direct)
						? 1 
						: 2
				;
			
			attribute<uint32> ZoneRingPointBase := cumulate(nrPoints) - nrPoints;
		}
		// compose a ring from the JunctionLink geometries, either a JFSL2_Point sequence, the BoundaryPoint of F1, or the BoundaryPoint of F2 for doubleton_links
		unit<uint32> ZoneRingPoint := range(uint32, 0, sum(ZoneRingJunction/nrPoints))
		{
			attribute<ZoneRingJunction> ZoneRingJunction_rel := classify(ID(.), ZoneRingJunction/ZoneRingPointBase);
			attribute<ZoneRing> ZoneRing_rel := ZoneRingJunction_rel->ZoneRing_rel;
			attribute<uint32> Ring_ordinal := ID(.) - ZoneRing_rel->ZoneRingPointBase;
			attribute<uint32> RingJunction_ordinal := ID(.) - ZoneRingJunction_rel->ZoneRingPointBase;
			
			attribute<JunctionLink> JunctionLink_rel := ZoneRingJunction_rel->JunctionLink_rel;
			attribute<JFLS2> JFLS2_rel := JunctionLink_rel->outJFLS2;
			attribute<JFLS2_Point> JFLS2_Point_rel := JFLS2_rel->JFLS2_Point_Base + RingJunction_ordinal;
			attribute<BoundaryPoint> BP_rel := RingJunction_ordinal > 0 ? JunctionLink_rel->F2 : JunctionLink_rel->F1;
			attribute<Geografie/point_rd> geometry  := ZoneRingJunction_rel->IsJFLS 
				? JFLS2_Point_rel->geometry
				: BP_rel->Geometry;
		}
		// add a closing point to each ring equal to the first point of that ring.
		unit<uint32> ClosedZoneRingPoint := range(uint32, 0, sum(ZoneRingJunction/nrPoints)+#ZoneRing)
		{
			 attribute<Geografie/point_rd> geometry     := union_data(., ZoneRingPoint/geometry, ZoneRing/ZoneRingPointBase->geometry);
			 attribute<ZoneRing> ZoneRing_rel := union_data(., ZoneRingPoint/ZoneRing_rel, id(ZoneRing));
			 attribute<uint32>   Ring_ordinal := union_data(., ZoneRingPoint/Ring_ordinal, sum(ZoneRingJunction/nrPoints, ZoneRingJunction/ZoneRing_rel));
		}
		
		unit<uint32> Results := ZoneRing
		{
			attribute<Zone>               Zone_rel       := ZoneRing/FirstZone_rel, IntegrityCheck = "ZoneRing/CheckUniqueZonePerRing";
			attribute<Geografie/point_rd> geometry(poly) := ZoneRing/geometry;
		}
		
//		unit<uint32> SelectedRing := select(ZoneRing/FirstZone_rel == 1) // CUSTOMIZATION POINT: Which zones do we want: geometry van zone 0 negeren.
//		{
//			attribute<Geografie/point_rd> geometry(poly) := collect_by_cond(SelectedRing, ZoneRing/geometry);
//		}
	    // TODO: ringen met !IsDefined(Zone_rel) niet samenvoegen.
		// TODO: Losse ringen toevoegen
		// TODO: weglaten van lege ringen (met zero area)
		// TODO: bepaing orientation, dwz Outer Ring (area > 0) en inner ring (area < 0);
		// TODO: Zoneringen van dezelfde Zone samenvoegen van inner ringen met outer ring. na bepaling outer-ring
		
		
	}
	template MergePolygons_T {
		unit<uint32> PolygonDomain;
		unit<uint16> RegioDomain;
		attribute<Geografie/point_rd> geometry(PolygonDomain, poly);
		attribute<RegioDomain> Regio_rel(PolygonDomain);

		// TODO: Polygonen van dezelfde regio samenvoegen tot multi-polygons, in een afzonderlijke template
		attribute<Geografie/point_rd> result(RegioDomain, poly) := fpolygon(partitioned_union_polygon(ipolygon(geometry), Regio_rel));
	}

	container applications {
	
		attribute<bool> IsNL(Geografie/gridcel_100m/domain) := IsDefined(districts/m100/Districts);
		unit<uint16> NLZone := district_uint16(IsNl);
		
		container d100_NL := grid2poly_T(Geografie/gridcel_100m/domain, NLZone, NlZone/Districts, 100.0);
		
		container d100 := grid2poly_T(Geografie/gridcel_100m/domain, districts/m100, districts/m100/Districts, 100.0);
		container d50  := grid2poly_T(Geografie/gridcel_25m/domain,  districts/m25 , districts/m25/Districts,   50.0);
		container d10  := grid2poly_T(Geografie/gridcel_10m/domain,  districts/m10 , districts/m10/Districts,   10.0);
		

		container m100 := MergePolygons_T(d100/Results, SourceData/gemeente, d100/results/geometry, d100/results/Zone_rel->Regio_rel);
		container m50  := MergePolygons_T(d50/Results , SourceData/gemeente, d50/results/geometry , d50/results/Zone_rel->Regio_rel);
		container m10  := MergePolygons_T(d10/Results , SourceData/gemeente, d10/results/geometry , d10/results/Zone_rel->Regio_rel);
	}

	container ConfigSettings {
		container Overridable {
			parameter<string> CbsSourceDatadir := '%SourceDatadir%/CBS';
		}
	}
}