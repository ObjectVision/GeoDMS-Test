container Poly_2_grid_2_poly
{
	#include <eenheden.dms>
	#include <geografie.dms>

	container SourceData
	{
		unit<uint32> gemeente : StorageName = "%CbsSourceDatadir%/gemeente.shp", StorageType = "gdal.vect", StorageReadOnly = "True"
		{
			attribute<geografie/point_rd> geometry (poly);
			attribute<string> label := GM_NAAM;
		}
	}
	
	container GridData
	{
		attribute<SourceData/gemeente> m100 (Geografie/gridcel_100m/domain) := poly2grid(SourceData/gemeente/geometry, Geografie/gridcel_100m/domain);
		attribute<SourceData/gemeente> m25  (Geografie/gridcel_25m/domain)  := poly2grid(SourceData/gemeente/geometry, Geografie/gridcel_25m/domain);
		attribute<SourceData/gemeente> m10  (Geografie/gridcel_10m/domain)  := poly2grid(SourceData/gemeente/geometry, Geografie/gridcel_10m/domain);

		container districts
		{
			unit<uint32> m100 := district(GridData/m100);
			unit<uint32> m25  := district(GridData/m25);
			unit<uint32> m10  := district(GridData/m10);
		}
	}
	
	template vectorize {
		unit<spoint> domain_grid;
		attribute<uint32> zone_rel(domain_grid);
		
		// Segments := horizontale raster-randjes met ongelijke boven en onder zones + verticale raster-randjes met ongelijke linker en rechter zones
		unit<int16> rows := range(uint32, pointrow(lowerbound(domain_grid)), pointrow(upperbound(domain_grid)));
		unit<int16> cols := range(uint32, pointcol(lowerbound(domain_grid)), pointcol(upperbound(domain_grid)));
		
		unit<int16>  HorizontalLines := range(int16, lowerbound(rows), upperbound(rows)+1s);
		unit<int16>  VerticalLines   := range(int16, lowerbound(cols), upperbound(cols)+1s);
		
		unit<uint32> Point := combine(VerticalLines, HorizontalLines)
		{
			attribute<domain_grid> domain_grid_rel := point_xy(first_rel, second_rel, domain_grid); // the RasterCell NorthEast of this Point
			attribute<uint32> NrBoundarySegments := pcount(BoundarySegments/F1) + pcount(BoundarySegments/F2);
		}
		
		unit<uint32> HorizontalSegments := combine(cols, HorizontalLines)
		{
			attribute<domain_grid> left  := point_xy(first_rel   , second_rel, domain_grid);
			attribute<domain_grid> right := point_xy(first_rel+1s, second_rel, domain_grid);
			attribute<bool> isBoundary := MakeDefined(left->zone_rel, max(zone_rel)+1) != MakeDefined(right->zone_rel, max(zone_rel)+1);
			attribute<Point> F1 := combine_data(Point,  first_rel    [VerticalLines], second_rel);
			attribute<Point> F2 := combine_data(Point, (first_rel+1s)[VerticalLines], second_rel);
		}
		
		unit<uint32> VerticalSegments := combine(VerticalLines, rows)
		{
			attribute<domain_grid> left  := point_xy(first_rel, second_rel   , domain_grid);
			attribute<domain_grid> right := point_xy(first_rel, second_rel+1s, domain_grid);
			attribute<bool> isBoundary := MakeDefined(left->zone_rel, max(zone_rel)+1) != MakeDefined(right->zone_rel, max(zone_rel)+1);
			attribute<Point> F1 := combine_data(Point, first_rel,  second_rel    [HorizontalLines]);
			attribute<Point> F2 := combine_data(Point, first_rel, (second_rel+1s)[HorizontalLines]);
		}
		
		
		unit<uint32> HorizontalBoundarySegments := select(HorizontalSegments/isBoundary);
		unit<uint32> VerticalBoundarySegments := select(verticalSegments/isBoundary);
		
		unit<uint32> BoundarySegments := union_unit(HorizontalBoundarySegments, VerticalBoundarySegments)
		{
			attribute<domain_grid> left  := union_data(., collect_by_cond(HorizontalBoundarySegments, HorizontalSegments/left) , collect_by_cond(VerticalBoundarySegments, VerticalSegments/left));
			attribute<domain_grid> right := union_data(., collect_by_cond(HorizontalBoundarySegments, HorizontalSegments/right), collect_by_cond(VerticalBoundarySegments, VerticalSegments/right));
			attribute<Point> F1 := union_data(., collect_by_cond(HorizontalBoundarySegments, HorizontalSegments/F1), collect_by_cond(VerticalBoundarySegments, VerticalSegments/F1));
			attribute<Point> F2 := union_data(., collect_by_cond(HorizontalBoundarySegments, HorizontalSegments/F2), collect_by_cond(VerticalBoundarySegments, VerticalSegments/F2));
		}
		
		// JFN := raster-hoekpunten waarop 2 segments uit komen
		
		unit<uint32> JFN := select(Point/NrBoundarySegments == 2);
		
		// JFL := Segments die 2 JFN verbinden
		unit<uint32> JFL := select(BoundarySegments/F1->NrBoundarySegments == 2 && BoundarySegments/F2->NrBoundarySegments == 2);
		
		// JFS := serie verbonden JFL
		// JFS/Linestring := d.m.v. impedance_single van alle begin JFS naar eind JFS routes, traceback, flow voor ordinal t.b.v. points2sequence
		// Junction := raster-hoekpunt waarop meer dan 2 segmenten uit komen (1 komt niet voor)
		// Connector := Segment tussen een Junction en een JFN
		// JFS/Linestring := begin connector + result(5) + end connector; eventueel deze simplifyen
		// ZoneJunction := kruistabel met junctions en zones;
		// ZoneBorder := link tussen 2 junctions bij een zone die door een segment of JFS/Linestring verbonden zijn
		// bepaal per zone de 1e ZoneJunction en 1 via een ZoneBorder verbonden 2e ZoneJunction
		// routeer de andere ZoneJunctions min of meer conform stap 5.
		// gebruik 12 om resultaten van 9 achter elkaar te plakken per zone.
		
	}
	
	container applications {
		container d100 := vectorize(Geografie/gridcel_100m/domain, GridData/districts/m100/Districts);
		container d50  := vectorize(Geografie/gridcel_25m/domain,  GridData/districts/m25/Districts);
		container d10  := vectorize(Geografie/gridcel_10m/domain,  GridData/districts/m10/Districts);
		
		container m100 := vectorize(Geografie/gridcel_100m/domain, GridData/m100);
		container m50  := vectorize(Geografie/gridcel_25m/domain,  GridData/m25);
		container m10  := vectorize(Geografie/gridcel_10m/domain,  GridData/m10);
	}
	container ConfigSettings {
		container Overridable {
			parameter<string> CbsSourceDatadir := '%SourceDatadir%/CBS';
		}
	}
}