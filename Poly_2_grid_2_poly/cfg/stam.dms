container Poly_2_grid_2_poly
{
	#include <eenheden.dms>
	#include <geografie.dms>

	container SourceData{
		unit<uint16> gemeente_bron : StorageName = "%CbsSourceDatadir%/gemeente.shp", StorageType = "gdal.vect", StorageReadOnly = "True"
		{
			attribute<geografie/point_rd> geometry (poly);
			attribute<string> label := GM_NAAM;
		}
		unit<uint16> gemeente := select(IsDefined(gemeente_bron/GM_NAAM))
		{
			attribute<geografie/point_rd> geometry (poly) := collect_by_cond(., gemeente_bron/geometry);
			attribute<string> label := collect_by_cond(., gemeente_bron/label);
		}
		unit<uint16> nl := range(uint16, 0w, 1w)
		{
			attribute<geografie/point_rd> geometry (poly) := union_data(., fpolygon(union_polygon(ipolygon(gemeente/geometry))));
		}
	}
	
	template grid2poly_T {
		unit<spoint> domain_grid;
		unit<uint16> Zone;
		attribute<Zone> zone_rel(domain_grid);
		parameter<float64> simplifyFactor;
		
		parameter<Zone> NoZone := uint16(#Zone)+lowerbound(Zone); // outside study area indicator
		
		// Segments := horizontale raster-randjes met ongelijke boven en onder zones + verticale raster-randjes met ongelijke linker en rechter zones
		unit<int16> rows := range(uint32, pointrow(lowerbound(domain_grid)), pointrow(upperbound(domain_grid)));
		unit<int16> cols := range(uint32, pointcol(lowerbound(domain_grid)), pointcol(upperbound(domain_grid)));
		
		unit<int16>  HorizontalLine := range(int16, lowerbound(rows), upperbound(rows)+1s);
		unit<int16>  VerticalLine   := range(int16, lowerbound(cols), upperbound(cols)+1s);
		
		unit<uint32> Point := combine(VerticalLine, HorizontalLine)
		{
			attribute<geografie/point_rd> geometry := domain_grid_rel[geografie/point_rd];
			attribute<domain_grid> domain_grid_rel := point_xy(first_rel, second_rel, domain_grid); // the RasterCell NorthEast of this Point
			attribute<bool> isBoundaryPoint := has_any(BoundarySegment/F1) || has_any(BoundarySegment/F2);
			attribute<BoundaryPoint> BoundaryPoint_rel := invert(BoundaryPoint/org_rel);
		}
		unit<uint32> BoundaryPoint := select_with_org_rel(Point/isBoundaryPoint)
		{
			attribute<geografie/point_rd> geometry := org_rel->geometry;
			attribute<uint32> NrBoundarySegments := pcount(BoundarySegment/bp_F1) + pcount(BoundarySegment/bp_F2);
			attribute<bool>   isJunction := NrBoundarySegments != 2; // Junction := raster-hoekpunt waarop meer dan 2 segmenten uit komen (1 kan niet voor komen)
			
//			attribute<uint32> NrJFSegment := pcount(JFSegment/F1) + pcount(JFSegment/F2);
			
			attribute<BoundarySegment> FirstLink := MakeDefined(first(ID(BoundarySegment), BoundarySegment/bp_F1), first(ID(BoundarySegment), BoundarySegment/bp_F2));
			attribute<BoundarySegment> Last_Link := MakeDefined(last (ID(BoundarySegment), BoundarySegment/bp_F2), last (ID(BoundarySegment), BoundarySegment/bp_F1));
		}
		
		unit<uint32> HorizontalSegment := combine(cols, HorizontalLine)
		{
			attribute<domain_grid> North  := point_xy(first_rel, second_rel-1s, domain_grid);
			attribute<domain_grid> South  := point_xy(first_rel, second_rel   , domain_grid);
			attribute<bool> isBoundarySegment := MakeDefined(south->zone_rel, NoZone) != MakeDefined(North->zone_rel, NoZone);
			attribute<Point> F1 := combine_data(Point,  first_rel    [VerticalLine], second_rel);
			attribute<Point> F2 := combine_data(Point, (first_rel+1s)[VerticalLine], second_rel);
		}
		
		unit<uint32> VerticalSegment := combine(VerticalLine, rows)
		{
			attribute<domain_grid> West := point_xy(first_rel-1s, second_rel, domain_grid);
			attribute<domain_grid> East := point_xy(first_rel   , second_rel, domain_grid);
			attribute<bool> isBoundarySegment := MakeDefined(West->zone_rel, max(zone_rel)+1w) != MakeDefined(East->zone_rel, max(zone_rel)+1w);
			attribute<Point> F1 := combine_data(Point, first_rel,  second_rel    [HorizontalLine]);
			attribute<Point> F2 := combine_data(Point, first_rel, (second_rel+1s)[HorizontalLine]);
		}
		
		unit<uint32> HorizontalBoundarySegment := select(HorizontalSegment/isBoundarySegment)
		{
			attribute<domain_grid> North := collect_by_cond(., HorizontalSegment/North);
			attribute<domain_grid> South := collect_by_cond(., HorizontalSegment/South);
			attribute<Point>       F1    := collect_by_cond(., HorizontalSegment/F1);
			attribute<Point>       F2    := collect_by_cond(., HorizontalSegment/F2);
		}
		unit<uint32> VerticalBoundarySegment := select(verticalSegment/isBoundarySegment)
		{
			attribute<domain_grid> East  := collect_by_cond(., VerticalSegment/East);
			attribute<domain_grid> West  := collect_by_cond(., VerticalSegment/West);
			attribute<Point>       F1    := collect_by_cond(., VerticalSegment/F1);
			attribute<Point>       F2    := collect_by_cond(., VerticalSegment/F2);
		}
		
		unit<uint2> Direction {
			attribute<string> Label : [ 'North', 'East', 'South', 'West'];
			container V:= for_each_nedv(Label, string(ID(.))+'[..]', void, .);
			attribute<.> Next    := union_data(., V/West, V/North, V/East, V/South);
			attribute<.> Reverse := union_data(., V/South, V/West, V/North, V/East);
		}
		unit<uint32> BoundarySegment := union_unit(HorizontalBoundarySegment, VerticalBoundarySegment)
		{
			attribute<Direction> Direction_rel := union_data(., const(Direction/V/South, HorizontalBoundarySegment), const(Direction/V/East, VerticalBoundarySegment));
			
			unit<uint32> BS_Point := union_unit(BoundarySegment, BoundarySegment)
			{				
				attribute<Geografie/point_rd> geometry   := union_data(BS_Point, F1->geometry, F2->geometry);
				attribute<BoundarySegment> BoundarySegment_rel := union_data(BS_Point, ID(BoundarySegment), ID(BoundarySegment));
			}
			
			attribute<uint32> NrIntermediatePoints := pcount(IntermediatePoint/Ra) + pcount(IntermediatePoint/Rb);
			
			attribute<Geografie/point_rd> geometry(arc) := points2sequence(BS_Point/geometry, BS_Point/BoundarySegment_rel);
			attribute<domain_grid> left  := union_data(., HorizontalBoundarySegment/North, VerticalBoundarySegment/East);
			attribute<domain_grid> right := union_data(., HorizontalBoundarySegment/South, VerticalBoundarySegment/West);
			attribute<Direction> Dir_rel := union_data(., const(Direction/V/East ,HorizontalBoundarySegment), const(Direction/V/South ,VerticalBoundarySegment));
			attribute<Point> F1 := union_data(., HorizontalBoundarySegment/F1, VerticalBoundarySegment/F1);
			attribute<Point> F2 := union_data(., HorizontalBoundarySegment/F2, VerticalBoundarySegment/F2);
			attribute<BoundaryPoint> bp_F1 := F1->BoundaryPoint_rel; 
			attribute<BoundaryPoint> bp_F2 := F2->BoundaryPoint_rel; 
			attribute<bool> f1IsJunction := bp_F1->isJunction;
			attribute<bool> f2IsJunction := bp_F2->isJunction;
//			attribute<bool> isJFSegment := not(f1IsJunction) && not(f2IsJunction); // intermediate in linestring
			
			attribute<Zone> left_Zone_rel := zone_rel[left];
			attribute<Zone> rightZone_rel := zone_rel[right];
			
			attribute<JFSection> JFSection_rel := JFSection/PartNr;
		}
		unit<uint32> IntermediatePoint := select_with_org_rel(not(BoundaryPoint/isJunction))
		{
			attribute<BoundaryPoint> BoundaryPoint_rel := org_rel;
			attribute<BoundarySegment> Ra := collect_by_cond(IntermediatePoint, BoundaryPoint/FirstLink);
			attribute<BoundarySegment> Rb := collect_by_cond(IntermediatePoint, BoundaryPoint/Last_Link);
			attribute<bool> IsOke := IsDefined(Ra) && IsDefined(Rb) && Ra != Rb;
		}
		
		unit<uint32> Junction := select_with_org_rel(BoundaryPoint/isJunction)
		{
			attribute<geografie/point_rd> geometry := collect_by_cond(Junction, BoundaryPoint/geometry);
			attribute<.> per_node(BoundaryPoint) := invert(org_rel);
		}
		
		// JFSegment (aka Junction Free Links) := Segments die 2 JFN verbinden
/*		
		unit<uint32> JFSegment := select(BoundarySegment/isJFSegment)
		{
			attribute<BoundaryPoint> F1 := collect_by_cond(JFSegment, BoundarySegment/bp_F1);
			attribute<BoundaryPoint> F2 := collect_by_cond(JFSegment, BoundarySegment/bp_F2);
			
			attribute<Zone> left_Zone_rel := collect_by_cond(JFSegment, BoundarySegment/left_Zone_rel);
			attribute<Zone> rightZone_rel := collect_by_cond(JFSegment, BoundarySegment/rightZone_rel);
		}
*/		
		// Connector := Segment tussen een Junction en een JFN of een andere Junction
		unit<uint32> FromJunctionLink := select_with_org_rel(BoundarySegment/f1IsJunction)
		{
			attribute<BoundarySegment> BoundarySegment_rel := org_rel;
			attribute<BoundaryPoint> F1 := collect_by_cond(FromJunctionLink, BoundarySegment/bp_F1);
			attribute<BoundaryPoint> F2 := collect_by_cond(FromJunctionLink, BoundarySegment/bp_F2);
			attribute<Direction>     Dir_rel := collect_by_cond(FromJunctionLink, BoundarySegment/Dir_rel);
			
			attribute<Junction> Junction_rel := Junction/per_node[F1];
			
			attribute<Zone> left_Zone_rel := collect_by_cond(FromJunctionLink, BoundarySegment/left_Zone_rel);
			attribute<Zone> rightZone_rel := collect_by_cond(FromJunctionLink, BoundarySegment/rightZone_rel);
		}
		unit<uint32> ToJunctionLink := select_with_org_rel(BoundarySegment/f2IsJunction)
		{
			attribute<BoundarySegment> BoundarySegment_rel := org_rel;
			attribute<BoundaryPoint> F1 := collect_by_cond(ToJunctionLink, BoundarySegment/bp_F1);
			attribute<BoundaryPoint> F2 := collect_by_cond(ToJunctionLink, BoundarySegment/bp_F2);
			attribute<Direction>     Org_dir_rel := collect_by_cond(ToJunctionLink, BoundarySegment/Dir_rel);
			attribute<Direction>     Dir_rel := Org_dir_rel->Direction/Reverse;
			
			attribute<Junction> Junction_rel := Junction/per_node[F2];
			attribute<Zone> left_Zone_rel := collect_by_cond(ToJunctionLink, BoundarySegment/left_Zone_rel);
			attribute<Zone> rightZone_rel := collect_by_cond(ToJunctionLink, BoundarySegment/rightZone_rel);
		}
		
		unit<uint32> JunctionDirection := combine_unit(Junction, Direction);
		
		unit<uint32> JunctionLink := union_unit(FromJunctionLink, ToJunctionLink)
		{
			attribute<Geografie/point_rd> Junction_geometry := Junction_rel->Geometry;
			attribute<BoundarySegment> BoundarySegment_rel := union_data(., FromJunctionLink/BoundarySegment_rel, ToJunctionLink/BoundarySegment_rel);
			
			unit<uint32> JL_Point := union_unit(JunctionLink, JunctionLink)
			{				
				attribute<Geografie/point_rd> geometry   := union_data(JL_Point, F1->geometry, F2->geometry);
				attribute<JunctionLink> JunctionLink_rel := union_data(JL_Point, ID(JunctionLink), ID(JunctionLink));
			}
			
			attribute<Geografie/point_rd> geometry(arc) := points2sequence(JL_Point/geometry, JL_Point/JunctionLink_rel);
			
			attribute<BoundaryPoint> F1   := union_data(., FromJunctionLink/F1, ToJunctionLink/F2);
			attribute<BoundaryPoint> F2   := union_data(., FromJunctionLink/F2, ToJunctionLink/F1);
			attribute<Direction>     Dir_rel := union_data(., FromJunctionLink/Dir_rel, ToJunctionLink/Dir_rel);
			attribute<Direction>     NextDir_rel := Dir_rel->Next;
			attribute<Direction>     NextNextDir_rel := Dir_rel->Reverse;
			attribute<Junction>      Junction_rel := rlookup(F1, Junction/org_rel);
			
			attribute<Zone> left_Zone_rel := union_data(., FromJunctionLink/left_Zone_rel, ToJunctionLink/rightZone_rel);
			attribute<Zone> rightZone_rel := union_data(., FromJunctionLink/rightZone_rel, ToJunctionLink/left_Zone_rel );
			
			attribute<JunctionDirection> JunctionDirection_rel := combine_data(JunctionDirection, Junction_rel, Dir_rel);
			attribute<JunctionDirection> NextJunctionDirection_rel := combine_data(JunctionDirection, Junction_rel, NextDir_rel);
			attribute<JunctionDirection> NextNextJunctionDirection_rel := combine_data(JunctionDirection, Junction_rel, NextNextDir_rel);
			attribute<JunctionLink> n1_JL := rlookup(NextJunctionDirection_rel, JunctionDirection_rel);
			attribute<JunctionLink> n2_JL := rlookup(NextNextJunctionDirection_rel, JunctionDirection_rel);
			attribute<JunctionLink> next_JL := MakeDefined(n1_JL, n2_JL);
			
			attribute<JFLS2> outJFLS2 := invert(JFLS2/JL_rel);
			
			attribute<.> other_rel := outJFLS2->Other_rel;
			attribute<.> next_rel  := other_rel->next_JL;
		}
		
		
		// Junction Free Section := clusters van BoundarySegments
		unit<uint32> JFSection := connected_parts(intermediatePoint/Ra, intermediatePoint/Rb)
		{
			attribute<uint32> nr_BoundarySegments := pcount(PartNr);
			
			attribute<uint8> NrEnds := sum_uint8(2 - BoundarySegment/NrIntermediatePoints, PartNr);
			attribute<bool> isLineString := NrEnds == 2b; // it could also be a ring without any Junction
			
			attribute<.> per_IntermediatePoint(IntermediatePoint) := MakeDefined(BoundarySegment/JFSection_rel[IntermediatePoint/Ra], BoundarySegment/JFSection_rel[IntermediatePoint/Rb]);
		}
		
		unit<uint32> JFRing  := select_with_org_rel(not(JFSection/isLineString))
		{
			attribute<JFSection>  JFSection_rel  := org_rel;
			attribute<BoundarySegment> JFSection_firstBS_rel(JFSection) :=  min_index(ID(BoundarySegment), JFSection/PartNr);
			attribute<BoundarySegment> firstBoundarySegment_rel := lookup(JFSection_rel, JFSection_firstBS_rel);
			attribute<BoundaryPoint>   firstBoundaryPoint_rel   := firstBoundarySegment_rel->bp_F1;
			
			attribute<bool> IsOke := firstBoundarySegment_rel->Direction_rel == Direction/V/South; // follows from the order or Points and Segments

			attribute<bool> BoundarySegment_IsNotFirstRingSegment(BoundarySegment) := !IsDefined(invert(firstBoundarySegment_rel));
//			attribute<bool> BoundaryPoint_IsNotFirstRingPoint(BoundaryPoint) := BoundarySegment_IsNotFirstRingSegment[BoundaryPoint/Ra];
			
			// abuse the fact that the first segment of a ring is always North to South and therefore right is outside en left is inside.
			attribute<Zone> left_Zone_rel := firstBoundarySegment_rel->rightZone_rel;
			attribute<Zone> rightZone_rel := firstBoundarySegment_rel->left_Zone_rel;
			
			unit<uint32> ReducedBoundarySegment := select(not(BoundarySegment/JFSection_rel->isLineString) && BoundarySegment_IsNotFirstRingSegment)
			{
				attribute<BoundaryPoint> F1 := collect_by_cond(., BoundarySegment/bp_F1);
				attribute<BoundaryPoint> F2 := collect_by_cond(., BoundarySegment/bp_F2);
			}
			
			// TODO: only do these things per ring points as there are much less RingPoints than BoundaryPoints
			
//			attribute<.> per_IntermediatePoint(IntermediatePoint) := invert(JFSection_rel)[MakeDefined(BoundarySegment/JFSection_rel[IntermediatePoint/Ra], BoundarySegment/JFSection_rel[IntermediatePoint/Rb])];
			attribute<.> per_IntermediatePoint(IntermediatePoint) := invert(JFSection_rel)[JFSection/per_IntermediatePoint];
			attribute<.> per_BoundaryPoint(BoundaryPoint) := lookup(invert(intermediatePoint/org_rel), per_IntermediatePoint); // TODO: recollect_by_cond and remove org_rel
//			attribute<BoundaryPoint> firstBP_rel := min(JFPath/BoundaryPoint_rel, org_rel);
			
			// as the first segment has been removed, the remaining segments form a clock-wise path from the first BoundaryPoint to the other side of the removed segment
			attribute<uint32> dist_from_first_BP(BoundaryPoint) := impedance_table('bidirectional;startPoint(Node_rel);node:TraceBack'
					, const(1, ReducedBoundarySegment), ReducedBoundarySegment/F1, ReducedBoundarySegment/F2, firstBoundaryPoint_rel);
					
			unit<uint32> Point := select(IsDefined(dist_from_first_BP))
			{
				attribute<Geografie/point_rd> geometry := collect_by_cond(Point, BoundaryPoint/Geometry);
				attribute<JFRing> sequence_rel := collect_by_cond(Point, per_BoundaryPoint);
				attribute<uint32> ordinal := collect_by_cond(Point, dist_from_first_BP);
			}
			attribute<Geografie/point_rd> geometry(poly) := points2polygon(Point/geometry, Point/sequence_rel, Point/ordinal);
			attribute<float32> area := area(geometry, float32);
			attribute<Geografie/point_rd> SimplifiedRing(poly) := bg_simplify_polygon(geometry, simplifyFactor);
			attribute<float32> simplified_area := area(SimplifiedRing, float32);
		}
		unit<uint32> NonEmptyJFRing := select(abs(JFRing/simplified_area) > 100f)
		{
			attribute<Geografie/point_rd> geometry      (poly) := collect_by_cond(NonEmptyJFRing, JFRing/geometry);
			attribute<Geografie/point_rd> SimplifiedRing(poly) := collect_by_cond(NonEmptyJFRing, JFRing/SimplifiedRing);
			attribute<Zone> left_Zone_rel := collect_by_cond(., JFRing/left_Zone_rel);
			attribute<Zone> rightZone_rel := collect_by_cond(., JFRing/rightZone_rel);
			
			unit<uint32> Point := sequence2points(SimplifiedRing);
			attribute<Geografie/point_rd> SimplifiedReversedRing(poly) := points2polygon(Point/Point, Point/sequence_rel, (pcount(Point/sequence_rel) - 1)[Point/sequence_rel] - Point/ordinal);
		}
		
		unit<uint32> JFLineString := select_with_org_rel(JFSection/isLineString) // JunctionFree LineString
		{
			attribute<JunctionLink> firstJL_rel := collect_by_cond(., first(ID(JunctionLink), JunctionLink/BoundarySegment_rel->JFSection_rel));
			attribute<JunctionLink> last_JL_rel := collect_by_cond(., last (ID(JunctionLink), JunctionLink/BoundarySegment_rel->JFSection_rel));
			
			attribute<BoundaryPoint> firstBP_rel  := firstJL_rel->F1;
			attribute<BoundaryPoint> secondBP_rel := firstJL_rel->F2;
			attribute<BoundaryPoint> last_BP_rel  := last_JL_rel->F2; // just before the end of the last segment !!!
			
			// JFSection/Linestring := d.m.v. impedance_single van alle begin JFSection naar eind JFSection routes t.b.v. points2sequence
			attribute<BoundarySegment> last_BoundarySegment := last_JL_rel->BoundarySegment_rel;
			attribute<BoundarySegment> firstBoundarySegment := firstJL_rel->BoundarySegment_rel;
			unit<uint32> ReducedBoundarySegment := select(BoundarySegment/JFSection_rel->isLineString && !IsDefined(invert(last_BoundarySegment)) && !IsDefined(invert(firstBoundarySegment)))
			{
				attribute<BoundaryPoint> F1 := collect_by_cond(., BoundarySegment/bp_F1);
				attribute<BoundaryPoint> F2 := collect_by_cond(., BoundarySegment/bp_F2);
			}			
			
			attribute<uint32> dist_from_first_BP(BoundaryPoint) := impedance_table('bidirectional;startPoint(Node_rel);node:TraceBack'
					, const(1, ReducedBoundarySegment), ReducedBoundarySegment/F1, ReducedBoundarySegment/F2, secondBP_rel);
					
			unit<uint32> Point := select_with_org_rel(IsDefined(dist_from_first_BP))
			{
				attribute<BoundaryPoint> BoundaryPoint_rel := org_rel;
				attribute<IntermediatePoint> IntermediatePoint_rel := invert(IntermediatePoint/BoundaryPoint_rel)[BoundaryPoint_rel];
				attribute<BoundarySegment>  BoundarySegmentA_rel := IntermediatePoint_rel->Ra;
				attribute<Geografie/point_rd> geometry := collect_by_cond(Point, BoundaryPoint/Geometry);
				attribute<JFLineString> sequence_rel := invert(JFLineString/org_rel)[BoundarySegmentA_rel->JFSection_rel];
				attribute<uint32> ordinal := collect_by_cond(Point, dist_from_first_BP);
			}
			attribute<uint32> NrPoints := pcount(Point/sequence_rel) > 0 ? max(Point/ordinal, Point/sequence_rel) + 1 : 0;
			unit<uint32> PointwithConnectors := union_unit(JFLineString, Point, JFLineString)
			{
				attribute<Geografie/point_rd> geometry := union_data(., firstJL_rel->Junction_geometry, Point/geometry, last_JL_rel->Junction_geometry);
				attribute<JFLineString>   sequence_rel := union_data(., id(JFLineString), Point/sequence_rel, id(JFLineString));
				attribute<uint32> ordinal      := union_data(., const(0, JFLineString), Point/ordinal+1, NrPoints+1);
			}
			
			attribute<Geografie/point_rd> LineString(arc) := points2sequence(Point/geometry, Point/sequence_rel, Point/ordinal);
			attribute<Geografie/point_rd> LineStringWithConnectors(arc) := points2sequence(PointwithConnectors/geometry, PointwithConnectors/sequence_rel, PointwithConnectors/ordinal);
			attribute<Geografie/point_rd> SimplifiedLineString(arc) := bg_simplify_linestring(LineStringWithConnectors, simplifyFactor);

			unit<uint32> SimplifiedPoints := sequence2points(SimplifiedLineString);
			attribute<uint32> SimplifiedPointOrdinalMax := max(SimplifiedPoints/ordinal, SimplifiedPoints/Sequence_rel);
			attribute<uint32> NrSimplifiedPoints := SimplifiedPointOrdinalMax+1;
			attribute<SimplifiedPoints> SimplifiedPointBase := value(cumulate(NrSimplifiedPoints) - NrSimplifiedPoints, SimplifiedPoints);
		}
/*
		unit<uint32> Path := union_unit(JFLineString, NonEmptyJFRing)
		{
			attribute<JunctionLink> firstJL_rel := union_data(Path, JFLineString/firstJL_rel, const(null_u, NonEmptyJFRing));
			attribute<JunctionLink> last_JL_rel := union_data(Path, JFLineString/last_JL_rel, const(null_u, NonEmptyJFRing));
			attribute<Geografie/point_rd> SimplifiedPath(arc) := union_data(Path, JFLineString/SimplifiedLineString, NonEmptyJFRing/SimplifiedRing);
//			attribute<uint32>       NrSimplifiedPoints := union_data(path, JFLineString/NrSimplifiedPoints, JFRing/NrSimplifiedPoints);

			unit<uint32> SimplifiedPoints := sequence2points(SimplifiedPath);
			attribute<uint32> SimplifiedPointOrdinalMax := max(SimplifiedPoints/ordinal, SimplifiedPoints/Sequence_rel);
			attribute<uint32> NrSimplifiedPoints := SimplifiedPointOrdinalMax+1;
			attribute<SimplifiedPoints> SimplifiedPointBase := value(cumulate(NrSimplifiedPoints) - NrSimplifiedPoints, SimplifiedPoints);
		}
*/
		unit<uint32>  pathSrc := JFLineString;
		
		unit<uint32>  JFLS2 := union_unit(pathSrc, pathSrc)
		{
			attribute<JunctionLink> JL_rel    := union_data(., pathSrc/firstJL_rel, pathSrc/last_JL_rel);
			attribute<uint32>       NrSimplifiedPoints := union_data(., pathSrc/NrSimplifiedPoints, pathSrc/NrSimplifiedPoints);
			attribute<JunctionLink> Other_rel := union_data(., pathSrc/last_JL_rel, pathSrc/firstJL_rel);
			attribute<JFLS2_Point>  JFLS2_Point_Base := cumulate(NrSimplifiedPoints) - NrSimplifiedPoints;
		}
		unit<uint32> JFLS2_Point := range(uint32, 0, sum(JFLS2/NrSimplifiedPoints))
		{
			attribute<JFLS2> JFLS2_rel := classify(ID(.), JFLS2/JFLS2_Point_Base);
			attribute<uint32> ordinal := ID(.) - JFLS2_rel;
			attribute<pathSrc/SimplifiedPoints> SimplifiedPoint_rel := union_data(.
				, pathSrc/SimplifiedPointBase[pathSrc/SimplifiedPoints/Sequence_rel] + pathSrc/SimplifiedPoints/ordinal
				, (pathSrc/SimplifiedPointBase+pathSrc/SimplifiedPointOrdinalMax)[pathSrc/SimplifiedPoints/Sequence_rel] - pathSrc/SimplifiedPoints/ordinal);
			attribute<Geografie/point_rd> geometry  := SimplifiedPoint_rel->Point;
		}
		unit<uint32> ZoneRing := connected_parts(ID(JunctionLink), JunctionLink/next_rel)
		{
			attribute<.> per_JunctionLink(JunctionLink) := PartNr;
			attribute<JunctionLink> index(JunctionLink) := index(PartNr);
			attribute<JunctionLink> order(JunctionLink) := invert(index);
			
			attribute<Zone> FirstZone_rel := first(JunctionLink/rightZone_rel, per_JunctionLink);
			attribute<Zone> FirstZone_per_JunctionLink(JunctionLink) := per_JunctionLink->FirstZone_rel;
			attribute<bool> CheckUniqueZonePerRing(JunctionLink) := or(JunctionLink/rightZone_rel == FirstZone_per_JunctionLink,  not(or(IsDefined(JunctionLink/rightZone_rel), IsDefined(FirstZone_per_JunctionLink))));
			
			attribute<JunctionLink> FirstJunctionLink_rel := min(order, per_JunctionLink);
			
			attribute<uint32> nrJunctions := pcount(per_JunctionLink);
			
			attribute<ZoneRingJunction> ZoneRingJunctionBase := cumulate(nrJunctions) - nrJunctions;
			
			attribute<ZoneRingPoint> ZoneRingPointBase := ZoneRingJunctionBase->ZoneRingPointBase;
			
			attribute<Geografie/point_rd> geometry(poly) := points2polygon(ClosedZoneRingPoint/geometry, ClosedZoneRingPoint/ZoneRing_rel, ClosedZoneRingPoint/Ring_ordinal);
			attribute<Float32> area := area(geometry, float32);
		}

		unit<uint32> ZoneRingJunction := range(uint32, 0, sum(ZoneRing/nrJunctions)) 
		{
			attribute<ZoneRing> ZoneRing_rel := classify(ID(.), ZoneRing/ZoneRingJunctionBase);
			attribute<uint32> ordinal := ID(.) - ZoneRing_rel->ZoneRingJunctionBase;
			
			attribute<JunctionLink> OrderedJunctionLink_rel := rlookup(ZoneRing_rel->FirstJunctionLink_rel + ordinal, ZoneRing/order);
			attribute<JunctionLink> NextJunctionLink_rel    := OrderedJunctionLink_rel->next_rel;
			
			attribute<.> per_JunctionLink(JunctionLink) := invert(OrderedJunctionLink_rel);
			attribute<.> NextOrderedZoneRing_rel := per_JunctionLink[NextJunctionLink_rel];

			attribute<uint32> dist_from_first_JL := impedance_table('directed;startPoint(Node_rel);node:TraceBack'
					, const(1, ZoneRingJunction), ID(ZoneRingJunction), NextOrderedZoneRing_rel
					, ZoneRing/ZoneRingJunctionBase);
					
					
			attribute<JunctionLink> JunctionLink_rel := OrderedJunctionLink_rel[invert(ZoneRing_rel->ZoneRingJunctionBase + dist_from_first_JL)];
			
			attribute<JFLS2> JFLS2_rel := JunctionLink_rel->outJFLS2;			
			attribute<uint32> nrPoints := sub_or_null(JFLS2_rel->NrSimplifiedPoints, 1);
			
			attribute<uint32> ZoneRingPointBase := cumulate(nrPoints) - nrPoints;
		}
		// compose a ring from the JunctionLink geometries, either a JFSL2_Point sequence, the BoundaryPoint of F1, or the BoundaryPoint of F2 for doubleton_links
		unit<uint32> ZoneRingPoint := range(uint32, 0, sum(ZoneRingJunction/nrPoints))
		{
			attribute<ZoneRingJunction> ZoneRingJunction_rel := classify(ID(.), ZoneRingJunction/ZoneRingPointBase);
			attribute<ZoneRing> ZoneRing_rel := ZoneRingJunction_rel->ZoneRing_rel;
			attribute<uint32> Ring_ordinal := ID(.) - ZoneRing_rel->ZoneRingPointBase;
			attribute<uint32> RingJunction_ordinal := ID(.) - ZoneRingJunction_rel->ZoneRingPointBase;
			
			attribute<JunctionLink> JunctionLink_rel := ZoneRingJunction_rel->JunctionLink_rel;
			attribute<JFLS2> JFLS2_rel := JunctionLink_rel->outJFLS2;
			attribute<JFLS2_Point> JFLS2_Point_rel := JFLS2_rel->JFLS2_Point_Base + RingJunction_ordinal;
//			attribute<BoundaryPoint> BP_rel := RingJunction_ordinal > 0 ? JunctionLink_rel->F2 : JunctionLink_rel->F1;
			attribute<Geografie/point_rd> geometry  := JFLS2_Point_rel->geometry;
		}
		// add a closing point to each ring equal to the first point of that ring.
		unit<uint32> ClosedZoneRingPoint := range(uint32, 0, sum(ZoneRingJunction/nrPoints)+#ZoneRing)
		{
			 attribute<Geografie/point_rd> geometry     := union_data(., ZoneRingPoint/geometry, ZoneRing/ZoneRingPointBase->geometry);
			 attribute<ZoneRing> ZoneRing_rel := union_data(., ZoneRingPoint/ZoneRing_rel, id(ZoneRing));
			 attribute<uint32>   Ring_ordinal := union_data(., ZoneRingPoint/Ring_ordinal, sum(ZoneRingJunction/nrPoints, ZoneRingJunction/ZoneRing_rel));
			 attribute<Zone>     Zone_rel     := ZoneRing_rel->FirstZone_rel;
		}
		
/*		
		unit<uint32> ClosedZonePoint := range(uint32, 0, #ClosedZoneRingPoint + #ZoneRing - #Zone)
		{
			 attribute<Geografie/point_rd> geometry     := union_data(., ClosedZoneRingPoint->geometry, xxx);
			 attribute<Zone> Zone_rel := union_data(., ClosedZoneRingPoint/Zone_rel, xxx);
			 attribute<uint32>   Zone_ordinal := union_data(., ClosedZoneRingPoint/Ring_ordinal + ClosedZoneRingPoint/ZoneRing_rel->ClosedZoneRingPointBase, xxx);
		}
*/		
		unit<uint32> RingResults := union_unit(ZoneRing, NonEmptyJFRing, NonEmptyJFRing)
		{
			attribute<Geografie/point_rd> geometry(poly) := union_data(., ZoneRing/geometry, NonEmptyJFRing/SimplifiedRing, NonEmptyJFRing/SimplifiedReversedRing);
			attribute<Zone> Zone_rel := union_data(., ZoneRing/FirstZone_rel, NonEmptyJFRing/RightZone_rel, NonEmptyJFRing/Left_Zone_rel), IntegrityCheck = "ZoneRing/CheckUniqueZonePerRing";
		}
		
		unit<uint16> Results := Zone
		{
			attribute<Geografie/point_rd> geometry(poly) := fpolygon(partitioned_union_polygon(ipolygon(RingResults/geometry), RingResults/Zone_rel));
		}
		
//		unit<uint32> SelectedRing := select(ZoneRing/FirstZone_rel == 1) // CUSTOMIZATION POINT: Which zones do we want: geometry van zone 0 negeren.
//		{
//			attribute<Geografie/point_rd> geometry(poly) := collect_by_cond(SelectedRing, ZoneRing/geometry);
//		}
	    // TODO: ringen met !IsDefined(Zone_rel) niet samenvoegen.
		// TODO: Losse ringen toevoegen
		// TODO: bepaing orientation, dwz Outer Ring (area > 0) en inner ring (area < 0);
		// TODO: Zoneringen van dezelfde Zone samenvoegen van inner ringen met outer ring. na bepaling outer-ring
		// TODO: template met shapes en raster die vergrid, zoneert en simplifyt
		
		
	}
	container GridData
	{
		attribute<SourceData/gemeente> m100 (Geografie/gridcel_100m/domain) := poly2grid(SourceData/gemeente/geometry, Geografie/gridcel_100m/domain);
		attribute<SourceData/gemeente> m25  (Geografie/gridcel_25m/domain)  := poly2grid(SourceData/gemeente/geometry, Geografie/gridcel_25m/domain);
		attribute<SourceData/gemeente> m10  (Geografie/gridcel_10m/domain)  := poly2grid(SourceData/gemeente/geometry, Geografie/gridcel_10m/domain);

	}
	container districts
	{
		unit<uint16> m100 := district_uint16(GridData/m100) { attribute<SourceData/Gemeente> Regio_rel := first(GridData/m100, Districts); }
		unit<uint16> m25  := district_uint16(GridData/m25)  { attribute<SourceData/Gemeente> Regio_rel := first(GridData/m25 , Districts); }
		unit<uint16> m10  := district_uint16(GridData/m10)  { attribute<SourceData/Gemeente> Regio_rel := first(GridData/m10 , Districts); }
	}
	
	
	template SimplifyPolygons_T {
		unit<uint16> RegionDomain;
		unit<spoint> RasterDomain;
		parameter<float64> simplifyFactor;
		
		attribute<Geografie/point_rd> Region_geometry(RegionDomain, poly) := RegionDomain/geometry;
		
		attribute<RegionDomain> RasterData(RasterDomain) := poly2grid(Region_geometry, RasterDomain);
		unit<uint16> DistrictDomain := district_uint16(RasterData) { attribute<RegionDomain> Region_rel := first(RasterData, Districts); }
		
		container SimplifiedPolygons := grid2poly_T(RasterDomain, DistrictDomain, DistrictDomain/Districts, simplifyFactor);
		
		// Polygonen van dezelfde regio samenvoegen tot multi-polygons, in een afzonderlijke template
		// TODO: met afzonderlijke punten doen o.b.v. de te checked aanname dat ze niet overlappen.
		unit<uint32> ZoneRing := SimplifiedPolygons/ZoneRing;
		attribute<RegionDomain> ZoneRing_RegioDomain_rel(ZoneRing) := lookup(ZoneRing/FirstZone_rel, DistrictDomain/Region_rel);
		
		attribute<Geografie/point_rd> result(RegionDomain, poly) := fpolygon(partitioned_union_polygon(ipolygon(SimplifiedPolygons/results/geometry), DistrictDomain/Region_rel));
		
		// check dat result geen overlappende polygonen bevat
		attribute<ipoint> iresult(RegionDomain, poly) := ipolygon(result);
		
		unit<uint32> overlap_check := polygon_connectivity(iresult)
		{
			attribute<ipoint> geometry(poly) := iresult[F1] * iresult[F2];
			attribute<int32> area := area(geometry, int32);
		}
	}

	container applications {
	
		container d100_NL := SimplifyPolygons_T(SourceData/nl, Geografie/gridcel_100m/domain, 100.0);
		container d50_NL  := SimplifyPolygons_T(SourceData/nl, Geografie/gridcel_50m/domain,   50.0);
		container d10_NL  := SimplifyPolygons_T(SourceData/nl, Geografie/gridcel_10m/domain,   10.0);
		
		container d100 := SimplifyPolygons_T(SourceData/gemeente, Geografie/gridcel_100m/domain, 100.0);
		container d50  := SimplifyPolygons_T(SourceData/gemeente, Geografie/gridcel_50m/domain ,  50.0);
		container d10  := SimplifyPolygons_T(SourceData/gemeente, Geografie/gridcel_10m/domain ,  10.0);
	}

	container ConfigSettings {
		container Overridable {
			parameter<string> CbsSourceDatadir := '%SourceDatadir%/CBS';
		}
	}
}