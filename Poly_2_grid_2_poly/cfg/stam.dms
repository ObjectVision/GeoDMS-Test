container Poly_2_grid_2_poly
{
	#include <eenheden.dms>
	#include <geografie.dms>

	container SourceData{
		unit<uint32> gemeente : StorageName = "%CbsSourceDatadir%/gemeente.shp", StorageType = "gdal.vect", StorageReadOnly = "True"
		{
			attribute<geografie/point_rd> geometry (poly);
			attribute<string> label := GM_NAAM;
		}
	}
	
	container GridData
	{
		attribute<SourceData/gemeente> m100 (Geografie/gridcel_100m/domain) := poly2grid(SourceData/gemeente/geometry, Geografie/gridcel_100m/domain);
		attribute<SourceData/gemeente> m25  (Geografie/gridcel_25m/domain)  := poly2grid(SourceData/gemeente/geometry, Geografie/gridcel_25m/domain);
		attribute<SourceData/gemeente> m10  (Geografie/gridcel_10m/domain)  := poly2grid(SourceData/gemeente/geometry, Geografie/gridcel_10m/domain);

		container districts
		{
			unit<uint32> m100 := district(GridData/m100);
			unit<uint32> m25  := district(GridData/m25);
			unit<uint32> m10  := district(GridData/m10);
		}
	}
	
	template vectorize {
		unit<spoint> domain_grid;
		unit<uint32> Zone;
		attribute<Zone> zone_rel(domain_grid);
		parameter<float64> simplifyFactor;
		
		parameter<Zone> NoZone := #Zone+lowerbound(Zone); // outside study area indicator
		
		// Segments := horizontale raster-randjes met ongelijke boven en onder zones + verticale raster-randjes met ongelijke linker en rechter zones
		unit<int16> rows := range(uint32, pointrow(lowerbound(domain_grid)), pointrow(upperbound(domain_grid)));
		unit<int16> cols := range(uint32, pointcol(lowerbound(domain_grid)), pointcol(upperbound(domain_grid)));
		
		unit<int16>  HorizontalLine := range(int16, lowerbound(rows), upperbound(rows)+1s);
		unit<int16>  VerticalLine   := range(int16, lowerbound(cols), upperbound(cols)+1s);
		
		unit<uint32> Point := combine(VerticalLine, HorizontalLine)
		{
			attribute<geografie/point_rd> geometry := domain_grid_rel[geografie/point_rd];
			attribute<domain_grid> domain_grid_rel := point_xy(first_rel, second_rel, domain_grid); // the RasterCell NorthEast of this Point
			attribute<bool> isBoundaryPoint := has_any(BoundarySegment/F1) || has_any(BoundarySegment/F2);
			attribute<BoundaryPoint> BoundaryPoint_rel := invert(BoundaryPoint/org_rel);
		}
		unit<uint32> BoundaryPoint := select_with_org_rel(Point/isBoundaryPoint)
		{
			attribute<geografie/point_rd> geometry := org_rel->geometry;
			attribute<uint32> NrBoundarySegments := pcount(BoundarySegment/bp_F1) + pcount(BoundarySegment/bp_F2);
			attribute<bool>   isJunction := NrBoundarySegments != 2; // Junction := raster-hoekpunt waarop meer dan 2 segmenten uit komen (1 kan niet voor komen)
			attribute<JFS> JFS_rel := JFS/PartNr;
			
			attribute<uint32> NrJFL := pcount(JFL/F1) + pcount(JFL/F2);
		}
		
		unit<uint32> HorizontalSegment := combine(cols, HorizontalLine)
		{
			attribute<domain_grid> North  := point_xy(first_rel, second_rel-1s, domain_grid);
			attribute<domain_grid> South  := point_xy(first_rel, second_rel   , domain_grid);
			attribute<bool> isBoundarySegment := MakeDefined(south->zone_rel, NoZone) != MakeDefined(North->zone_rel, NoZone);
			attribute<Point> F1 := combine_data(Point,  first_rel    [VerticalLine], second_rel);
			attribute<Point> F2 := combine_data(Point, (first_rel+1s)[VerticalLine], second_rel);
		}
		
		unit<uint32> VerticalSegment := combine(VerticalLine, rows)
		{
			attribute<domain_grid> West := point_xy(first_rel-1s, second_rel, domain_grid);
			attribute<domain_grid> East := point_xy(first_rel   , second_rel, domain_grid);
			attribute<bool> isBoundarySegment := MakeDefined(West->zone_rel, max(zone_rel)+1) != MakeDefined(East->zone_rel, max(zone_rel)+1);
			attribute<Point> F1 := combine_data(Point, first_rel,  second_rel    [HorizontalLine]);
			attribute<Point> F2 := combine_data(Point, first_rel, (second_rel+1s)[HorizontalLine]);
		}
		
		unit<uint32> HorizontalBoundarySegment := select(HorizontalSegment/isBoundarySegment)
		{
			attribute<domain_grid> North := collect_by_cond(., HorizontalSegment/North);
			attribute<domain_grid> South := collect_by_cond(., HorizontalSegment/South);
			attribute<Point>       F1    := collect_by_cond(., HorizontalSegment/F1);
			attribute<Point>       F2    := collect_by_cond(., HorizontalSegment/F2);
		}
		unit<uint32> VerticalBoundarySegment := select(verticalSegment/isBoundarySegment)
		{
			attribute<domain_grid> East  := collect_by_cond(., VerticalSegment/East);
			attribute<domain_grid> West  := collect_by_cond(., VerticalSegment/West);
			attribute<Point>       F1    := collect_by_cond(., VerticalSegment/F1);
			attribute<Point>       F2    := collect_by_cond(., VerticalSegment/F2);
		}
		
		unit<uint2> Direction {
			attribute<string> Label : [ 'North', 'East', 'South', 'West'];
			container V:= for_each_nedv(Label, string(ID(.))+'[..]', void, .);
			attribute<.> Next    := union_data(., V/East, V/South, V/West, V/North);
			attribute<.> Reverse := union_data(., V/South, V/West, V/North, V/East);
		}
		unit<uint32> BoundarySegment := union_unit(HorizontalBoundarySegment, VerticalBoundarySegment)
		{
			attribute<domain_grid> left  := union_data(., HorizontalBoundarySegment/North, VerticalBoundarySegment/East);
			attribute<domain_grid> right := union_data(., HorizontalBoundarySegment/South, VerticalBoundarySegment/West);
			attribute<Direction> Dir_rel := union_data(., const(Direction/V/East ,HorizontalBoundarySegment), const(Direction/V/South ,VerticalBoundarySegment));
			attribute<Point> F1 := union_data(., HorizontalBoundarySegment/F1, VerticalBoundarySegment/F1);
			attribute<Point> F2 := union_data(., HorizontalBoundarySegment/F2, VerticalBoundarySegment/F2);
			attribute<BoundaryPoint> bp_F1 := F1->BoundaryPoint_rel; 
			attribute<BoundaryPoint> bp_F2 := F2->BoundaryPoint_rel; 
			attribute<bool> f1IsJunction := bp_F1->isJunction;
			attribute<bool> f2IsJunction := bp_F2->isJunction;
			attribute<bool> isJFL := not(f1IsJunction) && not(f2IsJunction); // intermediate in linestring
//			attribute<bool> isJJL :=     f1IsJunction  &&     f2IsJunction ; // directly connecting 2 junctions
			
			attribute<Zone> left_Zone_rel := zone_rel[left];
			attribute<Zone> rightZone_rel := zone_rel[right];
		}
		
		unit<uint32> Junction := select_with_org_rel(BoundaryPoint/isJunction)
		{
			attribute<geografie/point_rd> geometry := collect_by_cond(Junction, BoundaryPoint/geometry);
			attribute<.> per_node(BoundaryPoint) := invert(org_rel);
		}
		
		// JFN (aka Junction Free Nodes) := raster-hoekpunten waarop 2 segments uit komen
		unit<uint32> JFN := select(not(BoundaryPoint/isJunction));
		
		// JFL (aka Junction Free Links) := Segments die 2 JFN verbinden
		unit<uint32> JFL := select(BoundarySegment/isJFL)
		{
			attribute<BoundaryPoint> F1 := collect_by_cond(JFL, BoundarySegment/bp_F1);
			attribute<BoundaryPoint> F2 := collect_by_cond(JFL, BoundarySegment/bp_F2);
			
			attribute<Zone> left_Zone_rel := collect_by_cond(JFL, BoundarySegment/left_Zone_rel);
			attribute<Zone> rightZone_rel := collect_by_cond(JFL, BoundarySegment/rightZone_rel);
		}
		
		// Connector := Segment tussen een Junction en een JFN of een andere Junction
		unit<uint32> FromJunctionLink := select(BoundarySegment/f1IsJunction)
		{
			attribute<BoundaryPoint> F1 := collect_by_cond(FromJunctionLink, BoundarySegment/bp_F1);
			attribute<BoundaryPoint> F2 := collect_by_cond(FromJunctionLink, BoundarySegment/bp_F2);
			attribute<Direction>     Dir_rel := collect_by_cond(FromJunctionLink, BoundarySegment/Dir_rel);
			
			attribute<Junction> Junction_rel := Junction/per_node[F1];
			
			attribute<Zone> left_Zone_rel := collect_by_cond(FromJunctionLink, BoundarySegment/left_Zone_rel);
			attribute<Zone> rightZone_rel := collect_by_cond(FromJunctionLink, BoundarySegment/rightZone_rel);
		}
		unit<uint32> ToJunctionLink := select(BoundarySegment/f2IsJunction)
		{
			attribute<BoundaryPoint> F1 := collect_by_cond(ToJunctionLink, BoundarySegment/bp_F1);
			attribute<BoundaryPoint> F2 := collect_by_cond(ToJunctionLink, BoundarySegment/bp_F2);
			attribute<Direction>     Org_dir_rel := collect_by_cond(ToJunctionLink, BoundarySegment/Dir_rel);
			attribute<Direction>     Dir_rel := Org_dir_rel->Direction/Reverse;
			
			attribute<Junction> Junction_rel := Junction/per_node[F2];
			
			attribute<Zone> left_Zone_rel := collect_by_cond(ToJunctionLink, BoundarySegment/left_Zone_rel);
			attribute<Zone> rightZone_rel := collect_by_cond(ToJunctionLink, BoundarySegment/rightZone_rel);
		}
		
		unit<uint32> JunctionDirection := combine_unit(Junction, Direction)
		{
		}
		
		unit<uint32> JunctionLink := union_unit(FromJunctionLink, ToJunctionLink)
		{
			attribute<Geografie/point_rd> geometry := Junction_rel->Geometry;
			attribute<BoundaryPoint> F1   := union_data(., FromJunctionLink/F1, ToJunctionLink/F2);
			attribute<BoundaryPoint> F2   := union_data(., FromJunctionLink/F2, ToJunctionLink/F1);
			attribute<Direction>     Dir_rel := union_data(., FromJunctionLink/Dir_rel, ToJunctionLink/Dir_rel);
			attribute<Direction>     NextDir_rel := Dir_rel->Next;
			attribute<Direction>     NextNextDir_rel := Dir_rel->Reverse;
			attribute<Junction>      Junction_rel := rlookup(F1, Junction/org_rel);
			
			attribute<Zone> left_Zone_rel := union_data(., FromJunctionLink/left_Zone_rel, ToJunctionLink/rightZone_rel);
			attribute<Zone> rightZone_rel := union_data(., FromJunctionLink/rightZone_rel, ToJunctionLink/left_Zone_rel );
			
			attribute<JunctionDirection> JunctionDirection_rel := combine_data(JunctionDirection, Junction_rel, Dir_rel);
			attribute<JunctionDirection> NextJunctionDirection_rel := combine_data(JunctionDirection, Junction_rel, NextDir_rel);
			attribute<JunctionDirection> NextNextJunctionDirection_rel := combine_data(JunctionDirection, Junction_rel, NextNextDir_rel);
			attribute<JunctionLink> n1_JL := rlookup(NextJunctionDirection_rel, JunctionDirection_rel);
			attribute<JunctionLink> n2_JL := rlookup(NextNextJunctionDirection_rel, JunctionDirection_rel);
			attribute<JunctionLink> prev_JL := MakeDefined(n1_JL, n2_JL);
			attribute<JunctionLink> next_JL := invert(prev_JL);
			
			
			attribute<JFLS2> in_JFLS2 := rlookup(prev_JL, JFLS2/JL_rel);
			attribute<JFLS2> outJFLS2 := rlookup(ID(.)  , JFLS2/JL_rel);
			
//			attribute<.> prev_rel_ls := rlookup(in_JFLS2->Other_rel, outLink); // TODO: ???
//			attribute<.> next_rel_ls := rlookup(outJFLS2->Other_rel, in_Link); // TODO: ???
			attribute<.> other_rel_ls := outJFLS2->Other_rel; //, in_Link); // TODO: ???
			
			attribute<.> other_rel_direct := rlookup(combine_data(JunctionDirection, rlookup(F2, Junction/org_rel), Dir_rel->Reverse), JunctionLink/JunctionDirection_rel);
//			attribute<.> next_rel_direct := other_rel_direct->next_JL;
//			attribute<.> prev_rel_direct := rlookup(combine_data(JunctionDirection, rlookup(in_link->F2, Junction/org_rel), Zone_rel), values);
			
 			attribute<.> next_rel_with2 := rlookup(F2, prev_JL->F2); // TODO: ???
//			attribute<.> prev_rel_with2 := rlookup(in_Link->F2, outlink->F2); // TODO: ???
			
//			attribute<.> prev_rel := MakeDefined(prev_rel_ls, prev_rel_direct, prev_rel_with2);
			attribute<.> other_rel := MakeDefined(other_rel_ls, other_rel_direct);
			attribute<.> next_rel :=  MakeDefined(other_rel->prev_JL, next_rel_with2);
		}
		
		
		// JFS (aka Junction Free Section) := serie verbonden JFL
		unit<uint32> JFS := connected_parts(JFL/F1, JFL/F2)
		{
			attribute<uint32> nrParts := pcount(PartNr);
		}
		unit<uint32> JFSS := select_with_org_rel(JFS/nrParts > 1)
		{
			attribute<JFS> JFS_rel := org_rel;
			attribute<.> PartNr(BoundaryPoint) := invert(org_rel)[JFS/PartNr];
			
			unit<uint32> JFLP := union_unit(JFL, JFL) 
			{ 
				attribute<BoundaryPoint> BP_rel  := union_data(., JFL/F1, JFL/F2);
				attribute<JFSS>          JFSS_rel := PartNr[BP_rel];
				attribute<bool> isEndOfJSF := BP_rel->NrJFL == 1;
			} 
			attribute<uint8> NrEnds := sum_uint8(JFLP/isEndOfJSF, JFLP/JFSS_rel);
			attribute<bool> isLineString := NrEnds == 2b; // it could also be a ring without any Junction
			
			unit<uint32> Connector := select_with_org_rel(JFLP/isEndOfJSF);
		
			attribute<uint32> nrParts := pcount(PartNr);
			attribute<BoundaryPoint> firstBP_rel := first(Connector/org_rel->BP_rel, Connector/org_rel->JFSS_rel);
			attribute<BoundaryPoint> last_BP_rel := last (Connector/org_rel->BP_rel, Connector/org_rel->JFSS_rel);
			
				
		}
		unit<uint32> JFR  := select_with_org_rel(not(JFSS/isLineString))// JunctionFreeRing
		{
			attribute<JFSS> JFSS_rel := org_rel;
			attribute<JFS>  JFS_rel  := JFSS_rel->JFS_rel;
			
			// use the fact that the first segment of a ring is always West to East and therefore right is inside.
			attribute<Zone> left_Zone_rel := rlookup(JFS_rel, first(JFL/left_Zone_rel, JFS/PartNr));
			attribute<Zone> rightZone_rel := rlookup(JFS_rel, first(JFL/rightZone_rel, JFS/PartNr));
		}
		
		unit<uint32> JFLS := select_with_org_rel(JFSS/isLineString) // JunctionFree LineString
		{
			attribute<BoundaryPoint> firstBP_rel := collect_by_cond(JFLS, JFSS/firstBP_rel);
			attribute<BoundaryPoint> last_BP_rel := collect_by_cond(JFLS, JFSS/last_BP_rel);
			attribute<JunctionLink>  firstJL_rel := rlookup(firstBP_rel, JunctionLink/F2);
			attribute<JunctionLink>  last_JL_rel := rlookup(last_BP_rel, JunctionLink/F2);
			
			attribute<.> PartNr(BoundaryPoint) := invert(org_rel)[JFSS/PartNr];
			// JFS/Linestring := d.m.v. impedance_single van alle begin JFS naar eind JFS routes t.b.v. points2sequence
			attribute<uint32> dist_from_first_BP(BoundaryPoint) := impedance_table('bidirectional;startPoint(Node_rel);node:TraceBack'
					, const(1, JFL), JFL/F1, JFL/F2, JFLS/firstBP_rel);
					
			unit<uint32> JFLSP := select(IsDefined(dist_from_first_BP))
			{
				attribute<Geografie/point_rd> geometry := collect_by_cond(JFLSP, BoundaryPoint/Geometry);
				attribute<JFLS> sequence_rel := collect_by_cond(JFLSP, PartNr);
				attribute<uint32> ordinal := collect_by_cond(JFLSP, dist_from_first_BP);
			}
			unit<uint32> JFLSPwithConnectors := union_unit(JFLS, JFLSP, JFLS)
			{
				attribute<Geografie/point_rd> geometry := union_data(., firstJL_rel->geometry, JFLSP/geometry, last_JL_rel->geometry);
				attribute<JFLS>   sequence_rel := union_data(., id(JFLS), JFLSP/sequence_rel, id(JFLS));
				attribute<uint32> ordinal      := union_data(., const(0, JFLS), JFLSP/ordinal+1, max(JFLSP/ordinal, JFLSP/sequence_rel)+2);
			}
			
			attribute<Geografie/point_rd> LineString(arc) := points2sequence(JFLSP/geometry, JFLSP/sequence_rel, JFLSP/ordinal);
			attribute<Geografie/point_rd> LineStringWithConnectors(arc) := points2sequence(JFLSPwithConnectors/geometry, JFLSPwithConnectors/sequence_rel, JFLSPwithConnectors/ordinal);
			attribute<Geografie/point_rd> SimplifiedLineStringWithConnectors(arc) := bg_simplify_linestring(LineStringWithConnectors, simplifyFactor);
			unit<uint32> SimplifiedPoints := sequence2points(SimplifiedLineStringWithConnectors);
			attribute<uint32> SimplifiedPointOrdinalMax := max(SimplifiedPoints/ordinal, SimplifiedPoints/Sequence_rel);
			attribute<uint32> NrSimplifiedPoints := SimplifiedPointOrdinalMax+1;
			attribute<SimplifiedPoints> SimplifiedPointBase := value(cumulate(NrSimplifiedPoints) - NrSimplifiedPoints, SimplifiedPoints);
		}
		unit<uint32>  JFLS2 := union_unit(JFLS, JFLS)
		{
			attribute<JunctionLink> JL_rel    := union_data(., JFLS/firstJL_rel, JFLS/last_JL_rel);
			attribute<uint32>       NrSimplifiedPoints := union_data(., JFLS/NrSimplifiedPoints, JFLS/NrSimplifiedPoints);
			attribute<JunctionLink> Other_rel := union_data(., JFLS/last_JL_rel, JFLS/firstJL_rel);
			attribute<JFLS2_Point>  JFLS2_Point_Base := cumulate(NrSimplifiedPoints) - NrSimplifiedPoints;
		}
		unit<uint32> JFLS2_Point := range(uint32, 0, sum(JFLS2/NrSimplifiedPoints))
		{
			attribute<JFLS2> JFLS2_rel := classify(ID(.), JFLS2/JFLS2_Point_Base);
			attribute<uint32> ordinal := ID(.) - JFLS2_rel;
			attribute<JFLS/SimplifiedPoints> SimplifiedPoint_rel := union_data(.
				, JFLS/SimplifiedPointBase[JFLS/SimplifiedPoints/Sequence_rel] + JFLS/SimplifiedPoints/ordinal
				, (JFLS/SimplifiedPointBase+JFLS/SimplifiedPointOrdinalMax)[JFLS/SimplifiedPoints/Sequence_rel] - JFLS/SimplifiedPoints/ordinal);
			attribute<Geografie/point_rd> geometry  := SimplifiedPoint_rel->Point;
		}
		unit<uint32> ZoneRing := connected_parts(ID(JunctionLink), JunctionLink/next_rel)
		{
			attribute<.> per_JunctionLink(JunctionLink) := PartNr;
			attribute<JunctionLink> index(JunctionLink) :=  index(PartNr);
			attribute<JunctionLink> order(JunctionLink) := invert(index);
			
			attribute<Zone> FirstZone_rel := first(JunctionLink/left_Zone_rel, per_JunctionLink);
			attribute<JunctionLink> FirstJunctionLink_rel := min(order, per_JunctionLink);
			
			attribute<uint32> nrJunctions := pcount(per_JunctionLink);
			
			attribute<ZoneRingJunction> ZoneRingJunctionBase := cumulate(nrJunctions) - nrJunctions;
			
			attribute<ZoneRingPoint> ZoneRingPointBase := ZoneRingJunctionBase->ZoneRingPointBase;
			
			attribute<Geografie/point_rd> geometry(poly) := points2sequence(ZoneRingPoint/geometry, ZoneRingPoint/ZoneRing_rel, ZoneRingPoint/Ring_ordinal);
		}
		unit<uint32> ZoneRingJunction := range(uint32, 0, sum(ZoneRing/nrJunctions)) 
		{
			attribute<ZoneRing> ZoneRing_rel := classify(ID(.), ZoneRing/ZoneRingJunctionBase);
			attribute<uint32> ordinal := ID(.) - ZoneRing_rel->ZoneRingJunctionBase;
			
			attribute<JunctionLink> JunctionLink_rel := rlookup(ZoneRing_rel->FirstJunctionLink_rel + ordinal, ZoneRing/order ); // TODO: Compare cardinality with JunctionZone
			attribute<JFLS2> JFLS2_rel := JunctionLink_rel->outJFLS2;

			attribute<bool> IsJFLS := IsDefined(JFLS2_rel);
			
			attribute<uint32> nrPoints := 
				IsJFLS 
					? sub_or_null(JFLS2_rel->NrSimplifiedPoints, 1)
					: IsDefined(JunctionLink_rel->other_rel_direct)
						? 1 
						: 2
				;
			
			attribute<uint32> ZoneRingPointBase := cumulate(nrPoints) - nrPoints;
		}
		unit<uint32> ZoneRingPoint := range(uint32, 0, sum(ZoneRingJunction/nrPoints))
		{
			attribute<ZoneRingJunction> ZoneRingJunction_rel := classify(ID(.), ZoneRingJunction/ZoneRingPointBase);
			attribute<ZoneRing> ZoneRing_rel := ZoneRingJunction_rel->ZoneRing_rel;
			attribute<uint32> Ring_ordinal := ID(.) - ZoneRing_rel->ZoneRingPointBase;
			attribute<uint32> RingJunction_ordinal := ID(.) - ZoneRingJunction_rel->ZoneRingPointBase;
			
			attribute<JunctionLink> JunctionLink_rel := ZoneRingJunction_rel->JunctionLink_rel;
//			attribute<JunctionLink> JunctionLink_rel := JunctionZone_rel->outLink;
			attribute<JFLS2> JFLS2_rel := JunctionLink_rel->outJFLS2;
			attribute<JFLS2_Point> JFLS2_Point_rel := JFLS2_rel->JFLS2_Point_Base + RingJunction_ordinal;
			attribute<BoundaryPoint> BP_rel := RingJunction_ordinal > 0 ? JunctionLink_rel->F2 : JunctionLink_rel->F1;
			attribute<Geografie/point_rd> geometry  := ZoneRingJunction_rel->IsJFLS 
				? JFLS2_Point_rel->geometry
				: BP_rel->Geometry;
	//		value(ZoneRingJunction_rel->JFLS2_rel/PointBase + ordinal;
		}
//		attribute<Geografie/point_rd> ZoneRing_geometry(ZoneRing, poly) := ZoneRing/geometry;
		unit<uint32> SelectedRing := select(ZoneRing/FirstZone_rel != 0) // CUSTOMIZATION POINT: Which zones do we want
		{
			attribute<Geografie/point_rd> geometry(poly) := collect_by_cond(SelectedRing, ZoneRing/geometry);
		}
		// TODO: Zoneringen van dezelfde Zone samenvoegen na bepaling outer-ring en geometry van zone 0 negeren.
	}
	
	container applications {
	
		attribute<uint32> IsNL(Geografie/gridcel_100m/domain) := UInt32(IsDefined(GridData/districts/m100/Districts));
		unit<uint32> NLZone := district(IsNl);
		
		container d100_NL := vectorize(Geografie/gridcel_100m/domain, NLZone, NlZone/Districts, 100.0);
		
		container d100 := vectorize(Geografie/gridcel_100m/domain, GridData/districts/m100, GridData/districts/m100/Districts, 100.0);
		container d50  := vectorize(Geografie/gridcel_25m/domain,  GridData/districts/m25 , GridData/districts/m25/Districts,   50.0);
		container d10  := vectorize(Geografie/gridcel_10m/domain,  GridData/districts/m10 , GridData/districts/m10/Districts,   10.0);
/*		
		container m100 := vectorize(Geografie/gridcel_100m/domain, /SourceData/gemeente, GridData/m100, 100.0);
		container m50  := vectorize(Geografie/gridcel_25m/domain,  /SourceData/gemeente, GridData/m25, 50.0);
		container m10  := vectorize(Geografie/gridcel_10m/domain,  /SourceData/gemeente, GridData/m10, 10.0s);
*/		
	}
	container ConfigSettings {
		container Overridable {
			parameter<string> CbsSourceDatadir := '%SourceDatadir%/CBS';
		}
	}
}