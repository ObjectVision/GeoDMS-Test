container Poly_2_grid_2_poly
{
	#include <eenheden.dms>
	#include <geografie.dms>

	container SourceData
	{
		unit<uint32> gemeente : StorageName = "%CbsSourceDatadir%/gemeente.shp", StorageType = "gdal.vect", StorageReadOnly = "True"
		{
			attribute<geografie/point_rd> geometry (poly);
			attribute<string> label := GM_NAAM;
		}
	}
	
	container GridData
	{
		attribute<SourceData/gemeente> m100 (Geografie/gridcel_100m/domain) := poly2grid(SourceData/gemeente/geometry, Geografie/gridcel_100m/domain);
		attribute<SourceData/gemeente> m25  (Geografie/gridcel_25m/domain)  := poly2grid(SourceData/gemeente/geometry, Geografie/gridcel_25m/domain);
		attribute<SourceData/gemeente> m10  (Geografie/gridcel_10m/domain)  := poly2grid(SourceData/gemeente/geometry, Geografie/gridcel_10m/domain);

		container districts
		{
			unit<uint32> m100 := district(GridData/m100);
			unit<uint32> m25  := district(GridData/m25);
			unit<uint32> m10  := district(GridData/m10);
		}
	}
	
	template vectorize {
		unit<spoint> domain_grid;
		unit<uint32> Zone;
		attribute<Zone> zone_rel(domain_grid);
		parameter<float64> simplifyFactor;
		
		parameter<Zone> NoZone := #Zone+lowerbound(Zone); // outside study area indicator
		
		// Segments := horizontale raster-randjes met ongelijke boven en onder zones + verticale raster-randjes met ongelijke linker en rechter zones
		unit<int16> rows := range(uint32, pointrow(lowerbound(domain_grid)), pointrow(upperbound(domain_grid)));
		unit<int16> cols := range(uint32, pointcol(lowerbound(domain_grid)), pointcol(upperbound(domain_grid)));
		
		unit<int16>  HorizontalLine := range(int16, lowerbound(rows), upperbound(rows)+1s);
		unit<int16>  VerticalLine   := range(int16, lowerbound(cols), upperbound(cols)+1s);
		
		unit<uint32> Point := combine(VerticalLine, HorizontalLine)
		{
			attribute<geografie/point_rd> geometry := domain_grid_rel[geografie/point_rd];
			attribute<domain_grid> domain_grid_rel := point_xy(first_rel, second_rel, domain_grid); // the RasterCell NorthEast of this Point
			attribute<bool> isBoundaryPoint := has_any(BoundarySegment/F1) || has_any(BoundarySegment/F2);
			attribute<BoundaryPoint> BoundaryPoint_rel := invert(BoundaryPoint/org_rel);
		}
		unit<uint32> BoundaryPoint := select_with_org_rel(Point/isBoundaryPoint)
		{
			attribute<geografie/point_rd> geometry := org_rel->geometry;
			attribute<uint32> NrBoundarySegments := pcount(BoundarySegment/bp_F1) + pcount(BoundarySegment/bp_F2);
			attribute<bool>   isJunction := NrBoundarySegments != 2; // Junction := raster-hoekpunt waarop meer dan 2 segmenten uit komen (1 kan niet voor komen)
			attribute<JFS> JFS_rel := JFS/PartNr;
			
			attribute<uint32> NrJFL := pcount(JFL/F1) + pcount(JFL/F2);
		}
		
		unit<uint32> HorizontalSegment := combine(cols, HorizontalLine)
		{
			attribute<domain_grid> North  := point_xy(first_rel, second_rel-1s, domain_grid);
			attribute<domain_grid> South  := point_xy(first_rel, second_rel   , domain_grid);
			attribute<bool> isBoundarySegment := MakeDefined(south->zone_rel, NoZone) != MakeDefined(North->zone_rel, NoZone);
			attribute<Point> F1 := combine_data(Point,  first_rel    [VerticalLine], second_rel);
			attribute<Point> F2 := combine_data(Point, (first_rel+1s)[VerticalLine], second_rel);
		}
		
		unit<uint32> VerticalSegment := combine(VerticalLine, rows)
		{
			attribute<domain_grid> West := point_xy(first_rel-1s, second_rel, domain_grid);
			attribute<domain_grid> East := point_xy(first_rel   , second_rel, domain_grid);
			attribute<bool> isBoundarySegment := MakeDefined(West->zone_rel, max(zone_rel)+1) != MakeDefined(East->zone_rel, max(zone_rel)+1);
			attribute<Point> F1 := combine_data(Point, first_rel,  second_rel    [HorizontalLine]);
			attribute<Point> F2 := combine_data(Point, first_rel, (second_rel+1s)[HorizontalLine]);
		}
		
		unit<uint32> HorizontalBoundarySegment := select(HorizontalSegment/isBoundarySegment);
		unit<uint32> VerticalBoundarySegment := select(verticalSegment/isBoundarySegment);
		
		unit<uint32> BoundarySegment := union_unit(HorizontalBoundarySegment, VerticalBoundarySegment)
		{
			attribute<domain_grid> left  := union_data(., collect_by_cond(HorizontalBoundarySegment, HorizontalSegment/North), collect_by_cond(VerticalBoundarySegment, VerticalSegment/West));
			attribute<domain_grid> right := union_data(., collect_by_cond(HorizontalBoundarySegment, HorizontalSegment/South), collect_by_cond(VerticalBoundarySegment, VerticalSegment/East));
			attribute<Point> F1 := union_data(., collect_by_cond(HorizontalBoundarySegment, HorizontalSegment/F1), collect_by_cond(VerticalBoundarySegment, VerticalSegment/F1));
			attribute<Point> F2 := union_data(., collect_by_cond(HorizontalBoundarySegment, HorizontalSegment/F2), collect_by_cond(VerticalBoundarySegment, VerticalSegment/F2));
			attribute<BoundaryPoint> bp_F1 := F1->BoundaryPoint_rel; 
			attribute<BoundaryPoint> bp_F2 := F2->BoundaryPoint_rel; 
			attribute<bool> f1IsJunction := bp_F1->isJunction;
			attribute<bool> f2IsJunction := bp_F2->isJunction;
			attribute<bool> isJFL := not(f1IsJunction) && not(f2IsJunction); // intermediate in linestring
			attribute<bool> isJJL :=     f1IsJunction  &&     f2IsJunction ; // directly connecting 2 junctions
			
			attribute<Zone> left_Zone_rel := zone_rel[left];
			attribute<Zone> rightZone_rel := zone_rel[right];
		}
		
		unit<uint32> Junction := select_with_org_rel(BoundaryPoint/isJunction)
		{
			attribute<geografie/point_rd> geometry := collect_by_cond(Junction, BoundaryPoint/geometry);
			attribute<.> per_node(BoundaryPoint) := invert(org_rel);
		}
		
		// JFN (aka Junction Free Nodes) := raster-hoekpunten waarop 2 segments uit komen
		unit<uint32> JFN := select(not(BoundaryPoint/isJunction));
		
		// JFL (aka Junction Free Links) := Segments die 2 JFN verbinden
		unit<uint32> JFL := select(BoundarySegment/isJFL)
		{
			attribute<BoundaryPoint> F1 := collect_by_cond(JFL, BoundarySegment/bp_F1);
			attribute<BoundaryPoint> F2 := collect_by_cond(JFL, BoundarySegment/bp_F2);
			
			attribute<Zone> left_Zone_rel := collect_by_cond(JFL, BoundarySegment/left_Zone_rel);
			attribute<Zone> rightZone_rel := collect_by_cond(JFL, BoundarySegment/rightZone_rel);
		}
		
		unit<uint32> FromJunctionLink := select_with_org_rel(BoundarySegment/f1IsJunction)
		{
//			attribute<BoundarySegment> BoundarySegment_rel := org_rel;
			
			attribute<BoundaryPoint> F1 := collect_by_cond(FromJunctionLink, BoundarySegment/bp_F1);
			attribute<BoundaryPoint> F2 := collect_by_cond(FromJunctionLink, BoundarySegment/bp_F2);
			
			attribute<Zone> left_Zone_rel := collect_by_cond(FromJunctionLink, BoundarySegment/left_Zone_rel);
			attribute<Zone> rightZone_rel := collect_by_cond(FromJunctionLink, BoundarySegment/rightZone_rel);
			
			attribute<Junction> Junction_rel := Junction/per_node[F1];
			attribute<bool> isJJL := collect_by_cond(FromJunctionLink, BoundarySegment/isJJL);
		}
		unit<uint32> ToJunctionLink := select_with_org_rel(BoundarySegment/f2IsJunction)
		{
			attribute<BoundarySegment> BoundarySegment_rel := org_rel;
			
			attribute<BoundaryPoint> F1 := collect_by_cond(ToJunctionLink, BoundarySegment/bp_F1);
			attribute<BoundaryPoint> F2 := collect_by_cond(ToJunctionLink, BoundarySegment/bp_F2);
			
			attribute<Junction> Junction_rel := Junction/per_node[F2];
			
			attribute<Zone> left_Zone_rel := collect_by_cond(ToJunctionLink, BoundarySegment/left_Zone_rel);
			attribute<Zone> rightZone_rel := collect_by_cond(ToJunctionLink, BoundarySegment/rightZone_rel);
		}
		
		unit<uint32> JunctionLink := union_unit(FromJunctionLink, ToJunctionLink)
		{
			attribute<Geografie/point_rd> geometry := Junction_rel->Geometry;
			attribute<BoundaryPoint> F1   := union_data(., FromJunctionLink/F1, ToJunctionLink/F2);
			attribute<BoundaryPoint> F2   := union_data(., FromJunctionLink/F2, ToJunctionLink/F1);
			attribute<Junction>      Junction_rel := rlookup(F1, Junction/org_rel);
			attribute<Zone> left_Zone_rel := union_data(., FromJunctionLink/left_Zone_rel, ToJunctionLink/rightZone_rel);
			attribute<Zone> rightZone_rel := union_data(., FromJunctionLink/rightZone_rel, ToJunctionLink/left_Zone_rel );
			attribute<JunctionZoneCode> left_JunctionZoneCode := combine_data(JunctionZoneCode,  Junction_rel, left_Zone_rel );
			attribute<JunctionZoneCode> rightJunctionZoneCode := combine_data(JunctionZoneCode,  Junction_rel, rightZone_rel);
		}
		
		// JFS (aka Junction Free Section) := serie verbonden JFL
		unit<uint32> JFS := connected_parts(JFL/F1, JFL/F2)
		{
			attribute<uint32> nrParts := pcount(PartNr);
		}
		unit<uint32> JFSS := select_with_org_rel(JFS/nrParts > 1)
		{
			attribute<JFS> JFS_rel := org_rel;
			attribute<.> PartNr(BoundaryPoint) := invert(org_rel)[JFS/PartNr];
			
			unit<uint32> JFLP := union_unit(JFL, JFL) 
			{ 
				attribute<BoundaryPoint> BP_rel  := union_data(., JFL/F1, JFL/F2);
				attribute<JFSS>          JFSS_rel := PartNr[BP_rel];
				attribute<bool> isEndOfJSF := BP_rel->NrJFL == 1;
			} 
			attribute<uint8> NrEnds := sum_uint8(JFLP/isEndOfJSF, JFLP/JFSS_rel);
			attribute<bool> isLineString := NrEnds == 2b; // it could also be a ring without any Junction
			
			unit<uint32> Connector := select_with_org_rel(JFLP/isEndOfJSF);
		
			attribute<uint32> nrParts := pcount(PartNr);
			attribute<BoundaryPoint> firstBP_rel := first(Connector/org_rel->BP_rel, Connector/org_rel->JFSS_rel);
			attribute<BoundaryPoint> last_BP_rel := last (Connector/org_rel->BP_rel, Connector/org_rel->JFSS_rel);
			
				
		}
		unit<uint32> JFR  := select_with_org_rel(not(JFSS/isLineString))// JunctionFreeRing
		{
			attribute<JFSS> JFSS_rel := org_rel;
			attribute<JFS>  JFS_rel  := JFSS_rel->JFS_rel;
			
			// use the fact that the first segment of a ring is always West to East and therefore right is inside.
			attribute<Zone> left_Zone_rel := rlookup(JFS_rel, first(JFL/left_Zone_rel, JFS/PartNr));
			attribute<Zone> rightZone_rel := rlookup(JFS_rel, first(JFL/rightZone_rel, JFS/PartNr));
		}
		
		unit<uint32> JFLS := select_with_org_rel(JFSS/isLineString) // JunctionFree LineString
		{
			attribute<BoundaryPoint> firstBP_rel := collect_by_cond(JFLS, JFSS/firstBP_rel);
			attribute<BoundaryPoint> last_BP_rel := collect_by_cond(JFLS, JFSS/last_BP_rel);
			attribute<JunctionLink>  firstJL_rel := rlookup(firstBP_rel, JunctionLink/F2);
			attribute<JunctionLink>  last_JL_rel := rlookup(last_BP_rel, JunctionLink/F2);
			
			attribute<.> PartNr(BoundaryPoint) := invert(org_rel)[JFSS/PartNr];
/*		
			attribute<uint32> nrParts := collect_by_cond(JFLS, JFSS/nrParts);
			attribute<JFLSP> first_JFLSP_rel := cumulate(nrParts) - nrParts;
			unit<uint32> JFLSP := range(uint32, 0, sum(nrParts))
			{
				attribute<JFLS> JFLS_rel := classify(id(.), first_JFLSP_rel);
				attribute<uint32> ordinal := id(.) - JFLS_rel->first_JFLSP_rel;
				attribute<uint32> BP_key := TraceBack;
			}
*/			
			// JFS/Linestring := d.m.v. impedance_single van alle begin JFS naar eind JFS routes t.b.v. points2sequence
			attribute<uint32> dist_from_first_BP(BoundaryPoint) := impedance_table('bidirectional;startPoint(Node_rel);node:TraceBack'
					, const(1, JFL), JFL/F1, JFL/F2, JFLS/firstBP_rel)
			{
//				attribute<BoundaryPoint> Prev_rel(BoundaryPoint) := TraceBack->F1 == ID(BoundaryPoint) ? JFL/F2 : JFL/F1;
			}
			unit<uint32> JFLSP := select(IsDefined(dist_from_first_BP))
			{
				attribute<Geografie/point_rd> geometry := collect_by_cond(JFLSP, BoundaryPoint/Geometry);
				attribute<JFLS> sequence_rel := collect_by_cond(JFLSP, PartNr);
				attribute<uint32> ordinal := collect_by_cond(JFLSP, dist_from_first_BP);
			}
			unit<uint32> JFLSPwithConnectors := union_unit(JFLS, JFLSP, JFLS)
			{
				attribute<Geografie/point_rd> geometry := union_data(., firstJL_rel->geometry, JFLSP/geometry, last_JL_rel->geometry);
				attribute<JFLS>   sequence_rel := union_data(., id(JFLS), JFLSP/sequence_rel, id(JFLS));
				attribute<uint32> ordinal      := union_data(., const(0, JFLS), JFLSP/ordinal+1, max(JFLSP/ordinal, JFLSP/sequence_rel)+2);
			}
			
			attribute<Geografie/point_rd> LineString(arc) := points2sequence(JFLSP/geometry, JFLSP/sequence_rel, JFLSP/ordinal);
			attribute<Geografie/point_rd> LineStringWithConnectors(arc) := points2sequence(JFLSPwithConnectors/geometry, JFLSPwithConnectors/sequence_rel, JFLSPwithConnectors/ordinal);
			attribute<Geografie/point_rd> SimplifiedLineStringWithConnectors(arc) := bg_simplify_linestring(LineStringWithConnectors, simplifyFactor);
			unit<uint32> SimplifiedJFLSP := sequence2points(SimplifiedLineStringWithConnectors);
		}
		
		unit<uint32> JunctionZoneCode := combine(Junction, Zone)
		{
			unit<uint32> JunctionLinks := union_unit(FromJunctionLink, ToJunctionLink, FromJunctionLink, ToJunctionLink)
			{
				attribute<JunctionZoneCode> values := union_data(JunctionLinks
					, combine_data(JunctionZoneCode, FromJunctionLink/Junction_rel, FromJunctionLink/left_Zone_rel )
					, combine_data(JunctionZoneCode, FromJunctionLink/Junction_rel, FromJunctionLink/rightZone_rel)
					, combine_data(JunctionZoneCode,   ToJunctionLink/Junction_rel,   ToJunctionLink/left_Zone_rel )
					, combine_data(JunctionZoneCode,   ToJunctionLink/Junction_rel,   ToJunctionLink/rightZone_rel)
				);
			}
		}
		
		unit<uint32> JunctionZone := unique(JunctionZoneCode/JunctionLinks/values)
		{
			attribute<Junction> Junction_rel := values->first_rel;
			attribute<Zone    > Zone_rel     := values->second_rel;
			attribute<JunctionLink> in_Link := rlookup(values, JunctionLink/left_JunctionZoneCode);
			attribute<JunctionLink> outLink := rlookup(values, JunctionLink/rightJunctionZoneCode);
			attribute<JFLS> in_JFLS := rlookup(in_Link, JFLS/last_JL_rel);
			attribute<JFLS> outJFLS := rlookup(outLink, JFLS/firstJL_rel);
			
			attribute<.> next_rel_direct := rlookup(combine_data(JunctionZoneCode, rlookup(outlink->F2, Junction/org_rel), Zone_rel), values);
			attribute<.> prev_rel_direct := rlookup(combine_data(JunctionZoneCode, rlookup(in_link->F2, Junction/org_rel), Zone_rel), values);
			
			attribute<.> next_rel_with2 := rlookup(outLink->F2, in_link->F2);
			attribute<.> prev_rel_with2 := rlookup(in_Link->F2, outlink->F2);
			
			attribute<.> prev_rel_ls := rlookup(in_JFLS->firstJL_rel, outLink);
			attribute<.> next_rel_ls := rlookup(outJFLS->last_JL_rel, in_Link);
			
			attribute<.> prev_rel := MakeDefined(prev_rel_ls, prev_rel_direct, prev_rel_with2);
			attribute<.> next_rel := MakeDefined(next_rel_ls, next_rel_direct, next_rel_with2);	
		}
		unit<uint32> ZoneRing := connected_parts(ID(JunctionZone), JunctionZone/next_rel)
		{
			attribute<.> per_JunctionZone(JunctionZone) := PartNr;
			attribute<Zone> Zone_rel := first(JunctionZone/Zone_rel, per_JunctionZone);
			attribute<uint32> nrRingsPerZone(Zone) := pcount(Zone_rel);
			attribute<uint32> nrJunctions := pcount(per_JunctionZone);
		}
		
		// Connector := Segment tussen een Junction en een JFN
		// JFS/Linestring := begin connector + result(5) + end connector; eventueel deze simplifyen
		// ZoneJunction := kruistabel met junctions en zones;
		// ZoneBorder := link tussen 2 junctions bij een zone die door een segment of JFS/Linestring verbonden zijn
		// bepaal per zone de 1e ZoneJunction en 1 via een ZoneBorder verbonden 2e ZoneJunction
		// routeer de andere ZoneJunctions min of meer conform stap 5.
		// gebruik 12 om resultaten van 9 achter elkaar te plakken per zone.
		
	}
	
	container applications {
		container d100 := vectorize(Geografie/gridcel_100m/domain, GridData/districts/m100, GridData/districts/m100/Districts, 100.0);
		container d50  := vectorize(Geografie/gridcel_25m/domain,  GridData/districts/m25 , GridData/districts/m25/Districts,   50.0);
		container d10  := vectorize(Geografie/gridcel_10m/domain,  GridData/districts/m10 , GridData/districts/m10/Districts,   10.0);
		
		container m100 := vectorize(Geografie/gridcel_100m/domain, /SourceData/gemeente, GridData/m100, 100.0);
		container m50  := vectorize(Geografie/gridcel_25m/domain,  /SourceData/gemeente, GridData/m25, 50.0);
		container m10  := vectorize(Geografie/gridcel_10m/domain,  /SourceData/gemeente, GridData/m10, 10.0s);
	}
	container ConfigSettings {
		container Overridable {
			parameter<string> CbsSourceDatadir := '%SourceDatadir%/CBS';
		}
	}
}