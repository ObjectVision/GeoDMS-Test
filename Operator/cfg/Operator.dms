////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                            //
//                              Operator/Functie Test                                                         //
//                                                                                                            //
//                  Configuratie voor het testen van de DMS Operatoren/Functies                               //
//                  Geschreven in het kader van het project: Beheer RuimteScanner                             //
//                                                                                                            //
//                                       Februari 2004                                                        //
//                                                                                                            //
//                             Continue aanpassingen voor nieuwe operatoren                                   //
//                                                                                                            //
////////////////////////////////////////////////////////////////////////////////////////////////////////////////

container OperatorTest: url = "%projdir%/doc/test.htm", FreeData = "True"
{
	container results
	{
		parameter<bool> tests_all := tests_regression && File/results/tests;

		parameter<bool> tests_regression:= 
			   Arithmetics/UnTiled/results/tests
			&& Arithmetics/EunTiled/results/tests
			&& Arithmetics/Tiled/results/tests
			&& Arithmetics/ETiled/results/tests
			&& Precedence/results/tests
			&& Ordering/UnTiled/results/tests
			&& Ordering/EunTiled/results/tests
			&& Ordering/Tiled/results/tests
			&& Ordering/ETiled/results/tests
			&& Transcendental/UnTiled/results/tests
			&& Transcendental/EunTiled/results/tests
			&& Transcendental/Tiled/results/tests
			&& Transcendental/ETiled/results/tests
			&& Conversion/UnTiled/results/tests
			&& Conversion/EunTiled/results/tests
			&& Conversion/Tiled/results/tests
			&& Conversion/ETiled/results/tests
			&& Aggregations/UnTiled2Untiled/results/tests
			&& Aggregations/UnTiled2Untiled/reg_count/test_attr
			&& Aggregations/Tiled2Untiled/results/tests
			&& Aggregations/UnTiled2Tiled/results/tests
			&& Aggregations/EUnTiled2Untiled/results/tests
			&& Aggregations/EUnTiled2Untiled/reg_count/test_attr
			&& Aggregations/ETiled2Untiled/results/tests
			&& Aggregations/EUnTiled2Tiled/results/tests
			&& Predicates/UnTiled/results/tests
			&& Predicates/Tiled/results/tests
			&& Predicates/EUnTiled/results/tests
			&& Predicates/Etiled/results/tests
			&& Logical/UnTiled/results/tests
			&& Logical/Tiled/results/tests
			&& Logical/EUnTiled/results/tests
			&& Logical/Etiled/results/tests
			&& Relational/UnTiled2UnTiled/results/tests
			&& Relational/UnTiled2Tiled/results/tests
			&& Relational/Tiled2UnTiled/results/tests
			&& Relational/Tiled2Tiled/results/tests
			&& Relational/EunTiled/results/tests
			&& Relational/ETiled/results/tests
			&& Relational/ResultUnitTiled/unique/test_attr
			&& Relational/ResultUnitTiled/combine/test_attr
			&& Relational/ResultUnitTiled/join_equal_values/test_attr
			&& Classify/UnTiled2UnTiled/results/tests
			&& Classify/Tiled2UnTiled/results/tests
			&& Classify/EunTiled/results/tests
			&& Rescale/UnTiled2UnTiled/results/tests
			&& Rescale/UnTiled2Tiled/results/tests
			&& Rescale/Tiled2UnTiled/results/tests
			&& Rescale/Tiled2Tiled/results/tests
			&& Constants/UnTiled/results/tests
			&& Constants/tiled/results/tests
			&& Constants/EUnTiled/results/tests
			&& Constants/Etiled/results/tests
			&& Trigonometric/UnTiled/results/tests
			&& Trigonometric/tiled/results/tests
			&& Trigonometric/EUnTiled/results/tests
			&& Trigonometric/Etiled/results/tests
			&& Point/UnTiled2UnTiled/results/tests
			&& Point/UnTiled2Tiled/results/tests
			&& Point/Tiled2UnTiled/results/tests
			&& Point/Tiled2Tiled/results/tests
			&& Point/EUnTiled2UnTiled/results/tests
			&& Point/EUnTiled2Tiled/results/tests
			&& Point/ETiled2UnTiled/results/tests
			&& Point/ETiled2Tiled/results/tests
			&& Point/ResultUnitTiled/dyna_point_tiled/CalcPoint/test_attr
			&& Sequence/UnTiled/canyon/test_attr
			&& Sequence/UnTiled/canyon_empty/test_attr
			&& Sequence/UnTiled/results/tests
			&& Sequence/Tiled/results/tests
			&& Sequence/EUnTiled/results/tests
			&& Sequence/ETiled/results/tests
			&& Sequence/ResultUnitTiled/sequence2points/test_attr
			&& Sequence/ResultUnitTiled/overlay_polygon/test_attr
			&& Network/UnTiled/results/tests
			&& Network/Tiled/results/tests
			&& Network/EunTiled/results/tests
			&& Network/ETiled/results/tests
			&& Network/ResultUnitTiled/connect/test_attr
			&& Network/ResultUnitTiled/connect_info/test_attr

			&& Grid/units/results/tests
			&& Grid/UnTiled/results/tests
			&& Grid/Tiled/results/tests
			&& Grid/ETiled/results/tests
			&& Grid/EUnTiled/results/tests
			&& Grid/potential_with_tiles/test_attr
			&& Matrix/UnTiled/results/tests
			&& Matrix/Tiled/results/tests
			&& Matrix/ETiled/results/tests
			&& Matrix/EunTiled/results/tests
			&& String/UnTiled/results/tests
			&& String/Tiled/results/tests
			&& String/EUnTiled/results/tests
			&& String/ETiled/results/tests
			&& ReadAVLE/results/tests 
			&& MetaScript/results/tests
			&& Allocation/allocate_discrete/test_attr
			&& Allocation/allocate_discrete_div_constant/test_attr
			&& UnitFunctions/UnTiled/results/tests
			&& UnitFunctions/Tiled/results/tests
			&& Miscellaneous/results/tests
			&& Trackers/Results/tests
			&& MetaInfo/results/test
			&& ExplicitNullvalues/tests
			&& Utf8Characters/tests;

		unit<uint32> resDomain: nrofrows = 1;
		attribute<uint32> testsExp(resDomain) :=  const(uint32(tests_all), resDomain)
		,	StorageName = "regr_res.dbf"; 

		parameter<string> tests_log := String(tests_regression)
		,	StorageType = "str"
		,	storagename = "%localDataProjDir%/regr_results/operator.txt";


		parameter<string> unit_test_log := tests_regression 
			? '' 
			: 'Operator Test: ' + expand(., '%configDir%') + '.dms ' + PropValue(tests_regression, 'fullname') + ' result: not OK'
		,	StorageType = "str"
		,	storagename = "%localDataDir%/GeoDMSTestResults/unit/operator/operator.txt";


		container Regression
		{
			parameter<string> TempDir                  := '';
			parameter<string> results_folder_filename  := '%LocalDataDir%/Regression/log/results_folder.txt';
			parameter<string> results_folder           :  Storagename =  "= results_folder_filename", StorageType = "str";

			container Subitems
			{
				parameter<string> ConfigFile : StorageName = "%projdir%/cfg/operator.dms", StorageType = "str";
				parameter<uint32> nrTests    := strcount(ConfigFile, 'test_attr') + strcount(ConfigFile, 'test_param');
			}

			container t010_operator_test
			{
				parameter<string> result := 
					'<description>operator test</description>' + 
					'<size>number unique tests: ' + string(Subitems/nrTests) + '</size>' + 
					'<result>' + (tests_regression ? 'OK' : 'False') + '</result>';

				parameter<string> C1C2 := result, StorageType = "str", Storagename = "= results_folder + '/t010_operator_test_C1C2.txt'";
				parameter<string> S1C2 := result, StorageType = "str", Storagename = "= results_folder + '/t010_operator_test_S1C2.txt'";
				parameter<string> S1S2 := result, StorageType = "str", Storagename = "= results_folder + '/t010_operator_test_S1S2.txt'";
				parameter<string> C1S2 := result, StorageType = "str", Storagename = "= results_folder + '/t010_operator_test_C1S2.txt'";
			}
		}
	}

	// gebruikte domain units
	unit<uint32> HDomain: nrofrows = 4;
	unit<uint32> ADomain: nrofrows = 5;
	unit<uint32> CDomain: nrofrows = 10;
	unit<uint32> RDomain: nrofrows = 7;
	unit<uint32> LDomain: nrofrows = 8;
	unit<uint32> SDomain: nrofrows = 1;
	unit<uint32> EDomain: nrofrows = 0;

	unit<uint32> SequenceUnit: nrofrows = 2;

	unit<uint32> RegionDomain:   nrofrows = 5;
	unit<uint32> ERegionDomain:  nrofrows = 0;
	
	unit<uint32> DistrictDomain: nrofrows = 15;
	unit<uint32> BuildingDomain: nrofrows = 6;

	unit<uint8>  ClassDomain           := Classifications/inhabitants_4K;
	unit<uint8>  ClassDomainOneClass   :  nrofrows =  1;
	unit<uint8>  ClassDomainManyClasses:  nrofrows = 20;

	unit<uint32> RoadDomain:   nrofrows = 3;
	unit<uint32> CityDomain:   Range = "[1, 8)";
	unit<uint32> CountryDomain:   nrofrows = 3;
	unit<uint32> DistrictPointsDomain: nrofrows = 177;

	unit<uint32> PandPointsDomain: nrofrows = 142;
	unit<uint32> PandDomain      : nrofrows = 21;

	unit<fpoint>  point_rd;//:= baseunit('m', fpoint);
	unit<spoint> gridcel_1km :=
		 range(
			gridset(
				 point_rd
				,point(float32(-1000.0)  , float32(1000.0) , point_rd )
				,point(float32(405600), float32(111300), point_rd )
				,spoint
			)
			,point(int16(0), int16(0))
			,point(int16(5), int16(4))
		);

	unit<UInt32> HTiledDomain := TiledUnit(2[HDomain]);
	unit<UInt32> ATiledDomain := TiledUnit(2[ADomain]);
	unit<UInt32> CTiledDomain := TiledUnit(2[CDomain]);
	unit<UInt32> RTiledDomain := TiledUnit(2[RDomain]);
	unit<UInt32> LTiledDomain := TiledUnit(2[LDomain]);
	unit<UInt32> ETiledDomain := TiledUnit(2[EDomain]);

	unit<uint32> RegionTiledDomain         := TiledUnit(2[RegionDomain]);
	unit<uint32> ERegionTiledDomain        := TiledUnit(2[ERegionDomain]);

	unit<uint32> CountryTiledDomain        := TiledUnit(2[CountryDomain]);

	unit<uint32> DistrictTiledDomain       := TiledUnit(2[DistrictDomain]);
	unit<uint32> RoadTiledDomain           := TiledUnit(2[RoadDomain]);
	unit<uint32> CityTiledDomain           := TiledUnit(2[CityDomain]);
	unit<uint32> DistrictPointsTiledDomain := TiledUnit(10[DistrictPointsDomain]);

	unit<uint32> PandPointsTiledDomain     := TiledUnit(10[PandPointsDomain]);
	unit<uint32> PandTiledDomain           := TiledUnit(10[PandDomain]);
	
	unit<uint32> UDomain1: nrofrows = 10000;
	unit<uint32> UDomain2: nrofrows = 10000;

	unit<uint32> UTiledDomain1 := TiledUnit(1000[UDomain1]);
	unit<uint32> UTiledDomain2 := TiledUnit(1000[UDomain2]);

	// gebruikte values units
	unit<float32> DegreesCelsius  := Range(BaseUnit('celsius',float32), -20f, 50f);
	unit<float32> DegreesCelsius2 := DegreesCelsius * DegreesCelsius; // used for statistical tests, (co)variance, 
	unit<uint32>  RegionEK;
	unit<uint32>  nrPersons;
	unit<float32> s               := baseunit('s', float32), label = "seconde";
	unit<uint32>  Years           :nrofrows = 3;
	unit<float32> m               := baseunit('m', float32), label = "meter", cdf = "classifications/m_4K/classes";
	unit<float32> m2              := m * m;
	unit<int16>   m_int16         := int16(m);
	unit<uint32>  color           :Range = "[0, 16777217)";
	unit<uint32>  rgb;
	unit<int16>   fontsize;
	unit<int16>   size;
	unit<int16>   index;

	// vergelijkingsparameters voor floating point items
	parameter <float32> Dif_all_float32   :=float32(0.99);
	parameter <float64> Dif_all_float64   :=0.99;
	parameter <float32> Dif_pconv_float32 := float32(1.000001);
	parameter <float64> Dif_pconv_float64 := 1.000001;

	container MetaInfo
	{
		//parameter <string> TestDbName := '%projdir%/data/OperatorTest.mdb';
		container OperatorList := DocData()
		// Structuur wordt hier herhaald om afleidingen te doen
		{
			unit<uint32> ObjectTypes
			{
				attribute<string> Name;
			}
			unit<uint32> OperatorGroups
			{
				attribute<string> Name;
			}
			unit<uint32> Operators
			{
				attribute<OperatorGroups> nr_Group;
				attribute<ObjectTypes>    nr_ResType;

				attribute<string> GroupName   := OperatorGroups/Name[nr_Group];
				attribute<string> ResTypeName := ObjectTypes/Name[nr_ResType];
			}
			unit<uint32> OperatorArgs
			{
				attribute<Operators>      nr_Operator;
				attribute<ObjectTypes>    nr_ArgType;
				attribute<OperatorGroups> nr_Group    := Operators/nr_Group[nr_Operator];
				attribute<string>         GroupName   := OperatorGroups/Name[nr_Group];
				attribute<string>         ArgTypeName := ObjectTypes/Name[nr_ArgType];
			}
		}
		container StorageManagersInfo := DocStorageManagers();
		
		container results
		{
			parameter<bool> test := #OperatorList/OperatorArgs > 10000 && #MetaInfo/StorageManagersInfo/StorageManagers > 15;
		}
	}
	container Classifications
	{
		unit<uint8> m_4K: nrofrows = 4
		{
			attribute<m> Classes
			:	DialogType = "Classification"
			,	[
					0,1000,2500,5000
				];
			attribute<uint32> BrushColor
			:	DialogType = "BrushColor"
			,	[
					rgb(128,255,0),rgb(0,128,0),rgb(0,64,128),rgb(255,0,0)
				];
			attribute<string> Label
			:	DialogType = "LabelText"
			,	[
					'0   - 1.000','1.000 - 2.500','2.500 - 5.000','    > 5.000'
				];
		}
		unit<uint8> inhabitants_4K: nrofrows = 4
		{
			attribute<nrPersons> Classes
			:	DialogType = "Classification"
			,	[
					0,100,300,800
				];
		}
		unit<uint8> inhabitants_20K: nrofrows = 20;
		unit<uint8> inhabitants_0K: nrofrows = 0
		{
			attribute<nrPersons> Classes: [];
		}
		unit<uint8> m_5K: nrofrows = 5
		{
			attribute<m> Classes
			:	DialogType = "Classification"
			,	[
					0,500,1000,1500,2500
				];
		}
		unit<uint8> JF_8k: nrofrows = 8
		{
			attribute<uint32> Classes: DialogType = "Class_Breaks",
				 = ClassifyJenksFisher(/Aggregations/UnTiled2UnTiled/City/NrInhabitants, .);
			
//			attribute<uint32> RampYellowToGreen := ramp_rgb(rgb(255,255,0), rgb(0, 255, 0),.)",DialogType = "BrushColor";
			attribute<uint32> RampWhiteToRed := ramp_rgb(rgb(255,255,255), rgb(255, 0, 0),.),DialogType = "BrushColor";
	
			attribute<String> Label: DialogType = "LabelText",
			['Low','','','','','','','High'];
		}
	}
	container Arithmetics
	{
		container srcDomain       := source(ADomain);
		container srcEDomain      := Esource(EDomain);

		container srcTiledDomain  := source(ATiledDomain);
		container srcETileDomain  := Esource(ETiledDomain);

		template source
		{
			// begin case parameters
			unit<uint32> Domain;
			// end case parameters

			parameter<uint32> ParamA := 5;
			parameter<uint32> ParamB := 7;
			parameter<uint32> ParamC := 2;
			parameter<int32>  ParamD := int32(5);

			attribute<float32> A     (Domain): [0,1,-2,3.6,999];
			attribute<float32> B     (Domain): [1,-1,2,1.44,111];
			attribute<int32>   C     (Domain): [0,1,4,7,-5];
			attribute<int32>   D     (Domain): [1,1,2,3,-2];
			attribute<float32> AddABC(Domain): [1,1,4,12.04,1105];
			attribute<float32> AsubB (Domain): [-1,2,-4,2.16,888];
			attribute<float32> mulABC(Domain): [0,-1,-16,36.288,-554445];
			attribute<float32> AdivB (Domain): [0,-1,-1,2.5,9];
			attribute<int32>   CmodD (Domain): [0,0,0,1,-1];
//			attribute<float64> CPowD (Domain): [0,1,16,343,0.04];
			attribute<float64> CPowD (Domain): [null,1,16,343,null];
			attribute<float32> NegA  (Domain): [0,-1,2,-3.6,-999];
			attribute<float32> RevB  (Domain): [111,1.44,2,-1,1];
			attribute<float32> AbsA  (Domain): [0,1,2,3.6,999];
			attribute<float32> sqrA  (Domain): [0,1,4,12.96,998001];
			attribute<float32> sqrtA (Domain): [0,1,null,1.89737,31.607];
		}
		template Esource
		{
			// begin case parameters
			unit<uint32> Domain;
			// end case parameters

			parameter<uint32> ParamA := 5;
			parameter<uint32> ParamB := 7;
			parameter<uint32> ParamC := 2;
			parameter<int32>  ParamD := int32(5);

			attribute<float32> A     (Domain): [];
			attribute<float32> B     (Domain): [];
			attribute<int32>   C     (Domain): [];
			attribute<int32>   D     (Domain): [];
			attribute<float32> AddABC(Domain): [];
			attribute<float32> AsubB (Domain): [];
			attribute<float32> mulABC(Domain): [];
			attribute<float32> AdivB (Domain): [];
			attribute<int32>   CmodD (Domain): [];
//			attribute<float64> CPowD (Domain): [];
			attribute<float64> CPowD (Domain): [];
			attribute<float32> NegA  (Domain): [];
			attribute<float32> RevB  (Domain): [];
			attribute<float32> AbsA  (Domain): [];
			attribute<float32> sqrA  (Domain): [];
			attribute<float32> sqrtA (Domain): [];
		}

		container UnTiled  := Template(ADomain, srcDomain);
		container EunTiled := Template(EDomain, srcEDomain);
		container Tiled    := Template(ATiledDomain, srcTiledDomain);
		container ETiled   := Template(ETiledDomain, srcETileDomain);

		Template Template
		{
			// begin case parameters
			unit<uint32> Domain;
			container source;
			// end case parameters

			container add_op: url = "http://www.objectvision.nl/geodms/operators-a-functions/arithmetic/add"
			{
				parameter<bool>    test_param          := source/ParamA + source/ParamB = 12;
				attribute<float32> attr       (Domain) := source/A + source/B + float32(source/C);
				attribute<bool>    test       (Domain) := attr = source/AddABC;
				attribute<fpoint>  att_point  (Domain) := add(point(source/A,source/B,fpoint), point(source/A,source/B,fpoint));
				attribute<bool>    test_point (Domain) := pointRow(att_point) = float32(2) * source/A && pointCol(att_point) = float32(2) * source/B;
				parameter<bool>    test_attr           := all(test) && all(test_point);
			}
			container add: url = "http://www.objectvision.nl/geodms/operators-a-functions/arithmetic/add"
			{
				parameter<bool>    test_param    := add(source/ParamA , source/ParamB) = 12;
				attribute<float32> attr (Domain) := add(source/A, source/B, float32(source/C));
				attribute<bool>    test (Domain) := attr = source/AddABC;
				parameter<bool>    test_attr     := all(test);
			}
			container sub_op: url = "http://www.objectvision.nl/geodms/operators-a-functions/arithmetic/sub"
			{
				parameter<bool>    test_param    := int32(source/ParamA) - int32(source/ParamB) = -2;
				attribute<float32> attr (Domain) := source/A - source/B ;
				attribute<bool>    test (Domain) := float_isNearby(attr, source/AsubB, Dif_all_float32) ;
				parameter<bool>    test_attr     := all(test);
			}
			container sub: url = "http://www.objectvision.nl/geodms/operators-a-functions/arithmetic/sub"
			{
				parameter<bool>    test_param    :=sub(int32(source/ParamA), int32(source/ParamB)) = -2;
				attribute<float32> attr (Domain) := sub(source/A, source/B);
				attribute<bool>    test (Domain) := float_isNearby(attr, source/AsubB, Dif_all_float32) ;
				parameter<bool>    test_attr     := all(test);
			}
			container mul_op: url = "http://www.objectvision.nl/geodms/operators-a-functions/arithmetic/mul"
			{
				parameter<bool>    test_param    :=source/ParamA * source/ParamB = 35;
				attribute<float32> attr (Domain) := source/A * source/B * float32(source/C);
				attribute<bool>    test (Domain) := float_isNearby(attr, Source/mulABC, Dif_all_float32);
				parameter<bool>    test_attr     := all(test);
			}
			container mul: url = "http://www.objectvision.nl/geodms/operators-a-functions/arithmetic/mul"
			{
				attribute<float32> attr (Domain) := mul(source/A,source/B,float32(source/C));
				attribute<bool>    test (Domain) := float_isNearby(attr, Source/mulABC, Dif_all_float32);
				parameter<bool>    test_attr     := all(test);
			}
			container div_op: url = "http://www.objectvision.nl/geodms/operators-a-functions/arithmetic/div"
			{
				parameter<bool>    test_param    := source/ParamA / source/ParamB = 5/7;
				attribute<float32> attr (Domain) := source/A / source/B;
				attribute<bool>    test (Domain) := float_isNearby(attr, source/AdivB, Dif_all_float32) ;
				parameter<bool>    test_attr     := all(test);
			}
			container div: url = "http://www.objectvision.nl/geodms/operators-a-functions/arithmetic/div"
			{
				parameter<bool>    test_param    := div(source/ParamA, source/ParamB) = 5/7;
				attribute<float32> attr (Domain) := div(source/A, source/B);
				attribute<bool>    test (Domain) := float_isNearby(attr, source/AdivB, Dif_all_float32) ;
				parameter<bool>    test_attr     := all(test);
			}
			container mod_op: url = "http://www.objectvision.nl/geodms/operators-a-functions/arithmetic/mod"
			{
				parameter<bool>    test_param    := source/ParamB % source/ParamA = 2 && isNull(2 % 0); 
				attribute<int32>   attr (Domain) := source/C % source/D;
				attribute<bool>    test (Domain) := attr = source/CModD;
				parameter<bool>    test_attr     := all(test);
			}
			container mod: url = "http://www.objectvision.nl/geodms/operators-a-functions/arithmetic/mod"
			{
				parameter<bool>    test_param    := mod(source/ParamB, source/ParamA) = 2 && isNull(mod(2, 0)); 
				attribute<int32>   attr (Domain) := mod(source/C, source/D);
				attribute<bool>    test (Domain) := attr = source/CModD;
				parameter<bool>    test_attr     := all(test);
			}
			container pow_op: url = "http://www.objectvision.nl/geodms/operators-a-functions/arithmetic/pow"
			{
				parameter<bool>    test_param    := float_isNearby(float64(source/ParamA) ^ float64(source/ParamC), 25.0, Dif_all_float64) ;
				attribute<float32> attr (Domain) := float32(source/C) ^ float32(source/D);
				attribute<bool>    test (Domain) := float_isNearby(attr, float32(source/CPowD), Dif_all_float32) ;
				parameter<bool>    test_attr     := all(test);
			}
			container pow: url = "http://www.objectvision.nl/geodms/operators-a-functions/arithmetic/pow"
			{
				parameter<bool>    test_param    := float_isNearby(pow(float64(source/ParamA), float64(source/ParamC)), 25.0, Dif_all_float64) ;
				attribute<float32> attr (Domain) := pow(float32(source/C), float32(source/D));
				attribute<bool>    test (Domain) := float_isNearby(attr, float32(source/CPowD), Dif_all_float32) ;
				parameter<bool>    test_attr     := all(test);
			}
			container plus_op
			{
				parameter<bool>    test_param    := +source/ParamA = 5;
				attribute<float32> attr (Domain) := +source/A;
				attribute<bool>    test (Domain) := attr = source/A;
				parameter<bool>    test_attr     := all(test);
			}
			/*container plus:
				url = "http://www.objectvision.nl/Geodms/Function/plus"
			{
				parameter<bool>    test_param      := plus(source/ParamA) = 5;
				attribute<float32> attr (Domain) := plus(source/A);
				attribute<bool>    test (Domain) := attr = source/A;
				parameter<bool>    test_attr       := all(test);
			}*/
			container neg_op: url = "http://www.objectvision.nl/geodms/operators-a-functions/arithmetic/neg"
			{
				parameter<bool>    test_param    := -source/ParamA = -5;
				attribute<float32> attr (Domain) := -source/A;
				attribute<bool>    test (Domain) := attr = source/NegA;
				parameter<bool>    test_attr     := all(test);
			}
			container neg: url = "http://www.objectvision.nl/geodms/operators-a-functions/arithmetic/neg"
			{
				parameter<bool>    test_param    := neg(source/ParamA) = -5;
				attribute<float32> attr (Domain) := neg(source/A);
				attribute<bool>    test (Domain) := attr = source/NegA;
				parameter<bool>    test_attr     := all(test);
			}
			container abs: url = "http://www.objectvision.nl/geodms/operators-a-functions/arithmetic/abs",
				Descr = " Operator only in use for signed integers and floats !"
			{
				parameter<bool>    test_param    := abs(source/ParamD) = int32(5);
				attribute<float32> attr (Domain) := abs(source/A);
				attribute<bool>    test (Domain) := attr = source/AbsA;
				parameter<bool>    test_attr     := all(test);
			}
			container sqr: url   = "http://www.objectvision.nl/geodms/operators-a-functions/arithmetic/sqr"
			{
				parameter<bool>    test_param    := sqr(5) = 25;
				attribute<float32> attr (Domain) := sqr(source/A);
				attribute<bool>    test (Domain) := float_isNearby(attr, source/sqrA, Dif_all_float32) ; 
				parameter<bool>    test_attr     := all(test);
			}
			container sqrt: url = "http://www.objectvision.nl/geodms/operators-a-functions/arithmetic/sqrt"
			{
				parameter<bool>    test_param    := sqrt(25) = 5.0;
				attribute<float32> attr (Domain) := sqrt(source/A);
				attribute<bool>    test (Domain) := float_isNearby(attr, source/sqrtA, Dif_all_float32) ; 
				parameter<bool>    test_attr     := all(test);
			}
			container ordinal
			{
				attribute<uint32> attr (Domain) := ordinal(uint32(source/C));
			}
			container results
			{
				parameter<bool> test_params :=
					   add_op/test_param 
					&& add/test_param 
					&& sub_op/test_param 
					&& sub/test_param 
					&& mul_op/test_param 
					&& div_op/test_param 
					&& div/test_param 
					&& mod_op/test_param 
					&& mod/test_param 
					&& pow_op/test_param 
					&& pow/test_param 
					&& neg_op/test_param 
					&& neg/test_param 
					&& abs/test_param 
					&& sqr/test_param 
					&& sqrt/test_param ;
				parameter<bool> test_attrs :=
					   add_op/test_attr 
					&& add/test_attr 
					&& sub_op/test_attr 
					&& sub/test_attr 
					&& mul_op/test_attr 
					&& mul/test_attr 
					&& div_op/test_attr 
					&& div/test_attr 
					&& mod_op/test_attr 
					&& mod/test_attr 
					&& pow_op/test_attr 
					&& pow/test_attr 
					&& neg_op/test_attr 
					&& neg/test_attr 
					&& abs/test_attr 
					&& sqr/test_attr 
					&& sqrt/test_attr ;
				parameter <bool> tests := test_params && test_attrs;
			}
		}
	}
	/* Currently not supported
	container arithmetic_uint2_4_8
	{
		container source
		{
			attribute<uint32> plusUint2 (Adomain): [0,0,1,1,1];
		}
		container plusUint2
		{
			attribute<uint2>   att  (ADomain) := Conversion/UInt2/att_bool + Conversion/UInt2/att_int;
			attribute<bool>    test (ADomain) := att = source/plusUint2; 
			parameter<bool>    test_attr     := all(test);
		}
	}
	*/
	container Precedence
	{
		container associative
		{
			parameter<bool> test_param_plus    := ++4.0 == 4.0;
			parameter<bool> test_param_plusmin := +-4.0 == -4.0;
			parameter<bool> test_param_minplus := -+4.0 == -4.0;
			parameter<bool> test_param_minmin  := --4.0 == 4.0;
			parameter<bool> test_param_pow     := 4.0 ^ 2.0 ^ 3.0 == 4096.0;
			parameter<bool> test_param_SubItem := all(eq_or_both_null(Relational/UnTiled2UnTiled!'Region'!'AvgDailyTemperature', Relational/UnTiled2UnTiled/Region/AvgDailyTemperature));
			parameter<bool> test_param_mod     := 15 % 4 % 3 == 0;
			parameter<bool> test_param_mul     := 5 * 3 * 2 == 30;
			parameter<bool> test_param_div     := 625 / 5 / 25 == 5;
			parameter<bool> test_param_add     := 5 + 3 + 2 == 10;
			parameter<bool> test_param_sub     := 5 - 3 - 2 == 0;
			parameter<bool> test_param_not     := !!true;
			parameter<bool> test_param_and     := true && true && true;
			parameter<bool> test_param_or      := true || false || false;
			parameter<bool> test_param_iif     := false ? true : false ? false : true;
		}
		container combined
		{
			parameter<bool> test_param_AddMul          := 5 + 3 * 2 == 11;
			parameter<bool> test_param_DivMul          := 25 / 5 * 2 == 10;
			parameter<bool> test_param_DivSub          := 25 / 5 - 2 == 3;
			parameter<bool> test_param_PlusPow         := +3.0 ^ 2.0  == 9.0;
			parameter<bool> test_param_NegPow          := -3.0 ^ 2.0  == 9.0;
			parameter<bool> test_param_SubLook         := Relational/UnTiled2UnTiled/Region!'AvgDailyTemperature'[4] == value(13, DegreesCelsius);
			parameter<bool> test_param_LookupPow       := float64(Relational/UnTiled2UnTiled/Region/AvgDailyTemperature)[3]  ^ 2.0 == 196.0;
			parameter<bool> test_param_LookupNrRows    :=Relational/UnTiled2UnTiled/Region/AvgDailyTemperature[#Classifications/m_4K] == value(13, DegreesCelsius);
			parameter<bool> test_param_PowMulAdd       := 1.0 + 3.0 * 5.0 ^ 2.0  == 76.0;
			parameter<bool> test_param_AddSubDivPowMul := 40.0 + 1.0 - 81.0 / 3.0 ^ 2.0 * 4.0 == 5.0;
			parameter<bool> test_param_Addeq           := 40.0 + 1.0 == 41.0;
			parameter<bool> test_param_MulNoteq        := 40.0 * 2.0 <> 100.0;
			parameter<bool> test_param_Powlt           := 2.0 ^ 4.0 < 100.0;
			parameter<bool> test_param_Modlteq         := 40.0 % 2.0 <= 0.0;
			parameter<bool> test_param_Subgt           := 40.0 - 29.0 >  10.0;
			parameter<bool> test_param_Divgteq         := 40.0 / 2.0 >= 20.0;
			parameter<bool> test_param_NotAnd          := !true == false && true ;
			parameter<bool> test_param_AndOr           := false || true && false == false;
			parameter<bool> test_param_iifMulAdd       := (true ? 2 * 6 : 3 + 7) == 12;
		}
		container results
		{
			parameter<bool> tests :=
				   associative/test_param_plus 
				&& associative/test_param_plusmin 
				&& associative/test_param_minplus 
				&& associative/test_param_minmin 
				&& associative/test_param_pow 
				&& associative/test_param_SubItem 
				&& associative/test_param_mul 
				&& associative/test_param_div 
				&& associative/test_param_add 
				&& associative/test_param_sub 
				&& associative/test_param_not 
				&& associative/test_param_and 
				&& associative/test_param_or 
				&& associative/test_param_iif 
				&& combined/test_param_AddMul 
				&& combined/test_param_DivMul 
				&& combined/test_param_DivSub 
				&& combined/test_param_PlusPow 
				&& combined/test_param_NegPow 
				&& combined/test_param_SubLook 
				&& combined/test_param_LookupPow 
				&& combined/test_param_LookupNrRows 
				&& combined/test_param_PowMulAdd 
				&& combined/test_param_Addeq 
				&& combined/test_param_MulNoteq 
				&& combined/test_param_Powlt 
				&& combined/test_param_Modlteq 
				&& combined/test_param_Subgt 
				&& combined/test_param_Divgteq 
				&& combined/test_param_NotAnd 
				&& combined/test_param_AndOr 
				&& combined/test_param_iifMulAdd;
		}
	}
	container Ordering
	{
		container srcDomain          := source(CDomain);
		container srcEDomain         := Esource(EDomain);

		container srcTiledDomain     := source(CTiledDomain);
		container srcETileDomain     := Esource(ETiledDomain);

		container srcDomDomain       := domsource(ADomain);
		container srcEDomDomain      := Edomsource(EDomain);

		container srcTiledDomDomain  := domsource(ATiledDomain);
		container srcETiledDomDomain := Edomsource(ETiledDomain);

		template source
		{
			// begin case parameters
			unit<uint32> Domain;
			// end case parameters

			parameter<uint32>  ParamA := 5;
			parameter<uint32>  ParamB := 7;

			attribute<float32> A        (Domain): [0,1,2.5,-100,999,null,null,0, null,100];
			attribute<float32> B        (Domain): [0,2,2.5,100,-999,0,null,null, 100,null];
			attribute<float32> B_nearby (Domain): [0,2,2.49,98,998.5,0.1,null,null, 100,null];
			
			attribute<bool>    AisB   (Domain): [-1,0,-1,0,0,0,0,0,0,0];
			attribute<bool>    eqAB   (Domain): [-1,0,-1,0,0,0,-1,0,0,0];
			attribute<bool>    AltB   (Domain): [0,-1,0,-1,0,0,0,0,0,0];
			attribute<bool>    ltAB   (Domain): [0,-1,0,-1,0,-1,0,0,-1,0];
			attribute<bool>    AlteqB (Domain): [-1,-1,-1,-1,0,0,0,0,0,0];
			attribute<bool>    leAB   (Domain): [-1,-1,-1,-1,0,-1,-1,0,-1,0];
			attribute<bool>    AgtB   (Domain): [0,0,0,0,-1,0,0,0,0,0];
			attribute<bool>    gtAB   (Domain): [0,0,0,0,-1,0,0,-1,0,-1];
			attribute<bool>    AgteqB (Domain): [-1,0,-1,0,-1,0,0,0,0,0];
			attribute<bool>    geAB   (Domain): [-1,0,-1,0,-1,0,-1,-1,0,-1];
			attribute<bool>    AnotB  (Domain): [0,-1,0,-1,-1,0,0,0,0,0];
			attribute<bool>    neAB   (Domain): [0,-1,0,-1,-1,-1,0,-1,-1,-1];
			attribute<float32> sortA  (Domain): [null,null,null,-100,0,0,1,2.5,100,999]; 
			attribute<float32> revA   (Domain): [100,null,0,null,null,999,-100,2.5,1,0]; 
			attribute<bool>    flNAB  (Domain): [1,0,1,0,1,0,1,0,0,0]; 
		}
		template Esource
		{
			// begin case parameters
			unit<uint32> Domain;
			// end case parameters

			parameter<uint32>  ParamA := 5;
			parameter<uint32>  ParamB := 7;

			attribute<float32> A      (Domain): [];
			attribute<float32> B      (Domain): [];
			attribute<float32> B_nearby (Domain): [];
			attribute<bool>    AisB   (Domain): [];
			attribute<bool>    eqAB   (Domain): [];
			attribute<bool>    AltB   (Domain): [];
			attribute<bool>    ltAB   (Domain): [];
			attribute<bool>    AlteqB (Domain): [];
			attribute<bool>    leAB   (Domain): [];
			attribute<bool>    AgtB   (Domain): [];
			attribute<bool>    gtAB   (Domain): [];
			attribute<bool>    AgteqB (Domain): [];
			attribute<bool>    geAB   (Domain): [];
			attribute<bool>    AnotB  (Domain): [];
			attribute<bool>    neAB   (Domain): [];
			attribute<float32> sortA  (Domain): []; 
			attribute<float32> revA   (Domain): []; 
			attribute<bool>    flNAB  (Domain): [];
		}

		template domsource
		{
			// begin case parameters
			unit<uint32> DomDomain;
			// end case parameters

			parameter<float64> paramA :=  1.0;
			parameter<float64> paramB := -3.9;
			parameter<float64> paramC :=  1.1;

			attribute<int32>   A                    (DomDomain): [0,1,-2,4,999];
			attribute<int32>   B                    (DomDomain): [1,-1,2,null,111];
			attribute<int32>   C                    (DomDomain): [2,4,2,7,-5];

			attribute<int32>   A_null               (DomDomain): [   2,0   ,null,null,1];
			attribute<int32>   B_null               (DomDomain): [null,1   ,1   ,null,1];
			attribute<int32>   C_null               (DomDomain): [   1,null,2   ,null,1];

			attribute<float32> D                    (DomDomain): [1,null,2,3,-2];
			attribute<float32> EE                   (DomDomain): [1.5,-1,1,-3.5,9999];
			attribute<float32> F                    (DomDomain): [2.5,null,2,3.5,9998.9];

			attribute<uint32>  argmaxIntABC         (DomDomain): [2,2,1,2,0];
			attribute<uint32>  argmaxFloatDEF       (DomDomain): [2,0,0,2,1];
			attribute<uint32>  argmaxNull           (DomDomain): [0,1,2,0,0];
			attribute<uint32>  certain_argmaxNull   (DomDomain): [null,null,null,null,0];
			attribute<uint32>  known_argmaxNull     (DomDomain): [0,1,2,null,0];

			attribute<uint32>  argminIntABC         (DomDomain): [0,1,0,1,2];
			attribute<uint32>  argminFloatDEF       (DomDomain): [0,1,1,1,0];
			attribute<uint32>  argminNull           (DomDomain): [2,0,1,0,0];
			attribute<uint32>  certain_argminNull   (DomDomain): [null,null,null,null,0];
			attribute<uint32>  known_argminNull     (DomDomain): [2,0,1,null,0];

			attribute<int32>   max_elemIntABC       (DomDomain): [2,4,2,7,999];
			attribute<float32> max_elemFloatDEF     (DomDomain): [2.5,0,2,3.5,9999];
			attribute<int32>   max_elemNull         (DomDomain): [2,1,2,null,1];
			attribute<int32>   certain_max_elemNull (DomDomain): [null,null,null,null,1];
			attribute<int32>   known_max_elemNull   (DomDomain): [2,1,2,null,1];

			attribute<int32>   min_elemIntABC       (DomDomain): [0,-1,-2,0,-5];
			attribute<float32> min_elemFloatDEF     (DomDomain): [1,-1,1,-3.5,-2];
			attribute<int32>   min_elemNull         (DomDomain): [1,0,1,null,1];
			attribute<int32>   certain_min_elemNull (DomDomain): [null,null,null,null,1];
			attribute<int32>   known_min_elemNull   (DomDomain): [1,0,1,null,1];

			attribute<int32>   medianIntABC         (DomDomain): [1, 1,2,4,111];
			attribute<float32> medianFloatDEF       (DomDomain): [1.5,0,2,3,9998.9];
		}
		template Edomsource
		{
			// begin case parameters
			unit<uint32> DomDomain;
			// end case parameters

			parameter<float64> paramA :=  1.0;
			parameter<float64> paramB := -3.9;
			parameter<float64> paramC :=  1.1;

			attribute<int32>   A                    (DomDomain): [];
			attribute<int32>   B                    (DomDomain): [];
			attribute<int32>   C                    (DomDomain): [];

			attribute<int32>   A_null               (DomDomain): [];
			attribute<int32>   B_null               (DomDomain): [];
			attribute<int32>   C_null               (DomDomain): [];

			attribute<float32> D                    (DomDomain): [];
			attribute<float32> EE                   (DomDomain): [];
			attribute<float32> F                    (DomDomain): [];

			attribute<uint32>  argmaxIntABC         (DomDomain): [];
			attribute<uint32>  argmaxFloatDEF       (DomDomain): [];
			attribute<uint32>  argmaxNull           (DomDomain): [];
			attribute<uint32>  certain_argmaxNull   (DomDomain): [];
			attribute<uint32>  known_argmaxNull     (DomDomain): [];

			attribute<uint32>  argminIntABC         (DomDomain): [];
			attribute<uint32>  argminFloatDEF       (DomDomain): [];
			attribute<uint32>  argminNull           (DomDomain): [];
			attribute<uint32>  certain_argminNull   (DomDomain): [];
			attribute<uint32>  known_argminNull     (DomDomain): [];

			attribute<int32>   max_elemIntABC       (DomDomain): [];
			attribute<float32> max_elemFloatDEF     (DomDomain): [];
			attribute<int32>   max_elemNull         (DomDomain): [];
			attribute<int32>   certain_max_elemNull (DomDomain): [];
			attribute<int32>   known_max_elemNull   (DomDomain): [];
			
			attribute<int32>   min_elemIntABC       (DomDomain): [];
			attribute<float32> min_elemFloatDEF     (DomDomain): [];
			attribute<int32>   min_elemNull         (DomDomain): [];
			attribute<int32>   certain_min_elemNull (DomDomain): [];
			attribute<int32>   known_min_elemNull   (DomDomain): [];

			attribute<int32>   medianIntABC         (DomDomain): [];
			attribute<float32> medianFloatDEF       (DomDomain): [];
		}

		container UnTiled  := Template(CDomain     , ADomain     , srcDomain     , srcDomDomain);
		container EunTiled := Template(EDomain     , EDomain     , srcEDomain    , srcEDomDomain);
		container Tiled    := Template(CTiledDomain, ATiledDomain, srcTiledDomain, srcTiledDomDomain);
		container ETiled   := Template(ETiledDomain, ETiledDomain, srcETileDomain, srcETiledDomDomain);

		//container UnTiled := Template(CDomain, ADomain);
		//container Tiled := Template(CTiledDomain, ATiledDomain);

		Template Template
		{
			// begin case parameters
			unit<uint32> Domain;
			unit<uint32> DomDomain;
			container source;
			container DomSource;
			// end case parameters
			
			
			container eq_op
			:	Descr = "Null = Null resulteert in false"
			,	url   = "http://www.objectvision.nl/geodms/operators-a-functions/ordering/eq"
			{
				parameter<bool> test_param          := source/ParamB == 7;
				attribute<bool> attr (Domain)       := source/A == source/B;
				attribute<bool> test (Domain)       := attr == source/AisB;
				parameter<bool> test_attr           := all(test);
				parameter<bool> test_case_sensitive := 't' == 'T';
			}
			container eq
			:	Descr = "Null = Null resulteert in false"
			,	url   = "http://www.objectvision.nl/geodms/operators-a-functions/ordering/eq"
			{
				parameter<bool> test_param          := eq(source/ParamB, 7);
				attribute<bool> attr (Domain)       := eq(source/A, source/B);
				attribute<bool> test (Domain)       := eq(attr, source/AisB);
				parameter<bool> test_attr           := all(test);
				parameter<bool> test_case_sensitive := not(eq('t', 'T')) && ne('t', 'T');
			}
			container eq_or_both_null
			:	Descr = "Null = Null resulteert in true"
			,	url   = "http://www.objectvision.nl/geodms/operators-a-functions/ordering/eq_or_both_null"
			{
				parameter<bool> test_param          := eq_or_both_null(source/ParamB, 7);
				attribute<bool> attr (Domain)       := eq_or_both_null(source/A, source/B);
				attribute<bool> test (Domain)       := attr = source/eqAB;
				parameter<bool> test_attr           := all(test);
				parameter<bool> test_case_sensitive := not(eq_or_both_null('t', 'T'));
			}
			container lt_op
			:	Descr = "lt means less then, i.e. <, Null < .. results in false"
			,	url   = "http://www.objectvision.nl/geodms/operators-a-functions/ordering/lt"
			{
				parameter<bool> test_param          := source/ParamA < source/ParamB;
				attribute<bool> attr (Domain)       := source/A < source/B; 
				attribute<bool> test (Domain)       := attr = source/AltB;
				parameter<bool> test_attr           := all(test);
				parameter<bool> test_case_sensitive := 'T' < 't';
			}
			container lt
			:	Descr = "lt means less then, i.e. <, Null < .. results in false"
			,	url   = "http://www.objectvision.nl/geodms/operators-a-functions/ordering/lt"
			{
				parameter<bool> test_param          := lt(source/ParamA, source/ParamB);
				attribute<bool> attr (Domain)       := lt(source/A, source/B); 
				attribute<bool> test (Domain)       := attr = source/AltB;
				parameter<bool> test_attr           := all(test);
				parameter<bool> test_case_sensitive := lt('T' , 't');
			}
			container lt_or_lhs_null
			:	Descr = "lt_or_lhs_null means less then, i.e. <, Null < .. results in true, except for Null < Null"
			,	url   = "http://www.objectvision.nl/geodms/operators-a-functions/ordering/lt_or_lhs_null"
			{
				parameter<bool> test_param          := lt_or_lhs_null(source/ParamA, source/ParamB);
				attribute<bool> attr (Domain)       := lt_or_lhs_null(source/A, source/B);
				attribute<bool> test (Domain)       := attr = source/ltAB;
				parameter<bool> test_attr           := all(test);
				parameter<bool> test_case_sensitive := lt_or_lhs_null('T','t');
			}
			container le_op
			:	Descr = "le means less then or equal, i.e. <=, Null <= .. results in false"
			,	url   = "http://www.objectvision.nl/geodms/operators-a-functions/ordering/le"
			{
				parameter<bool> test_param          := source/ParamB <= source/ParamB;
				attribute<bool> attr (Domain)       := Source/A <= source/B;
				attribute<bool> test (Domain)       := attr = source/AlteqB;
				parameter<bool> test_attr           := all(test);
				parameter<bool> test_case_sensitive := 'T' <= 't';
			}
			container le
			:	Descr = "le means less then or equal, i.e. <=, Null <= .. results in false"
			,	url   = "http://www.objectvision.nl/geodms/operators-a-functions/ordering/le"
			{
				parameter<bool> test_param          := le(source/ParamB, source/ParamB);
				attribute<bool> attr (Domain)       := le(Source/A, source/B);
				attribute<bool> test (Domain)       := attr = source/AlteqB;
				parameter<bool> test_attr           := all(test);
				parameter<bool> test_case_sensitive := le('T', 't');
			}
			container le_or_lhs_null
			:	Descr = "le_or_lhs_null means less then or equal, i.e. <= , Null <= .. results in true"
			,	url   = "http://www.objectvision.nl/geodms/operators-a-functions/ordering/le_or_lhs_null"
			{
				parameter<bool> test_param          := le_or_lhs_null(source/ParamA, source/ParamB);
				attribute<bool> attr (Domain)       := le_or_lhs_null(source/A, source/B);
				attribute<bool> test (Domain)       := attr = source/leAB;
				parameter<bool> test_attr           := all(test);
				parameter<bool> test_case_sensitive := le_or_lhs_null('T','t');
			}
			container gt_op
			:	Descr = "gt means greater then, i.e. >"
			,	url   = "http://www.objectvision.nl/geodms/operators-a-functions/ordering/gt"
			{
				parameter<bool> test_param          := source/ParamB > source/ParamA;
				attribute<bool> attr (Domain)       := source/A > source/B;
				attribute<bool> test (Domain)       := attr = source/AgtB;
				parameter<bool> test_attr           := all(test);
				parameter<bool> test_case_sensitive := not('T' > 't');
			}
			container gt
			:	Descr = "gt means greater then, i.e. >"
			,	url   = "http://www.objectvision.nl/geodms/operators-a-functions/ordering/gt"
			{
				parameter<bool> test_param          := gt(source/ParamB, source/ParamA);
				attribute<bool> attr (Domain)       := gt(source/A, source/B);
				attribute<bool> test (Domain)       := attr = source/AgtB;
				parameter<bool> test_attr           := all(test);
				parameter<bool> test_case_sensitive := not(gt('T', 't'));
			}
			container gt_or_rhs_null
			:	Descr = "gt_or_rhs_null means greater then, i.e. >, Null > .. results in true, except for Null > Null"
			,	url   = "http://www.objectvision.nl/geodms/operators-a-functions/ordering/gt_or_rhs_null"
			{
				parameter<bool> test_param          := gt_or_rhs_null(source/ParamB, source/ParamA);
				attribute<bool> attr (Domain)       := gt_or_rhs_null(source/A, source/B);
				attribute<bool> test (Domain)       := attr = source/gtAB;
				parameter<bool> test_attr           := all(test);
				parameter<bool> test_case_sensitive := not(gt_or_rhs_null('T','t'));
			}
			container ge_op
			:	Descr = "gt means greater then or equal, i.e. >= "
			,	url   = "http://www.objectvision.nl/geodms/operators-a-functions/ordering/ge"
			{
				parameter<bool> test_param          := source/ParamB >= source/ParamB;
				attribute<bool> attr (Domain)       := source/A >=  source/B;
				attribute<bool> test (Domain)       := attr = source/AgteqB;
				parameter<bool> test_attr           := all(test);
				parameter<bool> test_case_sensitive := not('T' >= 't');
			}
			container ge
			:	Descr = "ge means greater then or equal, i.e. >= "
			,	url   = "http://www.objectvision.nl/geodms/operators-a-functions/ordering/ge"
			{
				parameter<bool> test_param          := ge(source/ParamB, source/ParamB);
				attribute<bool> attr (Domain)       := ge(source/A, source/B);
				attribute<bool> test (Domain)       := attr = source/AgteqB;
				parameter<bool> test_attr           := all(test);
				parameter<bool> test_case_sensitive := not(ge('T', 't'));
			}
			container ge_or_rhs_null
			:	Descr = "ge_or_rhs_null means greater then or equal, i.e. >= , Null >= .. results in true"
			,	url   = "http://www.objectvision.nl/geodms/operators-a-functions/ordering/ge_or_rhs_null"
			{
				parameter<bool> test_param          := ge_or_rhs_null(source/ParamB, source/ParamA);
				attribute<bool> attr (Domain)       := ge_or_rhs_null(source/A, source/B);
				attribute<bool> test (Domain)       := attr = source/geAB;
				parameter<bool> test_attr           := all(test);
				parameter<bool> test_case_sensitive := not(ge_or_rhs_null('T','t'));
			}
			container ne_op
			:	Descr = ".. = Null results in false"
			,	url   = "http://www.objectvision.nl/geodms/operators-a-functions/ordering/ne"
			{
				parameter<bool> test_param    :=source/ParamA <> source/ParamB;
				attribute<bool> attr (Domain) := source/A <> source/B;
				attribute<bool> test (Domain) := attr = source/AnotB;
				parameter<bool> test_attr     := all(test);
			}
			container ne
			:	Descr = ".. = Null results in false"
			,	url   = "http://www.objectvision.nl/geodms/operators-a-functions/ordering/ne"
			{
				parameter<bool> test_param    :=ne(source/ParamA, source/ParamB);
				attribute<bool> attr (Domain) := ne(source/A, source/B);
				attribute<bool> test (Domain) := attr = source/AnotB;
				parameter<bool> test_attr     := all(test);
			}
			container ne_or_one_null
			:	Descr = ".. = Null results in true"
			,	url   = "http://www.objectvision.nl/geodms/operators-a-functions/ordering/ne_or_one_null"
			{
				parameter<bool> test_param          := ne_or_one_null(source/ParamA, source/ParamB);
				attribute<bool> attr (Domain)       := ne_or_one_null(source/A, source/B);
				attribute<bool> test (Domain)       := attr = source/neAB;
				parameter<bool> test_attr           := all(test);
				parameter<bool> test_case_sensitive := ne_or_one_null('T','t');
			}
			container argmax: url = "http://www.objectvision.nl/geodms/operators-a-functions/ordering/argmax"
			{
				parameter<bool>   test_param                := argmax(DomSource/paramA, DomSource/paramB, DomSource/paramC) == 2;
				attribute<uint32> att_int        (DomDomain) := argmax(DomSource/A, MakeDefined(DomSource/B, int32(0)), DomSource/C);
				attribute<bool>   test_int       (DomDomain) := att_int == DomSource/argmaxIntABC;
				attribute<uint32> att_float      (DomDomain) := argmax(MakeDefined(DomSource/D, float32(0.0)), DomSource/EE, MakeDefined(DomSource/F, float32(0.0)));
				attribute<bool>   test_float     (DomDomain) := att_float == DomSource/argmaxFloatDEF;
				attribute<uint32> att_with_null  (DomDomain) := argmax(DomSource/A_null, DomSource/B_null, DomSource/C_null);
				attribute<uint32> attA_with_null (DomDomain) := argmax(DomSource/A_null, const(Int32(0 / 0), DomDomain));
				attribute<bool>   test_with_null (DomDomain) := att_with_null == DomSource/argmaxNull;

				attribute<bool>   test           (DomDomain) := test_int && test_float && test_with_null;

				attribute<uint32> att_all_defined       (DomDomain) := argmax(0     , const( 0,DomDomain));
				attribute<bool>   test_all_defined      (DomDomain) := att_all_defined == 0;

				attribute<uint32> att_first_undefined   (DomDomain) := argmax(0 / 0 , const( 0,DomDomain));
				attribute<bool>   test_first_undefined  (DomDomain) := att_first_undefined == 1;

				attribute<uint32> att_second_undefined  (DomDomain) := argmax(0     , const( 0 / 0,DomDomain));
				attribute<bool>   test_second_undefined (DomDomain) := att_second_undefined == 0;

				attribute<uint32> att_both_undefined    (DomDomain) := argmax(0 / 0 , const( 0 / 0,DomDomain));
				attribute<bool>   test_both_undefined   (DomDomain) := att_both_undefined == 0;

				parameter<bool>   test_attr := all(test) && all(test_all_defined) && all(test_first_undefined) && all(test_second_undefined) && all(test_both_undefined);
			}
			container argmax_uint16
			{
				parameter<bool>   test_param                 := argmax_uint16(DomSource/paramA, DomSource/paramB, DomSource/paramC) == 2w;
				attribute<uint16> att_int        (DomDomain) := argmax_uint16(DomSource/A, MakeDefined(DomSource/B, 0i), DomSource/C);
				attribute<bool>   test_int       (DomDomain) := att_int == uint16(DomSource/argmaxIntABC);
				attribute<uint16> att_float      (DomDomain) := argmax_uint16(MakeDefined(DomSource/D, float32(0.0)), DomSource/EE, MakeDefined(DomSource/F, float32(0.0)));
				attribute<bool>   test_float     (DomDomain) := att_float == uint16(DomSource/argmaxFloatDEF);
				attribute<uint16> att_with_null  (DomDomain) := argmax_uint16(DomSource/A_null, DomSource/B_null, DomSource/C_null);
				attribute<uint16> attA_with_null (DomDomain) := argmax_uint16(DomSource/A_null, const(Int32(0 / 0), DomDomain));
				attribute<bool>   test_with_null (DomDomain) := att_with_null == uint16(DomSource/argmaxNull);

				attribute<bool>   test           (DomDomain) := test_int && test_float && test_with_null;

				attribute<uint16> att_all_defined       (DomDomain) := argmax_uint16(0     , const( 0,DomDomain));
				attribute<bool>   test_all_defined      (DomDomain) := att_all_defined == 0w;

				attribute<uint16> att_first_undefined   (DomDomain) := argmax_uint16(0 / 0 , const( 0,DomDomain));
				attribute<bool>   test_first_undefined  (DomDomain) := att_first_undefined == 1w;

				attribute<uint16> att_second_undefined  (DomDomain) := argmax_uint16(0     , const( 0 / 0,DomDomain));
				attribute<bool>   test_second_undefined (DomDomain) := att_second_undefined == 0w;

				attribute<uint16> att_both_undefined    (DomDomain) := argmax_uint16(0 / 0 , const( 0 / 0,DomDomain));
				attribute<bool>   test_both_undefined   (DomDomain) := att_both_undefined == 0w;

				parameter<bool>   test_attr := all(test) && all(test_all_defined) && all(test_first_undefined) && all(test_second_undefined) && all(test_both_undefined);
			}
			container argmax_uint8
			{
				parameter<bool>   test_param                 := argmax_uint8(DomSource/paramA, DomSource/paramB, DomSource/paramC) == 2b;
				attribute<uint8>  att_int        (DomDomain) := argmax_uint8(DomSource/A, MakeDefined(DomSource/B, 0i), DomSource/C);
				attribute<bool>   test_int       (DomDomain) := att_int == uint8(DomSource/argmaxIntABC);
				attribute<uint8>  att_float      (DomDomain) := argmax_uint8(MakeDefined(DomSource/D, float32(0.0)), DomSource/EE, MakeDefined(DomSource/F, float32(0.0)));
				attribute<bool>   test_float     (DomDomain) := att_float == uint8(DomSource/argmaxFloatDEF);
				attribute<uint8>  att_with_null  (DomDomain) := argmax_uint8(DomSource/A_null, DomSource/B_null, DomSource/C_null);
				attribute<uint8>  attA_with_null (DomDomain) := argmax_uint8(DomSource/A_null, const(Int32(0 / 0), DomDomain));
				attribute<bool>   test_with_null (DomDomain) := att_with_null == uint8(DomSource/argmaxNull);

				attribute<bool>   test           (DomDomain) := test_int && test_float && test_with_null;

				attribute<uint8>  att_all_defined       (DomDomain) := argmax_uint8(0     , const( 0,DomDomain));
				attribute<bool>   test_all_defined      (DomDomain) := att_all_defined == 0b;

				attribute<uint8>  att_first_undefined   (DomDomain) := argmax_uint8(0 / 0 , const( 0,DomDomain));
				attribute<bool>   test_first_undefined  (DomDomain) := att_first_undefined == 1b;

				attribute<uint8>  att_second_undefined  (DomDomain) := argmax_uint8(0     , const( 0 / 0,DomDomain));
				attribute<bool>   test_second_undefined (DomDomain) := att_second_undefined == 0b;

				attribute<uint8>  att_both_undefined    (DomDomain) := argmax_uint8(0 / 0 , const( 0 / 0,DomDomain));
				attribute<bool>   test_both_undefined   (DomDomain) := att_both_undefined == 0b;

				parameter<bool>   test_attr := all(test) && all(test_all_defined) && all(test_first_undefined) && all(test_second_undefined) && all(test_both_undefined);
			}
			container certain_argmax
			{
				parameter<bool>   test_param                 := certain_argmax(DomSource/paramA, DomSource/paramB, DomSource/paramC) == 2;
				attribute<uint32> att_int        (DomDomain) := certain_argmax(DomSource/A, MakeDefined(DomSource/B, int32(0)), DomSource/C);
				attribute<bool>   test_int       (DomDomain) := att_int == DomSource/argmaxIntABC;
				attribute<uint32> att_float      (DomDomain) := certain_argmax(MakeDefined(DomSource/D, float32(0.0)), DomSource/EE, MakeDefined(DomSource/F, float32(0.0)));
				attribute<bool>   test_float     (DomDomain) := att_float == DomSource/argmaxFloatDEF;
				attribute<uint32> att_with_null  (DomDomain) := certain_argmax(DomSource/A_null, DomSource/B_null, DomSource/C_null);
				attribute<uint32> attA_with_null (DomDomain) := certain_argmax(DomSource/A_null, const(Int32(0 / 0), DomDomain));
				attribute<bool>   test_with_null (DomDomain) := eq_or_both_null(att_with_null, DomSource/certain_argmaxNull);

				attribute<bool>   test           (DomDomain) := test_int && test_float && test_with_null;

				attribute<uint32> att_all_defined       (DomDomain) := certain_argmax(0     , const( 0,DomDomain));
				attribute<bool>   test_all_defined      (DomDomain) := att_all_defined == 0;

				attribute<uint32> att_first_undefined   (DomDomain) := certain_argmax(0 / 0 , const( 0,DomDomain));
				attribute<bool>   test_first_undefined  (DomDomain) := isNull(att_first_undefined);

				attribute<uint32> att_second_undefined  (DomDomain) := certain_argmax(0     , const( 0 / 0,DomDomain));
				attribute<bool>   test_second_undefined (DomDomain) := isNull(att_second_undefined);

				attribute<uint32> att_both_undefined    (DomDomain) := certain_argmax(0 / 0 , const( 0 / 0,DomDomain));
				attribute<bool>   test_both_undefined   (DomDomain) := isNull(att_both_undefined);

				parameter<bool>   test_attr := all(test) && all(test_all_defined) && all(test_first_undefined) && all(test_second_undefined) && all(test_both_undefined);
			}
			container certain_argmax_uint16
			{
				parameter<bool>   test_param                 := certain_argmax_uint16(DomSource/paramA, DomSource/paramB, DomSource/paramC) == 2w;
				attribute<uint16> att_int        (DomDomain) := certain_argmax_uint16(DomSource/A, MakeDefined(DomSource/B, int32(0)), DomSource/C);
				attribute<bool>   test_int       (DomDomain) := att_int == uint16(DomSource/argmaxIntABC);
				attribute<uint16> att_float      (DomDomain) := certain_argmax_uint16(MakeDefined(DomSource/D, float32(0.0)), DomSource/EE, MakeDefined(DomSource/F, float32(0.0)));
				attribute<bool>   test_float     (DomDomain) := att_float == uint16(DomSource/argmaxFloatDEF);
				attribute<uint16> att_with_null  (DomDomain) := certain_argmax_uint16(DomSource/A_null, DomSource/B_null, DomSource/C_null);
				attribute<uint16> attA_with_null (DomDomain) := certain_argmax_uint16(DomSource/A_null, const(Int32(0 / 0), DomDomain));
				attribute<bool>   test_with_null (DomDomain) := eq_or_both_null(att_with_null, uint16(DomSource/certain_argmaxNull));

				attribute<bool>   test           (DomDomain) := test_int && test_float && test_with_null;

				attribute<uint16> att_all_defined       (DomDomain) := certain_argmax_uint16(0     , const( 0,DomDomain));
				attribute<bool>   test_all_defined      (DomDomain) := att_all_defined == 0w;

				attribute<uint16> att_first_undefined   (DomDomain) := certain_argmax_uint16(0 / 0 , const( 0,DomDomain));
				attribute<bool>   test_first_undefined  (DomDomain) := isNull(att_first_undefined);

				attribute<uint16> att_second_undefined  (DomDomain) := certain_argmax_uint16(0     , const( 0 / 0,DomDomain));
				attribute<bool>   test_second_undefined (DomDomain) := isNull(att_second_undefined);

				attribute<uint16> att_both_undefined    (DomDomain) := certain_argmax_uint16(0 / 0 , const( 0 / 0,DomDomain));
				attribute<bool>   test_both_undefined   (DomDomain) := isNull(att_both_undefined);

				parameter<bool>   test_attr := all(test) && all(test_all_defined) && all(test_first_undefined) && all(test_second_undefined) && all(test_both_undefined);
			}
			container certain_argmax_uint8
			{
				parameter<bool>   test_param                 := certain_argmax_uint8(DomSource/paramA, DomSource/paramB, DomSource/paramC) == 2b;
				attribute<uint8>  att_int        (DomDomain) := certain_argmax_uint8(DomSource/A, MakeDefined(DomSource/B, int32(0)), DomSource/C);
				attribute<bool>   test_int       (DomDomain) := att_int == uint8(DomSource/argmaxIntABC);
				attribute<uint8>  att_float      (DomDomain) := certain_argmax_uint8(MakeDefined(DomSource/D, float32(0.0)), DomSource/EE, MakeDefined(DomSource/F, float32(0.0)));
				attribute<bool>   test_float     (DomDomain) := att_float == uint8(DomSource/argmaxFloatDEF);
				attribute<uint8>  att_with_null  (DomDomain) := certain_argmax_uint8(DomSource/A_null, DomSource/B_null, DomSource/C_null);
				attribute<uint8>  attA_with_null (DomDomain) := certain_argmax_uint8(DomSource/A_null, const(Int32(0 / 0), DomDomain));
				attribute<bool>   test_with_null (DomDomain) := eq_or_both_null(att_with_null, uint8(DomSource/certain_argmaxNull));

				attribute<bool>   test           (DomDomain) := test_int && test_float && test_with_null;

				attribute<uint8>  att_all_defined       (DomDomain) := certain_argmax_uint8(0     , const( 0,DomDomain));
				attribute<bool>   test_all_defined      (DomDomain) := att_all_defined == 0b;

				attribute<uint8>  att_first_undefined   (DomDomain) := certain_argmax_uint8(0 / 0 , const( 0,DomDomain));
				attribute<bool>   test_first_undefined  (DomDomain) := isNull(att_first_undefined);

				attribute<uint8>  att_second_undefined  (DomDomain) := certain_argmax_uint8(0     , const( 0 / 0,DomDomain));
				attribute<bool>   test_second_undefined (DomDomain) := isNull(att_second_undefined);

				attribute<uint8>  att_both_undefined    (DomDomain) := certain_argmax_uint8(0 / 0 , const( 0 / 0,DomDomain));
				attribute<bool>   test_both_undefined   (DomDomain) := isNull(att_both_undefined);

				parameter<bool>   test_attr := all(test) && all(test_all_defined) && all(test_first_undefined) && all(test_second_undefined) && all(test_both_undefined);
			}
			container known_argmax
			{
				parameter<bool>   test_param                 := known_argmax(DomSource/paramA, DomSource/paramB, DomSource/paramC) == 2;
				attribute<uint32> att_int        (DomDomain) := known_argmax(DomSource/A, MakeDefined(DomSource/B, int32(0)), DomSource/C);
				attribute<bool>   test_int       (DomDomain) := att_int == DomSource/argmaxIntABC;
				attribute<uint32> att_float      (DomDomain) := known_argmax(MakeDefined(DomSource/D, float32(0.0)), DomSource/EE, MakeDefined(DomSource/F, float32(0.0)));
				attribute<bool>   test_float     (DomDomain) := att_float == DomSource/argmaxFloatDEF;
				attribute<uint32> att_with_null  (DomDomain) := known_argmax(DomSource/A_null, DomSource/B_null, DomSource/C_null);
				attribute<uint32> attA_with_null (DomDomain) := known_argmax(DomSource/A_null, const(Int32(0 / 0), DomDomain));
				attribute<bool>   test_with_null (DomDomain) := eq_or_both_null(att_with_null, DomSource/known_argmaxNull);

				attribute<bool>   test           (DomDomain) := test_int && test_float && test_with_null;

				attribute<uint32> att_all_defined       (DomDomain) := known_argmax(0     , const( 0,DomDomain));
				attribute<bool>   test_all_defined      (DomDomain) := att_all_defined == 0;

				attribute<uint32> att_first_undefined   (DomDomain) := known_argmax(0 / 0 , const( 0,DomDomain));
				attribute<bool>   test_first_undefined  (DomDomain) := att_first_undefined == 1;

				attribute<uint32> att_second_undefined  (DomDomain) := known_argmax(0     , const( 0 / 0,DomDomain));
				attribute<bool>   test_second_undefined (DomDomain) := att_second_undefined == 0;

				attribute<uint32> att_both_undefined    (DomDomain) := known_argmax(0 / 0 , const( 0 / 0,DomDomain));
				attribute<bool>   test_both_undefined   (DomDomain) := isNull(att_both_undefined);

				parameter<bool>   test_attr := all(test) && all(test_all_defined) && all(test_first_undefined) && all(test_second_undefined) && all(test_both_undefined);
			}
			container known_argmax_uint16
			{
				parameter<bool>   test_param                 := known_argmax_uint16(DomSource/paramA, DomSource/paramB, DomSource/paramC) == 2w;
				attribute<uint16> att_int        (DomDomain) := known_argmax_uint16(DomSource/A, MakeDefined(DomSource/B, int32(0)), DomSource/C);
				attribute<bool>   test_int       (DomDomain) := att_int == uint16(DomSource/argmaxIntABC);
				attribute<uint16> att_float      (DomDomain) := known_argmax_uint16(MakeDefined(DomSource/D, float32(0.0)), DomSource/EE, MakeDefined(DomSource/F, float32(0.0)));
				attribute<bool>   test_float     (DomDomain) := att_float == uint16(DomSource/argmaxFloatDEF);
				attribute<uint16> att_with_null  (DomDomain) := known_argmax_uint16(DomSource/A_null, DomSource/B_null, DomSource/C_null);
				attribute<uint16> attA_with_null (DomDomain) := known_argmax_uint16(DomSource/A_null, const(Int32(0 / 0), DomDomain));
				attribute<bool>   test_with_null (DomDomain) := eq_or_both_null(att_with_null, uint16(DomSource/known_argmaxNull));

				attribute<bool>   test           (DomDomain) := test_int && test_float && test_with_null;

				attribute<uint16> att_all_defined       (DomDomain) := known_argmax_uint16(0     , const( 0,DomDomain));
				attribute<bool>   test_all_defined      (DomDomain) := att_all_defined == 0w;

				attribute<uint16> att_first_undefined   (DomDomain) := known_argmax_uint16(0 / 0 , const( 0,DomDomain));
				attribute<bool>   test_first_undefined  (DomDomain) := att_first_undefined == 1w;

				attribute<uint16> att_second_undefined  (DomDomain) := known_argmax_uint16(0     , const( 0 / 0,DomDomain));
				attribute<bool>   test_second_undefined (DomDomain) := att_second_undefined == 0w;

				attribute<uint16> att_both_undefined    (DomDomain) := known_argmax_uint16(0 / 0 , const( 0 / 0,DomDomain));
				attribute<bool>   test_both_undefined   (DomDomain) := isNull(att_both_undefined);

				parameter<bool>   test_attr := all(test) && all(test_all_defined) && all(test_first_undefined) && all(test_second_undefined) && all(test_both_undefined);
			}
			container known_argmax_uint8
			{
				parameter<bool>   test_param                 := known_argmax_uint8(DomSource/paramA, DomSource/paramB, DomSource/paramC) == 2b;
				attribute<uint8>  att_int        (DomDomain) := known_argmax_uint8(DomSource/A, MakeDefined(DomSource/B, int32(0)), DomSource/C);
				attribute<bool>   test_int       (DomDomain) := att_int == uint8(DomSource/argmaxIntABC);
				attribute<uint8>  att_float      (DomDomain) := known_argmax_uint8(MakeDefined(DomSource/D, float32(0.0)), DomSource/EE, MakeDefined(DomSource/F, float32(0.0)));
				attribute<bool>   test_float     (DomDomain) := att_float == uint8(DomSource/argmaxFloatDEF);
				attribute<uint8>  att_with_null  (DomDomain) := known_argmax_uint8(DomSource/A_null, DomSource/B_null, DomSource/C_null);
				attribute<uint8>  attA_with_null (DomDomain) := known_argmax_uint8(DomSource/A_null, const(Int32(0 / 0), DomDomain));
				attribute<bool>   test_with_null (DomDomain) := eq_or_both_null(att_with_null, uint8(DomSource/known_argmaxNull));

				attribute<bool>   test           (DomDomain) := test_int && test_float && test_with_null;

				attribute<uint8>  att_all_defined       (DomDomain) := known_argmax_uint8(0     , const( 0,DomDomain));
				attribute<bool>   test_all_defined      (DomDomain) := att_all_defined == 0b;

				attribute<uint8>  att_first_undefined   (DomDomain) := known_argmax_uint8(0 / 0 , const( 0,DomDomain));
				attribute<bool>   test_first_undefined  (DomDomain) := att_first_undefined == 1b;

				attribute<uint8>  att_second_undefined  (DomDomain) := known_argmax_uint8(0     , const( 0 / 0,DomDomain));
				attribute<bool>   test_second_undefined (DomDomain) := att_second_undefined == 0b;

				attribute<uint8>  att_both_undefined    (DomDomain) := known_argmax_uint8(0 / 0 , const( 0 / 0,DomDomain));
				attribute<bool>   test_both_undefined   (DomDomain) := isNull(att_both_undefined);

				parameter<bool>   test_attr := all(test) && all(test_all_defined) && all(test_first_undefined) && all(test_second_undefined) && all(test_both_undefined);
			}
			container argmin
			{
				parameter<bool>   test_param                 := argmin(DomSource/paramA, DomSource/paramB, DomSource/paramC) == 1;
				attribute<uint32> att_int        (DomDomain) := argmin(DomSource/A, MakeDefined(DomSource/B, int32(0)), DomSource/C);
				attribute<bool>   test_int       (DomDomain) := att_int == DomSource/argminIntABC;
				attribute<uint32> att_float      (DomDomain) := argmin(MakeDefined(DomSource/D, float32(0.0)), DomSource/EE, MakeDefined(DomSource/F, float32(0.0)));
				attribute<bool>   test_float     (DomDomain) := att_float == DomSource/argminFloatDEF;
				attribute<uint32> att_with_null  (DomDomain) := argmin(DomSource/A_null, DomSource/B_null, DomSource/C_null);
				attribute<bool>   test_with_null (DomDomain) := att_with_null == DomSource/argminNull;

				attribute<bool>   test           (DomDomain) := test_int && test_float && test_with_null;

				attribute<uint32> att_all_defined       (DomDomain) := argmin(0     , const( 0,DomDomain));
				attribute<bool>   test_all_defined      (DomDomain) := att_all_defined == 0;

				attribute<uint32> att_first_undefined   (DomDomain) := argmin(0 / 0 , const( 0,DomDomain));
				attribute<bool>   test_first_undefined  (DomDomain) := att_first_undefined == 1;

				attribute<uint32> att_second_undefined  (DomDomain) := argmin(0     , const( 0 / 0,DomDomain));
				attribute<bool>   test_second_undefined (DomDomain) := att_second_undefined == 0;

				attribute<uint32> att_both_undefined    (DomDomain) := argmin(0 / 0 , const( 0 / 0,DomDomain));
				attribute<bool>   test_both_undefined   (DomDomain) := att_both_undefined == 0;

				parameter<bool>    test_attr:= all(test) && all(test_all_defined) && all(test_first_undefined) && all(test_second_undefined) && all(test_both_undefined);
			}
			container argmin_uint16
			{
				parameter<bool>   test_param                 := argmin_uint16(DomSource/paramA, DomSource/paramB, DomSource/paramC) == 1w;
				attribute<uint16> att_int        (DomDomain) := argmin_uint16(DomSource/A, MakeDefined(DomSource/B, 0i), DomSource/C);
				attribute<bool>   test_int       (DomDomain) := att_int == uint16(DomSource/argminIntABC);
				attribute<uint16> att_float      (DomDomain) := argmin_uint16(MakeDefined(DomSource/D, float32(0.0)), DomSource/EE, MakeDefined(DomSource/F, float32(0.0)));
				attribute<bool>   test_float     (DomDomain) := att_float == uint16(DomSource/argminFloatDEF);
				attribute<uint16> att_with_null  (DomDomain) := argmin_uint16(DomSource/A_null, DomSource/B_null, DomSource/C_null);
				attribute<bool>   test_with_null (DomDomain) := att_with_null == uint16(DomSource/argminNull);

				attribute<bool>   test           (DomDomain) := test_int && test_float && test_with_null;

				attribute<uint16> att_all_defined       (DomDomain) := argmin_uint16(0     , const( 0,DomDomain));
				attribute<bool>   test_all_defined      (DomDomain) := att_all_defined == 0w;

				attribute<uint16> att_first_undefined   (DomDomain) := argmin_uint16(0 / 0 , const( 0,DomDomain));
				attribute<bool>   test_first_undefined  (DomDomain) := att_first_undefined == 1w;

				attribute<uint16> att_second_undefined  (DomDomain) := argmin_uint16(0     , const( 0 / 0,DomDomain));
				attribute<bool>   test_second_undefined (DomDomain) := att_second_undefined == 0w;

				attribute<uint16> att_both_undefined    (DomDomain) := argmin_uint16(0 / 0 , const( 0 / 0,DomDomain));
				attribute<bool>   test_both_undefined   (DomDomain) := att_both_undefined == 0w;

				parameter<bool>    test_attr := all(test) && all(test_all_defined) && all(test_first_undefined) && all(test_second_undefined) && all(test_both_undefined);
			}
			container argmin_uint8
			{
				parameter<bool>  test_param                 := argmin_uint8(DomSource/paramA, DomSource/paramB, DomSource/paramC) == 1b;
				attribute<uint8> att_int        (DomDomain) := argmin_uint8(DomSource/A, MakeDefined(DomSource/B, 0i), DomSource/C);
				attribute<bool>  test_int       (DomDomain) := att_int == uint8(DomSource/argminIntABC);
				attribute<uint8> att_float      (DomDomain) := argmin_uint8(MakeDefined(DomSource/D, float32(0.0)), DomSource/EE, MakeDefined(DomSource/F, float32(0.0)));
				attribute<bool>  test_float     (DomDomain) := att_float == uint8(DomSource/argminFloatDEF);
				attribute<uint8> att_with_null  (DomDomain) := argmin_uint8(DomSource/A_null, DomSource/B_null, DomSource/C_null);
				attribute<bool>  test_with_null (DomDomain) := att_with_null == uint8(DomSource/argminNull);

				attribute<bool>  test           (DomDomain) := test_int && test_float && test_with_null;

				attribute<uint8> att_all_defined       (DomDomain) := argmin_uint8(0     , const( 0,DomDomain));
				attribute<bool>  test_all_defined      (DomDomain) := att_all_defined == 0b;

				attribute<uint8> att_first_undefined   (DomDomain) := argmin_uint8(0 / 0 , const( 0,DomDomain));
				attribute<bool>  test_first_undefined  (DomDomain) := att_first_undefined == 1b;

				attribute<uint8> att_second_undefined  (DomDomain) := argmin_uint8(0     , const( 0 / 0,DomDomain));
				attribute<bool>  test_second_undefined (DomDomain) := att_second_undefined == 0b;

				attribute<uint8> att_both_undefined    (DomDomain) := argmin_uint8(0 / 0 , const( 0 / 0,DomDomain));
				attribute<bool>  test_both_undefined   (DomDomain) := att_both_undefined == 0b;

				parameter<bool>  test_attr := all(test) && all(test_all_defined) && all(test_first_undefined) && all(test_second_undefined) && all(test_both_undefined);
			}
			container certain_argmin
			{
				parameter<bool>   test_param                 := certain_argmin(DomSource/paramA, DomSource/paramB, DomSource/paramC) == 1;
				attribute<uint32> att_int        (DomDomain) := certain_argmin(DomSource/A, MakeDefined(DomSource/B, int32(0)), DomSource/C);
				attribute<bool>   test_int       (DomDomain) := att_int == DomSource/argminIntABC;
				attribute<uint32> att_float      (DomDomain) := certain_argmin(MakeDefined(DomSource/D, float32(0.0)), DomSource/EE, MakeDefined(DomSource/F, float32(0.0)));
				attribute<bool>   test_float     (DomDomain) := att_float == DomSource/argminFloatDEF;
				attribute<uint32> att_with_null  (DomDomain) := certain_argmin(DomSource/A_null, DomSource/B_null, DomSource/C_null);
				attribute<bool>   test_with_null (DomDomain) := eq_or_both_null(att_with_null, DomSource/certain_argminNull);

				attribute<bool>   test           (DomDomain) := test_int && test_float && test_with_null;

				attribute<uint32> att_all_defined       (DomDomain) := certain_argmin(0     , const( 0,DomDomain));
				attribute<bool>   test_all_defined      (DomDomain) := att_all_defined == 0;

				attribute<uint32> att_first_undefined   (DomDomain) := certain_argmin(0 / 0 , const( 0,DomDomain));
				attribute<bool>   test_first_undefined  (DomDomain) := isNull(att_first_undefined);

				attribute<uint32> att_second_undefined  (DomDomain) := certain_argmin(0     , const( 0 / 0,DomDomain));
				attribute<bool>   test_second_undefined (DomDomain) := isNull(att_second_undefined);

				attribute<uint32> att_both_undefined    (DomDomain) := certain_argmin(0 / 0 , const( 0 / 0,DomDomain));
				attribute<bool>   test_both_undefined   (DomDomain) := isNull(att_both_undefined);

				parameter<bool>   test_attr := all(test) && all(test_all_defined) && all(test_first_undefined) && all(test_second_undefined) && all(test_both_undefined);
			}
			container certain_argmin_uint16
			{
				parameter<bool>   test_param                 := certain_argmin_uint16(DomSource/paramA, DomSource/paramB, DomSource/paramC) = 1w;
				attribute<uint16> att_int        (DomDomain) := certain_argmin_uint16(DomSource/A, MakeDefined(DomSource/B, int32(0)), DomSource/C);
				attribute<bool>   test_int       (DomDomain) := att_int == uint16(DomSource/argminIntABC);
				attribute<uint16> att_float      (DomDomain) := certain_argmin_uint16(MakeDefined(DomSource/D, float32(0.0)), DomSource/EE, MakeDefined(DomSource/F, float32(0.0)));
				attribute<bool>   test_float     (DomDomain) := att_float == uint16(DomSource/argminFloatDEF);
				attribute<uint16> att_with_null  (DomDomain) := certain_argmin_uint16(DomSource/A_null, DomSource/B_null, DomSource/C_null);
				attribute<bool>   test_with_null (DomDomain) := eq_or_both_null(att_with_null, uint16(DomSource/certain_argminNull));

				attribute<bool>   test           (DomDomain) := test_int && test_float && test_with_null;

				attribute<uint16> att_all_defined       (DomDomain) := certain_argmin_uint16(0     , const( 0,DomDomain));
				attribute<bool>   test_all_defined      (DomDomain) := att_all_defined == 0w;

				attribute<uint16> att_first_undefined   (DomDomain) := certain_argmin_uint16(0 / 0 , const( 0,DomDomain));
				attribute<bool>   test_first_undefined  (DomDomain) := isNull(att_first_undefined);

				attribute<uint16> att_second_undefined  (DomDomain) := certain_argmin_uint16(0     , const( 0 / 0,DomDomain));
				attribute<bool>   test_second_undefined (DomDomain) := isNull(att_second_undefined);

				attribute<uint16> att_both_undefined    (DomDomain) := certain_argmin_uint16(0 / 0 , const( 0 / 0,DomDomain));
				attribute<bool>   test_both_undefined   (DomDomain) := isNull(att_both_undefined);

				parameter<bool>   test_attr := all(test) && all(test_all_defined) && all(test_first_undefined) && all(test_second_undefined) && all(test_both_undefined);
			}
			container certain_argmin_uint8
			{
				parameter<bool>   test_param                 := certain_argmin_uint8(DomSource/paramA, DomSource/paramB, DomSource/paramC) == 1b;
				attribute<uint8>  att_int        (DomDomain) := certain_argmin_uint8(DomSource/A, MakeDefined(DomSource/B, int32(0)), DomSource/C);
				attribute<bool>   test_int       (DomDomain) := att_int == uint8(DomSource/argminIntABC);
				attribute<uint8>  att_float      (DomDomain) := certain_argmin_uint8(MakeDefined(DomSource/D, float32(0.0)), DomSource/EE, MakeDefined(DomSource/F, float32(0.0)));
				attribute<bool>   test_float     (DomDomain) := att_float == uint8(DomSource/argminFloatDEF);
				attribute<uint8>  att_with_null  (DomDomain) := certain_argmin_uint8(DomSource/A_null, DomSource/B_null, DomSource/C_null);
				attribute<bool>   test_with_null (DomDomain) := eq_or_both_null(att_with_null, uint8(DomSource/certain_argminNull));

				attribute<bool>   test           (DomDomain) := test_int && test_float && test_with_null;

				attribute<uint8>  att_all_defined       (DomDomain) := certain_argmin_uint8(0     , const( 0,DomDomain));
				attribute<bool>   test_all_defined      (DomDomain) := att_all_defined == 0b;

				attribute<uint8>  att_first_undefined   (DomDomain) := certain_argmin_uint8(0 / 0 , const( 0,DomDomain));
				attribute<bool>   test_first_undefined  (DomDomain) := isNull(att_first_undefined);

				attribute<uint8>  att_second_undefined  (DomDomain) := certain_argmin_uint8(0     , const( 0 / 0,DomDomain));
				attribute<bool>   test_second_undefined (DomDomain) := isNull(att_second_undefined);

				attribute<uint8>  att_both_undefined    (DomDomain) := certain_argmin_uint8(0 / 0 , const( 0 / 0,DomDomain));
				attribute<bool>   test_both_undefined   (DomDomain) := isNull(att_both_undefined);

				parameter<bool>   test_attr := all(test) && all(test_all_defined) && all(test_first_undefined) && all(test_second_undefined) && all(test_both_undefined);
			}
			container known_argmin
			{
				parameter<bool>   test_param                 := known_argmin(DomSource/paramA, DomSource/paramB, DomSource/paramC) == 1;
				attribute<uint32> att_int        (DomDomain) := known_argmin(DomSource/A, MakeDefined(DomSource/B, int32(0)), DomSource/C);
				attribute<bool>   test_int       (DomDomain) := att_int == DomSource/argminIntABC;
				attribute<uint32> att_float      (DomDomain) := known_argmin(MakeDefined(DomSource/D, float32(0.0)), DomSource/EE, MakeDefined(DomSource/F, float32(0.0)));
				attribute<bool>   test_float     (DomDomain) := att_float == DomSource/argminFloatDEF;
				attribute<uint32> att_with_null  (DomDomain) := known_argmin(DomSource/A_null, DomSource/B_null, DomSource/C_null);
				attribute<bool>   test_with_null (DomDomain) := eq_or_both_null(att_with_null, DomSource/known_argminNull);

				attribute<bool>   test           (DomDomain) := test_int && test_float && test_with_null;

				attribute<uint32> att_all_defined       (DomDomain) := known_argmin(0     , const( 0,DomDomain));
				attribute<bool>   test_all_defined      (DomDomain) := att_all_defined == 0;

				attribute<uint32> att_first_undefined   (DomDomain) := known_argmin(0 / 0 , const( 0,DomDomain));
				attribute<bool>   test_first_undefined  (DomDomain) := att_first_undefined == 1;

				attribute<uint32> att_second_undefined  (DomDomain) := known_argmin(0     , const( 0 / 0,DomDomain));
				attribute<bool>   test_second_undefined (DomDomain) := att_second_undefined == 0;

				attribute<uint32> att_both_undefined    (DomDomain) := known_argmin(0 / 0 , const( 0 / 0,DomDomain));
				attribute<bool>   test_both_undefined   (DomDomain) := isNull(att_both_undefined);

				parameter<bool>   test_attr := all(test) && all(test_all_defined) && all(test_first_undefined) && all(test_second_undefined) && all(test_both_undefined);
			}
			container known_argmin_uint16
			{
				parameter<bool>   test_param                 := known_argmin_uint16(DomSource/paramA, DomSource/paramB, DomSource/paramC) == 1w;
				attribute<uint16> att_int        (DomDomain) := known_argmin_uint16(DomSource/A, MakeDefined(DomSource/B, int32(0)), DomSource/C);
				attribute<bool>   test_int       (DomDomain) := att_int == uint16(DomSource/argminIntABC);
				attribute<uint16> att_float      (DomDomain) := known_argmin_uint16(MakeDefined(DomSource/D, float32(0.0)), DomSource/EE, MakeDefined(DomSource/F, float32(0.0)));
				attribute<bool>   test_float     (DomDomain) := att_float == uint16(DomSource/argminFloatDEF);
				attribute<uint16> att_with_null  (DomDomain) := known_argmin_uint16(DomSource/A_null, DomSource/B_null, DomSource/C_null);
				attribute<bool>   test_with_null (DomDomain) := eq_or_both_null(att_with_null, uint16(DomSource/known_argminNull));

				attribute<bool>   test           (DomDomain) := test_int && test_float && test_with_null;

				attribute<uint16> att_all_defined       (DomDomain) := known_argmin_uint16(0     , const( 0,DomDomain));
				attribute<bool>   test_all_defined      (DomDomain) := att_all_defined == 0w;

				attribute<uint16> att_first_undefined   (DomDomain) := known_argmin_uint16(0 / 0 , const( 0,DomDomain));
				attribute<bool>   test_first_undefined  (DomDomain) := att_first_undefined == 1w;

				attribute<uint16> att_second_undefined  (DomDomain) := known_argmin_uint16(0     , const( 0 / 0,DomDomain));
				attribute<bool>   test_second_undefined (DomDomain) := att_second_undefined == 0w;

				attribute<uint16> att_both_undefined    (DomDomain) := known_argmin_uint16(0 / 0 , const( 0 / 0,DomDomain));
				attribute<bool>   test_both_undefined   (DomDomain) := isNull(att_both_undefined);

				parameter<bool>   test_attr := all(test) && all(test_all_defined) && all(test_first_undefined) && all(test_second_undefined) && all(test_both_undefined);
			}
			container known_argmin_uint8
			{
				parameter<bool>   test_param                 := known_argmin_uint8(DomSource/paramA, DomSource/paramB, DomSource/paramC) == 1b;
				attribute<uint8>  att_int        (DomDomain) := known_argmin_uint8(DomSource/A, MakeDefined(DomSource/B, int32(0)), DomSource/C);
				attribute<bool>   test_int       (DomDomain) := att_int == uint8(DomSource/argminIntABC);
				attribute<uint8>  att_float      (DomDomain) := known_argmin_uint8(MakeDefined(DomSource/D, float32(0.0)), DomSource/EE, MakeDefined(DomSource/F, float32(0.0)));
				attribute<bool>   test_float     (DomDomain) := att_float == uint8(DomSource/argminFloatDEF);
				attribute<uint8>  att_with_null  (DomDomain) := known_argmin_uint8(DomSource/A_null, DomSource/B_null, DomSource/C_null);
				attribute<bool>   test_with_null (DomDomain) := eq_or_both_null(att_with_null, uint8(DomSource/known_argminNull));

				attribute<bool>   test           (DomDomain) := test_int && test_float && test_with_null;

				attribute<uint8>  att_all_defined       (DomDomain) := known_argmin_uint8(0     , const( 0,DomDomain));
				attribute<bool>   test_all_defined      (DomDomain) := att_all_defined == 0b;

				attribute<uint8>  att_first_undefined   (DomDomain) := known_argmin_uint8(0 / 0 , const( 0,DomDomain));
				attribute<bool>   test_first_undefined  (DomDomain) := att_first_undefined == 1b;

				attribute<uint8>  att_second_undefined  (DomDomain) := known_argmin_uint8(0     , const( 0 / 0,DomDomain));
				attribute<bool>   test_second_undefined (DomDomain) := att_second_undefined == 0b;

				attribute<uint8>  att_both_undefined    (DomDomain) := known_argmin_uint8(0 / 0 , const( 0 / 0,DomDomain));
				attribute<bool>   test_both_undefined   (DomDomain) := isNull(att_both_undefined);

				parameter<bool>   test_attr := all(test) && all(test_all_defined) && all(test_first_undefined) && all(test_second_undefined) && all(test_both_undefined);
			}
			container max_elem: url = "http://www.objectvision.nl/geodms/operators-a-functions/ordering/max_elem"
			{
				parameter<float64> calc_param                 := max_elem(DomSource/paramA, DomSource/paramB, DomSource/paramC);
				parameter<bool>    test_param                 := calc_param == 1.1;
				attribute<int32>   att_int        (DomDomain) := max_elem(DomSource/A, MakeDefined(DomSource/B, int32(0)), DomSource/C);
				attribute<bool>    test_int       (DomDomain) := att_int == DomSource/max_elemIntABC;
				attribute<float32> att_float      (DomDomain) := max_elem(MakeDefined(DomSource/D, float32(0.0)), DomSource/EE, MakeDefined(DomSource/F, float32(0.0)));
				attribute<bool>    test_float     (DomDomain) := att_float == DomSource/max_elemFloatDEF;

				attribute<int32>   att_with_null  (DomDomain) := max_elem(DomSource/A_null, DomSource/B_null, DomSource/C_null);
				attribute<bool>    test_with_null (DomDomain) := eq_or_both_null(att_with_null, DomSource/max_elemNull);

				attribute<bool>    test           (DomDomain) := test_int && test_float && test_with_null;

				attribute<uint32>  att_all_defined       (DomDomain) := max_elem(0     , const( 0,DomDomain));
				attribute<bool>    test_all_defined      (DomDomain) := att_all_defined == 0;

				attribute<uint32>  att_first_undefined   (DomDomain) := max_elem(0 / 0 , const( 0,DomDomain));
				attribute<bool>    test_first_undefined  (DomDomain) := att_first_undefined == 0;

				attribute<uint32>  att_second_undefined  (DomDomain) := max_elem(0     , const( 0 / 0,DomDomain));
				attribute<bool>    test_second_undefined (DomDomain) := att_second_undefined == 0;

				attribute<uint32>  att_both_undefined    (DomDomain) := max_elem(0 / 0 , const( 0 / 0,DomDomain));
				attribute<bool>    test_both_undefined   (DomDomain) := isNull(att_both_undefined);

				parameter<bool>    test_attr := all(test) && all(test_all_defined) && all(test_first_undefined) && all(test_second_undefined) && all(test_both_undefined);
			}
			container certain_max_elem
			{
				parameter<float64> calc_param                 := certain_max_elem(DomSource/paramA, DomSource/paramB, DomSource/paramC);
				parameter<bool>    test_param                 := calc_param == 1.1;
				attribute<int32>   att_int        (DomDomain) := certain_max_elem(DomSource/A, MakeDefined(DomSource/B, int32(0)), DomSource/C);
				attribute<bool>    test_int       (DomDomain) := att_int == DomSource/max_elemIntABC;
				attribute<float32> att_float      (DomDomain) := certain_max_elem(MakeDefined(DomSource/D, float32(0.0)), DomSource/EE, MakeDefined(DomSource/F, float32(0.0)));
				attribute<bool>    test_float     (DomDomain) := att_float == DomSource/max_elemFloatDEF;
				
				attribute<int32>   att_with_null  (DomDomain) := certain_max_elem(DomSource/A_null, DomSource/B_null, DomSource/C_null);
				attribute<bool>    test_with_null (DomDomain) := eq_or_both_null(att_with_null, DomSource/certain_max_elemNull);

				attribute<bool>    test           (DomDomain) := test_int && test_float && test_with_null;
				attribute<uint32> att_all_defined       (DomDomain) := certain_max_elem(0     , const( 0,DomDomain));
				attribute<bool>   test_all_defined      (DomDomain) := att_all_defined == 0;

				attribute<uint32> att_first_undefined   (DomDomain) := certain_max_elem(0 / 0 , const( 0,DomDomain));
				attribute<bool>   test_first_undefined  (DomDomain) := isNull(att_first_undefined);

				attribute<uint32> att_second_undefined  (DomDomain) := certain_max_elem(0     , const( 0 / 0,DomDomain));
				attribute<bool>   test_second_undefined (DomDomain) := isNull(att_second_undefined);

				attribute<uint32> att_both_undefined    (DomDomain) := certain_max_elem(0 / 0 , const( 0 / 0,DomDomain));
				attribute<bool>   test_both_undefined   (DomDomain) := isNull(att_both_undefined);

				parameter<bool>    test_attr := all(test) && all(test_all_defined) && all(test_first_undefined) && all(test_second_undefined) && all(test_both_undefined);
			}
			container known_max_elem
			{
				parameter<float64> calc_param                 := known_max_elem(DomSource/paramA, DomSource/paramB, DomSource/paramC);
				parameter<bool>    test_param                 := calc_param == 1.1;
				attribute<int32>   att_int        (DomDomain) := known_max_elem(DomSource/A, MakeDefined(DomSource/B, int32(0)), DomSource/C);
				attribute<bool>    test_int       (DomDomain) := att_int == DomSource/max_elemIntABC;
				attribute<float32> att_float      (DomDomain) := known_max_elem(MakeDefined(DomSource/D, float32(0.0)), DomSource/EE, MakeDefined(DomSource/F, float32(0.0)));
				attribute<bool>    test_float     (DomDomain) := att_float == DomSource/max_elemFloatDEF;

				attribute<int32>   att_with_null  (DomDomain) := known_max_elem(DomSource/A_null, DomSource/B_null, DomSource/C_null);
				attribute<bool>    test_with_null (DomDomain) := eq_or_both_null(att_with_null, DomSource/known_max_elemNull);

				attribute<bool>    test           (DomDomain) := test_int && test_float && test_with_null;

				attribute<uint32>  att_all_defined       (DomDomain) := known_max_elem(0     , const( 0,DomDomain));
				attribute<bool>    test_all_defined      (DomDomain) := att_all_defined == 0;

				attribute<uint32>  att_first_undefined   (DomDomain) := known_max_elem(0 / 0 , const( 0,DomDomain));
				attribute<bool>    test_first_undefined  (DomDomain) := att_first_undefined == 0;

				attribute<uint32>  att_second_undefined  (DomDomain) := known_max_elem(0     , const( 0 / 0,DomDomain));
				attribute<bool>    test_second_undefined (DomDomain) := att_second_undefined == 0;

				attribute<uint32>  att_both_undefined    (DomDomain) := known_max_elem(0 / 0 , const( 0 / 0,DomDomain));
				attribute<bool>    test_both_undefined   (DomDomain) := isNull(att_both_undefined);

				parameter<bool>    test_attr := all(test) && all(test_all_defined) && all(test_first_undefined) && all(test_second_undefined) && all(test_both_undefined);
			}
			container min_elem: url = "http://www.objectvision.nl/geodms/operators-a-functions/ordering/min_elem"
			{
				parameter<bool>    test_param                 := min_elem(DomSource/paramA, DomSource/paramB, DomSource/paramC) == -3.9;
				attribute<int32>   att_int        (DomDomain) := min_elem(DomSource/A, MakeDefined(DomSource/B, int32(0)), DomSource/C);
				attribute<bool>    test_int       (DomDomain) := att_int == DomSource/min_elemIntABC;
				attribute<float32> att_float      (DomDomain) := min_elem(MakeDefined(DomSource/D, float32(0.0)), DomSource/EE, MakeDefined(DomSource/F, float32(0.0)));
				attribute<bool>    test_float     (DomDomain) := att_float == DomSource/min_elemFloatDEF;
				
				attribute<int32>   att_with_null  (DomDomain) := min_elem(DomSource/A_null, DomSource/B_null, DomSource/C_null);
				attribute<bool>    test_with_null (DomDomain) := eq_or_both_null(att_with_null, DomSource/min_elemNull);

				attribute<bool>    test           (DomDomain) := test_int && test_float && test_with_null;

				attribute<uint32> att_all_defined       (DomDomain) := min_elem(0     , const( 0,DomDomain));
				attribute<bool>   test_all_defined      (DomDomain) := att_all_defined == 0;

				attribute<uint32> att_first_undefined   (DomDomain) := min_elem(0 / 0 , const( 0,DomDomain));
				attribute<bool>   test_first_undefined  (DomDomain) := att_first_undefined == 0;

				attribute<uint32> att_second_undefined  (DomDomain) := min_elem(0     , const( 0 / 0,DomDomain));
				attribute<bool>   test_second_undefined (DomDomain) := att_second_undefined == 0;

				attribute<uint32> att_both_undefined    (DomDomain) := min_elem(0 / 0 , const( 0 / 0,DomDomain));
				attribute<bool>   test_both_undefined   (DomDomain) := isNull(att_both_undefined);

				parameter<bool>   test_attr := all(test) && all(test_all_defined) && all(test_first_undefined) && all(test_second_undefined) && all(test_both_undefined);
			}

			container certain_min_elem
			{
				parameter<bool>    test_param                 := certain_min_elem(DomSource/paramA, DomSource/paramB, DomSource/paramC) == -3.9;
				attribute<int32>   att_int        (DomDomain) := certain_min_elem(DomSource/A, MakeDefined(DomSource/B, int32(0)), DomSource/C);
				attribute<bool>    test_int       (DomDomain) := att_int == DomSource/min_elemIntABC;
				attribute<float32> att_float      (DomDomain) := certain_min_elem(MakeDefined(DomSource/D, float32(0.0)), DomSource/EE, MakeDefined(DomSource/F, float32(0.0)));
				attribute<bool>    test_float     (DomDomain) := att_float == DomSource/min_elemFloatDEF;
				
				attribute<int32>   att_with_null  (DomDomain) := certain_min_elem(DomSource/A_null, DomSource/B_null, DomSource/C_null);
				attribute<bool>    test_with_null (DomDomain) := eq_or_both_null(att_with_null, DomSource/certain_min_elemNull);

				attribute<bool>    test           (DomDomain) := test_int && test_float && test_with_null;

				attribute<uint32> att_all_defined       (DomDomain) := certain_min_elem(0     , const( 0,DomDomain));
				attribute<bool>   test_all_defined      (DomDomain) := att_all_defined == 0;

				attribute<uint32> att_first_undefined   (DomDomain) := certain_min_elem(0 / 0 , const( 0,DomDomain));
				attribute<bool>   test_first_undefined  (DomDomain) := isNull(att_first_undefined);

				attribute<uint32> att_second_undefined  (DomDomain) := certain_min_elem(0     , const( 0 / 0,DomDomain));
				attribute<bool>   test_second_undefined (DomDomain) := isNull(att_second_undefined);

				attribute<uint32> att_both_undefined    (DomDomain) := certain_min_elem(0 / 0 , const( 0 / 0,DomDomain));
				attribute<bool>   test_both_undefined   (DomDomain) := isNull(att_both_undefined);

				parameter<bool>   test_attr := all(test) && all(test_all_defined) && all(test_first_undefined) && all(test_second_undefined) && all(test_both_undefined);
			}
			container known_min_elem
			{
				parameter<bool>    test_param                 := known_min_elem(DomSource/paramA, DomSource/paramB, DomSource/paramC) == -3.9;
				attribute<int32>   att_int        (DomDomain) := known_min_elem(DomSource/A, MakeDefined(DomSource/B, int32(0)), DomSource/C);
				attribute<bool>    test_int       (DomDomain) := att_int == DomSource/min_elemIntABC;
				attribute<float32> att_float      (DomDomain) := known_min_elem(MakeDefined(DomSource/D, float32(0.0)), DomSource/EE, MakeDefined(DomSource/F, float32(0.0)));
				attribute<bool>    test_float     (DomDomain) := att_float == DomSource/min_elemFloatDEF;
				
				attribute<int32>   att_with_null  (DomDomain) := known_min_elem(DomSource/A_null, DomSource/B_null, DomSource/C_null);
				attribute<bool>    test_with_null (DomDomain) := eq_or_both_null(att_with_null, DomSource/known_min_elemNull);

				attribute<bool>    test           (DomDomain) := test_int && test_float && test_with_null;

				attribute<uint32> att_all_defined       (DomDomain) := known_min_elem(0     , const( 0,DomDomain));
				attribute<bool>   test_all_defined      (DomDomain) := att_all_defined == 0;

				attribute<uint32> att_first_undefined   (DomDomain) := known_min_elem(0 / 0 , const( 0,DomDomain));
				attribute<bool>   test_first_undefined  (DomDomain) := att_first_undefined == 0;

				attribute<uint32> att_second_undefined  (DomDomain) := known_min_elem(0     , const( 0 / 0,DomDomain));
				attribute<bool>   test_second_undefined (DomDomain) := att_second_undefined == 0;

				attribute<uint32> att_both_undefined    (DomDomain) := known_min_elem(0 / 0 , const( 0 / 0,DomDomain));
				attribute<bool>   test_both_undefined   (DomDomain) := isNull(att_both_undefined);

				parameter<bool>   test_attr := all(test) && all(test_all_defined) && all(test_first_undefined) && all(test_second_undefined) && all(test_both_undefined);
			}
			container median
			{
				parameter<bool>    test_param             := median(DomSource/paramA, DomSource/paramB, DomSource/paramA) == 1.0 ;
				attribute<int32>   att_int    (DomDomain) := median(DomSource/A, MakeDefined(DomSource/B, int32(0)), DomSource/C);
				attribute<bool>    test_int   (DomDomain) := att_int = DomSource/medianIntABC;
				attribute<float32> att_float  (DomDomain) := median(MakeDefined(DomSource/D, float32(0.0)), DomSource/EE, MakeDefined(DomSource/F, float32(0.0)));
				attribute<bool>    test_float (DomDomain) := att_float = DomSource/medianFloatDEF;
				attribute<bool>    test       (DomDomain) := test_int && test_float;

				attribute<uint32> att_all_defined       (DomDomain) := median(0,0, const( 0,DomDomain));
				attribute<bool>   test_all_defined      (DomDomain) := att_all_defined == 0;

				attribute<uint32> att_first_undefined   (DomDomain) := median(0 / 0 , 0,  const( 0,DomDomain));
				attribute<bool>   test_first_undefined  (DomDomain) := att_first_undefined == 0;

				attribute<uint32> att_second_undefined  (DomDomain) := median(0     , const( 0 / 0,DomDomain),  const( 0,DomDomain));
				attribute<bool>   test_second_undefined (DomDomain) := att_second_undefined == 0;

				attribute<uint32> att_third_undefined  (DomDomain) := median(0     , const( 0,DomDomain), const( 0 / 0,DomDomain));
				attribute<bool>   test_third_undefined (DomDomain) := att_third_undefined == 0;

				attribute<uint32> att_first_second_undefined  (DomDomain) := median(0 / 0     , const( 0,DomDomain), const( 0 / 0,DomDomain));
				attribute<bool>   test_first_second_undefined (DomDomain) := att_first_second_undefined == 0;

				attribute<uint32> att_all_undefined    (DomDomain) := median(0 / 0 ,0 / 0,  const( 0 / 0,DomDomain));
				attribute<bool>   test_all_undefined   (DomDomain) := isNull(att_all_undefined);

				parameter<bool>    test_attr              := 
					all(test) && all(test_all_defined) && all(test_first_undefined) && all(test_second_undefined) && all(test_third_undefined) && all(test_first_second_undefined) && all(test_all_undefined);

			}
			container sort: url  = "http://www.objectvision.nl/geodms/operators-a-functions/ordering/sort"
			{
				attribute<float32> att (Domain) := sort(Source/A);
				attribute<bool>    test(Domain) := eq_or_both_null(Source/SortA, att);
				parameter<bool>    test_attr    := all(test);
			}
			container reverse: url = "http://www.objectvision.nl/geodms/operators-a-functions/ordering/reverse"
			{
				attribute<float32> att (Domain) := reverse(Source/A);
				unit<uint8> uint8Domain: nrofrows = 10
				{
					attribute<.>    id         := id(.);
					attribute<.>    reverse_id := reverse(id);
					attribute<bool> test       := reverse_id == max(id) - id;
					parameter<bool> test_attr  := all(test);
				}
				attribute<bool>    test(Domain) := eq_or_both_null(Source/RevA, att);
				parameter<bool>    test_attr    := all(test) && uint8Domain/test_attr;
			}
			container float_is_nearby
			{
				attribute<bool> att  (Domain) := float_isNearby(Source/A, Source/B_nearby, 0.99f);
				attribute<bool> test (Domain) := att == Source/flNAB;
				parameter<bool> test_attr     := all(test);
			}
			container results
			{
				parameter<bool> test_params := 
					   eq/test_param 
					&& eq_op/test_param 
					&& eq_or_both_null/test_param 
					&& lt_op/test_param 
					&& lt/test_param 
					&& lt_or_lhs_null/test_param 
					&& le_op/test_param 
					&& le/test_param 
					&& le_or_lhs_null/test_param 
					&& gt_op/test_param 
					&& gt/test_param 
					&& gt_or_rhs_null/test_param 
					&& ge_op/test_param 
					&& ge/test_param 
					&& ge_or_rhs_null/test_param 
					&& ne_op/test_param 
					&& ne/test_param 
					&& ne_or_one_null/test_param
					&& argmax/test_param 
					&& argmax_uint16/test_param
					&& argmax_uint8/test_param
					&& certain_argmax/test_param 
					&& certain_argmax_uint16/test_param
					&& certain_argmax_uint8/test_param
					&& known_argmax/test_param 
					&& known_argmax_uint16/test_param
					&& known_argmax_uint8/test_param
					&& argmin/test_param
					&& argmin_uint16/test_param
					&& argmin_uint8/test_param
					&& certain_argmin/test_param 
					&& certain_argmin_uint16/test_param
					&& certain_argmin_uint8/test_param
					&& known_argmin/test_param 
					&& known_argmin_uint16/test_param
					&& known_argmin_uint8/test_param
					&& max_elem/test_param 
					&& certain_max_elem/test_param 
					&& known_max_elem/test_param 
					&& min_elem/test_param 
					&& certain_min_elem/test_param 
					&& known_min_elem/test_param;
				parameter<bool> test_attrs := 
					   eq/test_attr 
					&& eq_or_both_null/test_attr 
					&& lt_op/test_attr 
					&& lt/test_attr 
					&& lt_or_lhs_null/test_attr 
					&& le_op/test_attr 
					&& le/test_attr 
					&& le_or_lhs_null/test_attr 
					&& gt_op/test_attr 
					&& gt/test_attr 
					&& gt_or_rhs_null/test_attr 
					&& ge_op/test_attr 
					&& ge/test_attr 
					&& ge_or_rhs_null/test_attr 
					&& ne_op/test_attr 
					&& ne/test_attr 
					&& ne_or_one_null/test_attr
					&& argmax/test_attr
					&& argmax_uint16/test_attr
					&& argmax_uint8/test_attr
					&& certain_argmax/test_attr
					&& certain_argmax_uint16/test_attr
					&& certain_argmax_uint8/test_attr
					&& known_argmax/test_attr
					&& known_argmax_uint16/test_attr
					&& known_argmax_uint8/test_attr
					&& argmin/test_attr 
					&& argmin_uint16/test_attr 
					&& argmin_uint8/test_attr
					&& certain_argmin/test_attr 
					&& certain_argmin_uint16/test_attr 
					&& certain_argmin_uint8/test_attr
					&& known_argmin/test_attr
					&& known_argmin_uint16/test_attr
					&& known_argmin_uint8/test_attr
					&& max_elem/test_attr 
					&& certain_max_elem/test_attr 
					&& known_max_elem/test_attr 
					&& min_elem/test_attr
					&& certain_min_elem/test_attr 
					&& known_min_elem/test_attr
					&& median/test_attr
					&& sort/test_attr 
					&& reverse/test_attr
					&& float_is_nearby/test_attr;
				parameter<bool> test_case_sensitive :=
					   eq/test_case_sensitive 
					&& eq_or_both_null/test_case_sensitive 
					&& lt_op/test_case_sensitive 
					&& lt/test_case_sensitive 
					&& lt_or_lhs_null/test_case_sensitive 
					&& le_op/test_case_sensitive 
					&& le/test_case_sensitive 
					&& le_or_lhs_null/test_case_sensitive 
					&& gt_op/test_case_sensitive 
					&& gt/test_case_sensitive 
					&& gt_or_rhs_null/test_case_sensitive 
					&& ge_op/test_case_sensitive 
					&& ge/test_case_sensitive 
					&& ge_or_rhs_null/test_case_sensitive 
					&& ne_or_one_null/test_case_sensitive;
				parameter<bool> tests :=
					   test_params 
					&& test_attrs
					&& test_case_sensitive;
			}
		}
	}
	container Transcendental
	{
		container srcDomain  := source(ADomain);
		container srcEDomain := Esource(EDomain);
		container srcTiledDomain  := source(ATiledDomain);
		container srcETiledDomain := Esource(ETiledDomain);
		
		template source
		{
			// begin case parameters
			unit<uint32> Domain;
			// end case paremeters
			attribute<float32> A    (Domain): [1,2,3.5,5,10];
			attribute<float32> expA (Domain): [2.718282, 7.389056, 33.11545, 148.4132, 22026.46];
			attribute<float32> logA (Domain): [0,0.6931472,1.252763,1.609438,2.302585];
		}

		template Esource
		{
			// begin case parameters
			unit<uint32> Domain;
			// end case paremeters
			attribute<float32> A    (Domain): [];
			attribute<float32> expA (Domain): [];
			attribute<float32> logA (Domain): [];
		}

		container UnTiled  := Template(ADomain, srcDomain);
		container EunTiled := Template(EDomain, srcEDomain);
		container Tiled    := Template(ATiledDomain, srcTiledDomain);
		container ETiled   := Template(ETiledDomain, srcETiledDomain);
		
		Template Template
		{
			unit<uint32> Domain;
			container source;

			container exp: url = "http://www.objectvision.nl/geodms/operators-a-functions/transcendental/exp"
			{
				parameter<bool>    test_param    := float_isNearby(exp(float32(1.0)), float32(2.718282), Dif_all_float32) ;
				attribute<float32> attr (Domain) := exp(source/A); 
				attribute<bool>    test (Domain) := float_isNearby(attr, source/expA, Dif_all_float32) ;
				parameter<bool>    test_attr     := all(test);
			}
			container log: url   = "http://www.objectvision.nl/geodms/operators-a-functions/transcendental/log"
			{
				parameter<bool>    test_param    := log(1.0) = 0.0;
				attribute<float32> attr (Domain) := log(source/A); 
				attribute<bool>    test (Domain) := float_isNearby(attr, source/logA, Dif_all_float32) ;
				parameter<bool>    test_attr     := all(test);
			}
			container results
			{
				parameter<bool> test_params := exp/test_param && log/test_param ;
				parameter<bool> test_attrs  := exp/test_attr && log/test_attr ;
				parameter<bool> tests       := test_params && test_attrs;
			}
		}
	}
	container Conversion
	{
		container srcDomain       := source(ADomain);
		container srcEDomain      := Esource(EDomain);
		container srcTiledDomain  := source(ATiledDomain);
		container srcETiledDomain := Esource(ETiledDomain);

		template source
		{
			// begin case parameters
			unit<uint32> Domain;
			// end case parameters

			unit<bool>    boolUnit;
			unit<int32>   int32Unit;
			unit<float64> float64Unit;
			unit<string>  stringUnit;

			parameter<bool>    BoolParam    := true;
			parameter<uint32>  IntegerParam := 7;
			parameter<float64> FloatParam   := -999.99;
			parameter<string>  stringParam  := 'teststring';

			attribute<int32>        IntegerAtt        (Domain): [0,1,256,-100,9999];
			attribute<uint32>       IntegerAttHex     (Domain): [0,1,11,100,255];
			attribute<float32>      FloatAtt          (Domain): [0,1,9999999,-2.5,99.9];
			attribute<bool>         BoolAtt           (Domain): [0,-1,-1,0,-1];
			attribute<string>       stringAtt         (Domain): ['Hello','Test',null,'Two words','88a'];
			attribute<string>       bstringAtt        (Domain): ['F','Test','False','Two words','Four'];
			attribute<bool>         BoolInteger       (Domain): [0,-1,-1,-1,-1];
			attribute<bool>         BoolFloat         (Domain): [0,-1,-1,-1,-1];
			attribute<bool>         BoolBool          (Domain): [0,-1,-1,0,-1];
			attribute<bool>         Boolstring        (Domain): [0,-1,0,-1,0];
			attribute<string>       StringInteger     (Domain): ['0','1','256','-100','9999'];
			attribute<float32>      float32Integer    (Domain): [0,1,256,-100,9999];
			attribute<float32>      float32Float      (Domain): [0,1,9999999,-2.5,99.9];
			attribute<float32>      float32Bool       (Domain): [0,1,1,0,1];
			attribute<float32>      float32string     (Domain): [null,null,null,null,88];
			attribute<float64>      float64Integer    (Domain): [0,1,256,-100,9999];
			attribute<float64>      float64Float      (Domain): [0,1,9999999,-2.5,99.9];
			attribute<float64>      float64Bool       (Domain): [0,1,1,0,1];
			attribute<float64>      float64string     (Domain): [null,null,null,null,88];
			attribute<int64>        int64Integer      (Domain): [0,1,256,-100,9999];
			attribute<int64>        int64Float        (Domain): [0,1,9999999,-2,99];
			attribute<int64>        int64Bool         (Domain): [0,1,1,0,1];
			attribute<int64>        int64string       (Domain): [null,null,null,null,88];
			attribute<int32>        int32Integer      (Domain): [0,1,256,-100,9999];
			attribute<int32>        int32Float        (Domain): [0,1,9999999,-2,99];
			attribute<int32>        int32Bool         (Domain): [0,1,1,0,1];
			attribute<int32>        int32string       (Domain): [null,null,null,null,88];
			attribute<int16>        int16Integer      (Domain): [0,1,256,-100,9999];
			attribute<int16>        int16Float        (Domain): [0,1,null,-2,99];
			attribute<int16>        int16Bool         (Domain): [0,1,1,0,1];
			attribute<int16>        int16string       (Domain): [null,null,null,null,88];
			attribute<int8>         int8Integer       (Domain): [0,1,null,-100, null];
			attribute<int8>         int8Float         (Domain): [0,1,null,-2,99];
			attribute<int8>         int8Bool          (Domain): [0,1,1,0,1];
			attribute<int8>         int8string        (Domain): [null,null,null,null,88];
			attribute<uint64>       uint64Integer     (Domain): [0,1,256,null,9999];
			attribute<uint64>       uint64Float       (Domain): [0,1,9999999,null,99];
			attribute<uint64>       uint64Bool        (Domain): [0,1,1,0,1];
			attribute<uint64>       uint64string      (Domain): [null,null,null,null,88];
			attribute<uint32>       uint32Integer     (Domain): [0,1,256,null,9999];
			attribute<uint32>       uint32Float       (Domain): [0,1,9999999,null,99];
			attribute<uint32>       uint32Bool        (Domain): [0,1,1,0,1];
			attribute<uint32>       uint32string      (Domain): [null,null,null,null,88];
			attribute<uint16>       uint16Integer     (Domain): [0,1,256,null,9999];
			attribute<uint16>       uint16Float       (Domain): [0,1,null,null,99];
			attribute<uint16>       uint16Bool        (Domain): [0,1,1,0,1];
			attribute<uint16>       uint16string      (Domain): [null,null,null,null,88];
			attribute<uint8>        uint8Integer      (Domain): [0,1,null,null,null];
			attribute<uint8>        uint8Float        (Domain): [0,1,null,null,99];
			attribute<uint8>        uint8Bool         (Domain): [0,1,1,0,1];
			attribute<uint8>        uint8string       (Domain): [null,null,null,null,88];
			attribute<uint4>        uint4Integer      (Domain): [0, 1, 0 , 0, 0];
			attribute<uint4>        uint4Float        (Domain): [0, 1, 0 , 0, 0];
			attribute<uint4>        uint4Bool         (Domain): [0, 1, 1 , 0, 1];
			attribute<uint4>        uint4string       (Domain): [0, 0, 0 , 0, 0];
			attribute<uint2>        uint2Integer      (Domain): [0, 1, 0 , 0, 0];
			attribute<uint2>        uint2Float        (Domain): [0, 1, 0 , 0, 0];
			attribute<uint2>        uint2Bool         (Domain): [0, 1, 1 , 0, 1];
			attribute<uint2>        uint2string       (Domain): [0, 0, 0 , 0, 0];
			attribute<float32>      float32Round      (Domain): [1.49,1.5,-1.49,-1.5,-1.51];
			attribute<int32>        int32Round        (Domain): [1,2,-1,-1,-2];
			attribute<int64>        int64Round        (Domain): [1,2,-1,-1,-2];
			attribute<int32>        int32RoundUp      (Domain): [2,2,-1,-1,-1];
			attribute<int64>        int64RoundUp      (Domain): [2,2,-1,-1,-1];
			attribute<int32>        int32RoundDown    (Domain): [1,1,-2,-2,-2];
			attribute<int64>        int64RoundDown    (Domain): [1,1,-2,-2,-2];
			attribute<int32>        int32RoundToZero  (Domain): [1,1,-1,-1,-1];
			attribute<int64>        int64RoundToZero  (Domain): [1,1,-1,-1,-1];
			attribute<int32>        ValInteger        (Domain): [0,1,256,-100,9999];
			attribute<float64>      ValFloat          (Domain): [0,1,256,-100,9999];
			attribute<bool>         ValBool           (Domain): [0,-1,-1,-1,-1];
			attribute<string>       Valstring         (Domain): ['0','1','256','-100','9999'];
			attribute<int32>        ConvertInteger    (Domain): [0,1,256,-100,9999];
			attribute<float64>      ConvertFloat      (Domain): [0,1,256,-100,9999];
			attribute<bool>         ConvertBool       (Domain): [0,-1,-1,-1,-1];
			attribute<string>       Convertstring     (Domain): ['Hello','Test',null,'Two words','88a'];
			attribute<fpoint>       valFPoint         (Domain): [{0,0},{1,1},{9999999,9999999},{-2.5,-2.5},{99.9,99.9}];
			attribute<spoint>       valSPoint         (Domain): [{0,0},{1,1},null,{-2,-2},{99,99}];
			attribute<ipoint>       valIPoint         (Domain): [{0,0},{1,1},{9999999,9999999},{-2,-2},{99,99}];
			attribute<fpoint>       testFPoint        (Domain): [{0,0},{1,1},null,{-2,-2},{99,99}];
			attribute<dpoint>       valDPoint         (Domain): [{0,0},{1,1},{9999999,9999999},{-2.5,-2.5},{99,99}];
			attribute<wpoint>       valWPoint         (Domain): [{0,0},{1,1},null,null,{99,99}];
			attribute<upoint>       valUPoint         (Domain): [{0,0},{1,1},{9999999,9999999},null,{99,99}];
			attribute<SequenceUnit> SequenceNr        (Domain): [ 0,0,1,1,1];
			attribute<uint32>       Ordinal           (Domain): [ 0,1,0,1,2];
			attribute<string>       AsHex             (Domain): [ '00000000','00000001','0000000B','00000064','000000FF'];
			attribute<string>       HTMLEncodeDecode  (Domain): [ '<','>','&','abcdef',' '];
			attribute<string>       HTMLEncodeOk      (Domain): [ '&lt;','&gt;','&amp','abcdef',' '];
			attribute<string>       UrlEncodeDecode   (Domain): [ '<','>','&','abcdef',' '];
			attribute<string>       UrlEncodeOk       (Domain): [ '&lt;','&gt;','&amp','abcdef',' '];
		}
		template Esource
		{
			// begin case parameters
			unit<uint32> Domain;
			// end case parameters

			unit<bool>    boolUnit;
			unit<int32>   int32Unit;
			unit<float64> float64Unit;
			unit<string>  stringUnit;

			parameter<bool>    BoolParam    := true;
			parameter<uint32>  IntegerParam := 7;
			parameter<float64> FloatParam   := -999.99;
			parameter<string>  stringParam  := 'teststring';

			attribute<int32>        IntegerAtt        (Domain): [];
			attribute<uint32>       IntegerAttHex     (Domain): [];
			attribute<float32>      FloatAtt          (Domain): [];
			attribute<bool>         BoolAtt           (Domain): [];
			attribute<string>       stringAtt         (Domain): [];
			attribute<string>       bstringAtt        (Domain): [];
			attribute<bool>         BoolInteger       (Domain): [];
			attribute<bool>         BoolFloat         (Domain): [];
			attribute<bool>         BoolBool          (Domain): [];
			attribute<bool>         Boolstring        (Domain): [];
			attribute<string>       StringInteger     (Domain): [];
			attribute<float32>      float32Integer    (Domain): [];
			attribute<float32>      float32Float      (Domain): [];
			attribute<float32>      float32Bool       (Domain): [];
			attribute<float32>      float32string     (Domain): [];
			attribute<float64>      float64Integer    (Domain): [];
			attribute<float64>      float64Float      (Domain): [];
			attribute<float64>      float64Bool       (Domain): [];
			attribute<float64>      float64string     (Domain): [];
			attribute<int64>        int64Integer      (Domain): [];
			attribute<int64>        int64Float        (Domain): [];
			attribute<int64>        int64Bool         (Domain): [];
			attribute<int64>        int64string       (Domain): [];
			attribute<int32>        int32Integer      (Domain): [];
			attribute<int32>        int32Float        (Domain): [];
			attribute<int32>        int32Bool         (Domain): [];
			attribute<int32>        int32string       (Domain): [];
			attribute<int16>        int16Integer      (Domain): [];
			attribute<int16>        int16Float        (Domain): [];
			attribute<int16>        int16Bool         (Domain): [];
			attribute<int16>        int16string       (Domain): [];
			attribute<int8>         int8Integer       (Domain): [];
			attribute<int8>         int8Float         (Domain): [];
			attribute<int8>         int8Bool          (Domain): [];
			attribute<int8>         int8string        (Domain): [];
			attribute<uint64>       uint64Integer     (Domain): [];
			attribute<uint64>       uint64Float       (Domain): [];
			attribute<uint64>       uint64Bool        (Domain): [];
			attribute<uint64>       uint64string      (Domain): [];
			attribute<uint32>       uint32Integer     (Domain): [];
			attribute<uint32>       uint32Float       (Domain): [];
			attribute<uint32>       uint32Bool        (Domain): [];
			attribute<uint32>       uint32string      (Domain): [];
			attribute<uint16>       uint16Integer     (Domain): [];
			attribute<uint16>       uint16Float       (Domain): [];
			attribute<uint16>       uint16Bool        (Domain): [];
			attribute<uint16>       uint16string      (Domain): [];
			attribute<uint8>        uint8Integer      (Domain): [];
			attribute<uint8>        uint8Float        (Domain): [];
			attribute<uint8>        uint8Bool         (Domain): [];
			attribute<uint8>        uint8string       (Domain): [];
			attribute<uint4>        uint4Integer      (Domain): [];
			attribute<uint4>        uint4Float        (Domain): [];
			attribute<uint4>        uint4Bool         (Domain): [];
			attribute<uint4>        uint4string       (Domain): [];
			attribute<uint2>        uint2Integer      (Domain): [];
			attribute<uint2>        uint2Float        (Domain): [];
			attribute<uint2>        uint2Bool         (Domain): [];
			attribute<uint2>        uint2string       (Domain): [];
			attribute<float32>      float32Round      (Domain): [];
			attribute<int32>        int32Round        (Domain): [];
			attribute<int64>        int64Round        (Domain): [];
			attribute<int32>        int32RoundUp      (Domain): [];
			attribute<int64>        int64RoundUp      (Domain): [];
			attribute<int32>        int32RoundDown    (Domain): [];
			attribute<int64>        int64RoundDown    (Domain): [];
			attribute<int32>        int32RoundToZero  (Domain): [];
			attribute<int64>        int64RoundToZero  (Domain): [];
			attribute<int32>        ValInteger        (Domain): [];
			attribute<float64>      ValFloat          (Domain): [];
			attribute<bool>         ValBool           (Domain): [];
			attribute<string>       Valstring         (Domain): [];
			attribute<int32>        ConvertInteger    (Domain): [];
			attribute<float64>      ConvertFloat      (Domain): [];
			attribute<bool>         ConvertBool       (Domain): [];
			attribute<string>       Convertstring     (Domain): [];
			attribute<fpoint>       valFPoint         (Domain): [];
			attribute<spoint>       valSPoint         (Domain): [];
			attribute<ipoint>       valIPoint         (Domain): [];
			attribute<fpoint>       testFPoint        (Domain): [];
			attribute<dpoint>       valDPoint         (Domain): [];
			attribute<wpoint>       valWPoint         (Domain): [];
			attribute<upoint>       valUPoint         (Domain): [];
			attribute<SequenceUnit> SequenceNr        (Domain): [];
			attribute<uint32>       Ordinal           (Domain): [];
			attribute<string>       AsHex             (Domain): [];
			attribute<string>       HTMLEncodeDecode  (Domain): [];
			attribute<string>       HTMLEncodeOk      (Domain): [];
			attribute<string>       UrlEncodeDecode   (Domain): [];
			attribute<string>       UrlEncodeOk       (Domain): [];
		}

		container UnTiled  := Template(ADomain, srcDomain);
		container EunTiled := Template(EDomain, srcEDomain);
		container Tiled    := Template(ATiledDomain, srcTiledDomain);
		container ETiled   := Template(ETiledDomain, srcETiledDomain);

		Template Template
		{
			// begin case parameters
			unit<uint32> Domain;
			container source;
			// end case parameters

			container uint2: url = "http://www.objectvision.nl/geodms/operators-a-functions/conversion/uint2"
			{
				parameter<bool> test_param :=
					   uint2(source/IntegerParam) == uint2(7) 
					&& uint2(source/FloatParam)   == uint2(-999.99) 
					&& uint2(source/BoolParam)    == uint2(1) 
					&& uint2(source/stringParam)  == uint2(0);
				parameter<bool> test_param_u2 := uint2(source/IntegerParam) == 7u2 && uint2(source/BoolParam) == 1u2;

				attribute<uint2> att_int     (Domain) := uint2(source/IntegerAtt);
				attribute<bool>  test_int    (Domain) := att_int = source/uint2Integer;
				attribute<uint2> att_float   (Domain) := uint2(source/FloatAtt);
				attribute<bool>  test_float  (Domain) := att_float = source/uint2Float;
				attribute<uint2> att_bool    (Domain) := uint2(source/BoolAtt);
				attribute<bool>  test_bool   (Domain) := att_bool = source/uint2Bool;
				attribute<uint2> att_string  (Domain) := uint2(source/stringAtt);
				attribute<bool>  test_string (Domain) := att_string = source/uint2string;
				attribute<bool>  test        (Domain) := 
					   test_int 
					&& test_float 
					&& test_bool 
					&& test_string;
				parameter<bool> test_attr := all(test);
			}
			container uint4: url = "http://www.objectvision.nl/geodms/operators-a-functions/conversion/uint4"
			{
				parameter<bool> test_param :=
					   uint4(source/IntegerParam) = uint4(7) 
					&& uint4(source/FloatParam)   = uint4(-999.99) 
					&& uint4(source/BoolParam)    = uint4(1) 
					&& uint4(source/stringParam)  = uint4(0) ;
				parameter<bool> test_param_u4 := uint4(source/IntegerParam) == 7u4 && uint4(source/BoolParam) == 1u4;

				attribute<uint4> att_int         (Domain) := uint4(source/IntegerAtt);
				attribute<uint4> att_int_convert (Domain) := convert(source/IntegerAtt, uint4);
				attribute<bool>  test_int        (Domain) := att_int == source/uint4Integer && att_int_convert == source/uint4Integer;
				attribute<uint4> att_float       (Domain) := uint4(source/FloatAtt);
				attribute<bool>  test_float      (Domain) := att_float = source/uint4Float;
				attribute<uint4> att_bool        (Domain) := uint4(source/BoolAtt);
				attribute<bool>  test_bool       (Domain) := att_bool = source/uint4Bool;
				attribute<uint4> att_string      (Domain) := uint4(source/stringAtt);
				attribute<bool>  test_string     (Domain) := att_string = source/uint4string;
				attribute<bool>  test            (Domain) := 
					   test_int 
					&& test_float 
					&& test_bool 
					&& test_string;
				parameter<bool> test_attr := all(test);
			}
			container uint8: url = "http://www.objectvision.nl/geodms/operators-a-functions/conversion/uint8"
			{
				parameter<bool> test_param :=
					   uint8(source/IntegerParam) == uint8(7) 
					&& eq_or_both_null(uint8(source/FloatParam), uint8(-999.99))
					&& uint8(source/BoolParam) == uint8(1) 
					&& Not(isDefined(uint8(source/stringParam)));
				parameter<bool> test_param_b := uint8(source/IntegerParam) == 7b && uint8(source/BoolParam) == 1b;

				attribute<uint8> att_int     (Domain) := uint8(source/IntegerAtt);
				attribute<bool>  test_int    (Domain) := eq_or_both_null(att_int, source/uint8Integer);
				attribute<uint8> att_float   (Domain) := uint8(source/FloatAtt);
				attribute<bool>  test_float  (Domain) := eq_or_both_null(att_float, source/uint8Float);
				attribute<uint8> att_bool    (Domain) := uint8(source/BoolAtt);
				attribute<bool>  test_bool   (Domain) := att_bool = source/uint8Bool;
				attribute<uint8> att_string  (Domain) := uint8(source/stringAtt);
				attribute<bool>  test_string (Domain) := eq_or_both_null(att_string, source/uint8string);
				attribute<bool>  test        (Domain) := 
					   test_int 
					&& test_float 
					&& test_bool 
					&& test_string;
				parameter<bool> test_attr := all(test);
			}
			container uint16: url = "http://www.objectvision.nl/geodms/operators-a-functions/conversion/uint16"
			{
				parameter<bool> test_param :=
					   uint16(source/IntegerParam) == uint16(7) 
					&& eq_or_both_null(uint16(source/FloatParam), uint16(-999.99)) 
					&& uint16(source/BoolParam) == uint16(1) 
					&& Not(isDefined(uint16(source/stringParam)));
				parameter<bool> test_param_w := uint16(source/IntegerParam) = 7w && uint16(source/BoolParam) = 1w;

				attribute<uint16> att_int     (Domain) := uint16(source/IntegerAtt);
				attribute<bool>   test_int    (Domain) := eq_or_both_null(att_int, source/uint16Integer);
				attribute<uint16> att_float   (Domain) := uint16(source/FloatAtt);
				attribute<bool>   test_float  (Domain) := eq_or_both_null(att_float, source/uint16Float);
				attribute<uint16> att_bool    (Domain) := uint16(source/BoolAtt);
				attribute<bool>   test_bool   (Domain) := att_bool = source/uint16Bool;
				attribute<uint16> att_string  (Domain) := uint16(source/stringAtt);
				attribute<bool>   test_string (Domain) := eq_or_both_null(att_string, source/uint16string);
				attribute<bool>   test        (Domain) := 
					   test_int 
					&& test_float 
					&& test_bool 
					&& test_string;
				parameter<bool> test_attr := all(test);
			}
			container uint32: url = "http://www.objectvision.nl/geodms/operators-a-functions/conversion/uint32"
			{
				parameter <uint32> test_afr   := uint32(float32(7) / float32(4) ); 
				parameter <bool>   test_param :=
					   uint32(source/IntegerParam) == uint32(7) 
					&& eq_or_both_null(uint32(source/FloatParam), uint32(-999.99)) 
					&& uint32(source/BoolParam) == uint32(1) 
					&& Not(isDefined(uint32(source/stringParam)));
				parameter <bool>   test_param_u := uint32(source/IntegerParam) = 7u && uint32(source/BoolParam) = 1u;

				attribute<uint32> att_int     (Domain) := uint32(source/IntegerAtt);
				attribute<bool>   test_int    (Domain) := eq_or_both_null(att_int, source/uint32Integer);
				attribute<uint32> att_float   (Domain) := uint32(source/FloatAtt);
				attribute<bool>   test_float  (Domain) := eq_or_both_null(att_float, source/uint32Float);
				attribute<uint32> att_bool    (Domain) := uint32(source/BoolAtt);
				attribute<bool>   test_bool   (Domain) := att_bool = source/uint32Bool;
				attribute<uint32> att_string  (Domain) := uint32(source/stringAtt);
				attribute<bool>   test_string (Domain) := eq_or_both_null(att_string, source/uint32string);
				attribute<bool>  test         (Domain) := 
					   test_int 
					&& test_float 
					&& test_bool 
					&& test_string;
				parameter<bool> test_attr := all(test);
			}
			container uint64: url = "http://www.objectvision.nl/geodms/operators-a-functions/conversion/uint64"
			{
				parameter <uint64> test_afr := uint64(float64(7) / float64(4) ); 
				parameter <bool>   test_param := 
					   uint64(source/IntegerParam) == uint64(7) 
					&& eq_or_both_null(uint64(source/FloatParam), uint64(-999.99)) 
					&& uint64(source/BoolParam) == uint64(1) 
					&& Not(isDefined(uint64(source/stringParam)));
				parameter <bool>   test_param_u64 := uint64(source/IntegerParam) = 7u64 && uint64(source/BoolParam) = 1u64;

				attribute<uint64> att_int     (Domain) := uint64(source/IntegerAtt);
				attribute<bool>   test_int    (Domain) := eq_or_both_null(att_int, source/uint64Integer);
				attribute<uint64> att_float   (Domain) := uint64(source/FloatAtt);
				attribute<bool>   test_float  (Domain) := eq_or_both_null(att_float, source/uint64Float);
				attribute<uint64> att_bool    (Domain) := uint64(source/BoolAtt);
				attribute<bool>   test_bool   (Domain) := att_bool = source/uint64Bool;
				attribute<uint64> att_string  (Domain) := uint64(source/stringAtt);
				attribute<bool>   test_string (Domain) := eq_or_both_null(att_string, source/uint64string);
				attribute<bool>  test         (Domain) := 
					   test_int 
					&& test_float 
					&& test_bool 
					&& test_string;
				parameter<bool> test_attr := all(test);
			}
			container int8: url = "http://www.objectvision.nl/geodms/operators-a-functions/conversion/int8"
			{
				parameter<bool> test_param :=
					   int8(source/IntegerParam) == int8(7) 
					&& eq_or_both_null(int8(source/FloatParam),  int8(-999.99)) 
					&& int8(source/BoolParam) == int8(1) 
					&& Not(isDefined(int8(source/stringParam)));
				parameter<bool> test_param_c:= int8(source/IntegerParam) == 7c && int8(source/BoolParam) == 1c;

				attribute<int8> att_int     (Domain) := int8(source/IntegerAtt);
				attribute<bool> test_int    (Domain) := eq_or_both_null(att_int, source/int8Integer);
				attribute<int8> att_float   (Domain) := int8(source/FloatAtt);
				attribute<bool> test_float  (Domain) := eq_or_both_null(att_float, source/int8Float);
				attribute<int8> att_bool    (Domain) := int8(source/BoolAtt);
				attribute<bool> test_bool   (Domain) := att_bool = source/int8Bool;
				attribute<int8> att_string  (Domain) := int8(source/stringAtt);
				attribute<bool> test_string (Domain) := eq_or_both_null(att_string, source/int8string);
				attribute<bool>  test       (Domain) :=  
					   test_int 
					&& test_float 
					&& test_bool 
					&& test_string;
				parameter<bool> test_attr := all(test);
			}
			container int16: url = "http://www.objectvision.nl/geodms/operators-a-functions/conversion/int16"
			{
				parameter<bool> test_param :=
					   int16(source/IntegerParam) == int16(7) 
					&& int16(source/FloatParam)   == int16(-999.99) 
					&& int16(source/BoolParam)    == int16(1) 
					&& Not(isDefined(int16(source/stringParam)));
				parameter<bool> test_param_s:= int16(source/IntegerParam) == 7s && int16(source/BoolParam) == 1s;

				attribute<int16> att_int     (Domain) := int16(source/IntegerAtt);
				attribute<bool>  test_int    (Domain) := att_int = source/int16Integer;
				attribute<int16> att_float   (Domain) := int16(source/FloatAtt);
				attribute<bool>  test_float  (Domain) := eq_or_both_null(att_float, source/int16Float);
				attribute<int16> att_bool    (Domain) := int16(source/BoolAtt);
				attribute<bool>  test_bool   (Domain) := att_bool = source/int16Bool;
				attribute<int16> att_string  (Domain) := int16(source/stringAtt);
				attribute<bool>  test_string (Domain) := eq_or_both_null(att_string, source/int16string);
				attribute<bool>  test        (Domain) := 
					   test_int 
					&& test_float 
					&& test_bool 
					&& test_string;
				parameter<bool> test_attr := all(test);
			}
			container int32: url = "http://www.objectvision.nl/geodms/operators-a-functions/conversion/int32"
			{
				parameter<bool> test_param :=
					   int32(source/IntegerParam) == int32(7) 
					&& int32(source/FloatParam)   == int32(-999.99) 
					&& int32(source/BoolParam)    == int32(1) 
					&& Not(isDefined(int32(source/stringParam)));
				parameter<bool>  test_param_i := int32(source/IntegerParam) == 7i && int32(source/BoolParam) == 1i;
				attribute<int32> att_int     (Domain) := int32(source/IntegerAtt);
				attribute<bool>  test_int    (Domain) := att_int = source/int32Integer;
				attribute<int32> att_float   (Domain) := int32(source/FloatAtt);
				attribute<bool>  test_float  (Domain) := att_float = source/int32Float;
				attribute<int32> att_bool    (Domain) := int32(source/BoolAtt);
				attribute<bool>  test_bool   (Domain) := att_bool = source/int32Bool;
				attribute<int32> att_string  (Domain) := int32(source/stringAtt);
				attribute<bool>  test_string (Domain) := eq_or_both_null(att_string, source/int32string);
				attribute<bool>  test        (Domain) := 
					   test_int 
					&& test_float 
					&& test_bool 
					&& test_string;
				parameter<bool> test_attr := all(test);
			}
			container int64: url = "http://www.objectvision.nl/geodms/operators-a-functions/conversion/int64"
			{
				parameter<bool> test_param :=
					int64(source/IntegerParam) = int64(7) 
					&& int64(source/FloatParam)= int64(-999.99) 
					&& int64(source/BoolParam) = int64(1) 
					&& Not(isDefined(int64(source/stringParam)));
				parameter<bool>  test_param_i64 := int64(source/IntegerParam) == 7i64 && int64(source/BoolParam) == 1i64;

				attribute<int64> att_int     (Domain) := int64(source/IntegerAtt);
				attribute<bool>  test_int    (Domain) := eq_or_both_null(att_int, source/int64Integer);
				attribute<int64> att_float   (Domain) := int64(source/FloatAtt);
				attribute<bool>  test_float  (Domain) := att_float = source/int64Float;
				attribute<int64> att_bool    (Domain) := int64(source/BoolAtt);
				attribute<bool>  test_bool   (Domain) := att_bool = source/int64Bool;
				attribute<int64> att_string  (Domain) := int64(source/stringAtt);
				attribute<bool>  test_string (Domain) := eq_or_both_null(att_string, source/int64string);
				attribute<bool>  test        (Domain) := 
					   test_int 
					&& test_float 
					&& test_bool 
					&& test_string;
				parameter<bool> test_attr := all(test);
			}
			container float32: url = "http://www.objectvision.nl/geodms/operators-a-functions/conversion/float32"
			{
				parameter<bool> test_param :=
					float32(source/IntegerParam)  == float32(7.0) 
					&& float32(source/FloatParam) == float32(-999.99) 
					&& float32(source/BoolParam)  == float32(1.0) 
					&& Not(isDefined(float32(source/stringParam)));
				parameter<bool> test_param_f :=
					float32(source/IntegerParam)  == 7.0f 
					&& float32(source/FloatParam) == -999.99f 
					&& float32(source/BoolParam)  == 1.0f ;

				attribute<float32> att_int     (Domain) := float32(source/IntegerAtt);
				attribute<bool>    test_int    (Domain) := att_int = source/float32Integer;
				attribute<float32> att_float   (Domain) := float32(source/FloatAtt);
				attribute<bool>    test_float  (Domain) := att_float = source/float32Float;
				attribute<float32> att_bool    (Domain) := float32(source/BoolAtt);
				attribute<bool>    test_bool   (Domain) := att_bool = source/float32Bool;
				attribute<float32> att_string  (Domain) := float32(source/stringAtt);
				attribute<bool>    test_string (Domain) := eq_or_both_null(att_string, source/float32string);
				attribute<bool>    test        (Domain) := 
					   test_int 
					&& test_float 
					&& test_bool 
					&& test_string;
				parameter<bool> test_attr := all(test);
			}
			container float64: url = "http://www.objectvision.nl/geodms/operators-a-functions/conversion/float64"
			// Uitlezen uit MsAccess en casten van float32 attribuut levert kleine afrondingsverschillen op, vandaar constructie met een kleine marge
			{
				parameter<bool> test_param :=
					   float64(source/IntegerParam) == 7.0 
					&& float64(source/FloatParam)   == -999.99 
					&& float64(source/BoolParam)    == 1.0 
					&& Not(isDefined(float64(source/stringParam)));
				parameter<bool> test_param_d :=
					   float64(source/IntegerParam) == 7.0d
					&& float64(source/FloatParam)   == -999.99d
					&& float64(source/BoolParam)    == 1.0d;

				attribute<float64> att_int     (Domain) := float64(source/IntegerAtt);
				attribute<bool>    test_int    (Domain) := att_int = source/float64Integer;
				attribute<float64> att_float   (Domain) := float64(source/FloatAtt);
				attribute<bool>    test_float  (Domain) := float_isNearby(att_float, source/float64Float, Dif_all_float64) ;
				attribute<float64> att_bool    (Domain) := float64(source/BoolAtt);
				attribute<bool>    test_bool   (Domain) := att_bool = source/float64Bool;
				attribute<float64> att_string  (Domain) := float64(source/stringAtt);
				attribute<bool>    test_string (Domain) := eq_or_both_null(att_string, source/float64string);
				attribute<bool>    test        (Domain) := 
					   test_int 
					&& test_float 
					&& test_bool 
					&& test_string;
				parameter<bool> test_attr := all(test);
			}
			container string: url = "http://www.objectvision.nl/geodms/operators-a-functions/conversion/string"
			{
				parameter<bool> test_param := 
					   string(source/IntegerParam) = '7'
					&& string(source/FloatParam)   = '-999.99';
				attribute<string> att_int  (Domain) := string(source/IntegerAtt);
				attribute<bool>   test_int (Domain) := att_int = source/StringInteger;
				parameter<bool>   test_attr := all(test_int);
			}
			container bool: url = "http://www.objectvision.nl/geodms/operators-a-functions/conversion/bool"
			{
				parameter<bool> test_param := 
					    Bool(source/IntegerParam)
					 && Bool(source/FloatParam)
					 && Bool(source/BoolParam)
					 && Bool(source/stringParam);
				attribute<bool> att_int     (Domain) := Bool(source/IntegerAtt);
				attribute<bool> test_int    (Domain) := att_int = source/BoolInteger;
				attribute<bool> att_float   (Domain) := Bool(source/FloatAtt);
				attribute<bool> test_float  (Domain) := att_float = source/BoolFloat;
				attribute<bool> att_bool    (Domain) := Bool(source/BoolAtt);
				attribute<bool> test_bool   (Domain) := att_bool = source/BoolBool;
				attribute<bool> att_string  (Domain) := Bool(source/stringAtt);
				attribute<bool> test_string (Domain) := att_string = source/Boolstring;
				attribute<bool> test        (Domain) := 
					   test_int 
					&& test_float 
					&& test_bool 
					&& test_string;
				parameter<bool> test_attr := all(test);
			}
			container spoint: url = "http://www.objectvision.nl/geodms/operators-a-functions/conversion/spoint"
			{
				attribute<spoint> att  (Domain) := spoint(source/ValFPoint);
				attribute<bool>   test (Domain) := eq_or_both_null(att, source/ValSPoint);
				parameter<bool>   test_attr     := all(test);
			}
			container wpoint: url = "http://www.objectvision.nl/geodms/operators-a-functions/conversion/wpoint"
			{
				attribute<wpoint> att  (Domain) := wpoint(source/ValFPoint);
				attribute<bool>   test (Domain) := eq_or_both_null(att, source/ValWPoint);
				parameter<bool>   test_attr     := all(test);
			}
			container ipoint: url = "http://www.objectvision.nl/geodms/operators-a-functions/conversion/ipoint"
			{
				attribute<ipoint> att  (Domain) := ipoint(source/ValFPoint);
				attribute<bool>   test (Domain) := eq_or_both_null(att, source/ValIPoint);
				parameter<bool>   test_attr     := all(test);
			}
			container upoint: url = "http://www.objectvision.nl/geodms/operators-a-functions/conversion/upoint"
			{
				attribute<upoint> att  (Domain) := upoint(source/ValFPoint);
				attribute<bool>   test (Domain) := eq_or_both_null(att, source/ValUPoint);
				parameter<bool>   test_attr     := all(test);
			}
			container fpoint: url = "http://www.objectvision.nl/geodms/operators-a-functions/conversion/fpoint"
			{
				attribute<fpoint> att  (Domain) := fpoint(spoint/att);
				attribute<bool>   test (Domain) := eq_or_both_null(att, source/testFPoint);
				parameter<bool>   test_attr     := all(test);
			}
			container dpoint: url = "http://www.objectvision.nl/geodms/operators-a-functions/conversion/dpoint"
			{
				attribute<dpoint> att  (Domain) := dpoint(source/ValFPoint);
				attribute<bool>   test (Domain) := point_isNearby(att, source/ValDPoint, dif_all_float64);
				parameter<bool>   test_attr     := all(test);
			}
			container spolygon
			{
				attribute<fpoint> poly (SequenceUnit, polygon) := points2Sequence(Source/valFPoint, Source/SequenceNr, Source/Ordinal);
				attribute<spoint> att  (SequenceUnit, polygon) := spolygon(poly);
				unit<uint32> points := sequence2points(att);

				container tests := 
					for_each_nedv(
						 'param' + string(id(ADomain))
						,'   eq_or_both_null(PointRow(points/point[' + string(id(ADomain)) + ']), PointRow(Source/valSPoint['+ string(id(ADomain)) + '])) 
						  && eq_or_both_null(PointCol(points/point[' + string(id(ADomain)) + ']), PointCol(Source/valSPoint['+ string(id(ADomain)) + ']))'
						, void
						, bool
					);
				parameter<bool>test_attr := =AsList('tests/param' + string(id(ADomain)),' && ');
			}
			container wpolygon
			{
				attribute<fpoint> poly (SequenceUnit, polygon) := points2Sequence(Source/valFPoint, Source/SequenceNr, Source/Ordinal);
				attribute<wpoint> att  (SequenceUnit, polygon) := wpolygon(poly);
				unit<uint32> points := sequence2points(att);

				container tests := 
					for_each_nedv(
						 'param' + string(id(ADomain))
						,'   eq_or_both_null(PointRow(points/point[' + string(id(ADomain)) + ']), PointRow(Source/valWpoint['+ string(id(ADomain)) + '])) 
						  && eq_or_both_null(PointCol(points/point[' + string(id(ADomain)) + ']), PointCol(Source/valWpoint['+ string(id(ADomain)) + ']))'
						, void
						, bool
					);
				parameter<bool>test_attr := =AsList('tests/param' + string(id(ADomain)),' && ');
			}
			container ipolygon
			{
				attribute<fpoint> poly (SequenceUnit, polygon) := points2Sequence(Source/valFPoint, Source/SequenceNr, Source/Ordinal);
				attribute<ipoint> att  (SequenceUnit, polygon) := ipolygon(poly);
				unit<uint32> points := sequence2points(att);

				container tests := 
					for_each_nedv(
						 'param' + string(id(ADomain))
						,'   eq_or_both_null(PointRow(points/point[' + string(id(ADomain)) + ']), PointRow(Source/valIPoint['+ string(id(ADomain)) + '])) 
						  && eq_or_both_null(PointCol(points/point[' + string(id(ADomain)) + ']), PointCol(Source/valIPoint['+ string(id(ADomain)) + ']))'
						, void
						, bool
					);
				parameter<bool>test_attr := =AsList('tests/param' + string(id(ADomain)),' && ');
			}
			container upolygon
			{
				attribute<fpoint> poly (SequenceUnit, polygon) := points2Sequence(Source/valFPoint, Source/SequenceNr, Source/Ordinal);
				attribute<upoint> att  (SequenceUnit, polygon) := upolygon(poly);
				unit<uint32> points := sequence2points(att);

				container tests := 
					for_each_nedv(
						 'param' + string(id(ADomain))
						,'   eq_or_both_null(PointRow(points/point[' + string(id(ADomain)) + ']), PointRow(Source/valUPoint['+ string(id(ADomain)) + '])) 
						  && eq_or_both_null(PointCol(points/point[' + string(id(ADomain)) + ']), PointCol(Source/valUPoint['+ string(id(ADomain)) + ']))'
						, void
						, bool
					);
				parameter<bool>test_attr := =AsList('tests/param' + string(id(ADomain)),' && ');
			}
			container fpolygon
			{
				attribute<fpoint> att  (SequenceUnit, polygon) := fpolygon(dpolygon/att);
				unit<uint32> points := sequence2points(att);

				container tests := 
					for_each_nedv(
						 'param' + string(id(ADomain))
						,'   float_isNearby(PointRow(points/point[' + string(id(ADomain)) + ']), PointRow(Source/valFPoint['+ string(id(ADomain)) + ']), dif_all_float32) 
						  && float_isNearby(PointCol(points/point[' + string(id(ADomain)) + ']), PointCol(Source/valFPoint['+ string(id(ADomain)) + ']), dif_all_float32)'
						, void
						, bool
					);
				parameter<bool>test_attr := =AsList('tests/param' + string(id(ADomain)),' && ');
			}
			container dpolygon
			{
				attribute<fpoint> poly (SequenceUnit, polygon) := points2Sequence(Source/valFPoint, Source/SequenceNr, Source/Ordinal);
				attribute<dpoint> att  (SequenceUnit, polygon) := dpolygon(poly);
				unit<uint32> points := sequence2points(att);

				container tests := 
					for_each_nedv(
						 'param' + string(id(ADomain))
						,'   float_isNearby(PointRow(points/point[' + string(id(ADomain)) + ']), PointRow(Source/valDPoint['+ string(id(ADomain)) + ']), dif_all_float64) 
						  && float_isNearby(PointCol(points/point[' + string(id(ADomain)) + ']), PointCol(Source/valDPoint['+ string(id(ADomain)) + ']), dif_all_float64)'
						, void
						, bool
					);
				parameter<bool>test_attr := =AsList('tests/param' + string(id(ADomain)),' && ');
			}

			container round: url = "http://www.objectvision.nl/geodms/operators-a-functions/conversion/round"
			{
				attribute<int32> att  (Domain) := round(source/float32Round);
				attribute<bool>  test (Domain) := att == source/int32Round;
				parameter<bool>  test_attr     := all(test);
			}
			container round_64: url = "http://www.objectvision.nl/geodms/operators-a-functions/conversion/round"
			{
				attribute<int64> att  (Domain) := round_64(source/float32Round);
				attribute<bool>  test (Domain) := att == source/int64Round;
				parameter<bool>  test_attr     := all(test);
			}
			container roundUp: url = "http://www.objectvision.nl/geodms/operators-a-functions/conversion/roundup"
			{
				attribute<int32> att  (Domain) := RoundUp(source/float32Round);
				attribute<bool>  test (Domain) := att == source/int32RoundUp;
				parameter<bool>  test_attr     := all(test);
			}
			container roundUp_64: url = "http://www.objectvision.nl/geodms/operators-a-functions/conversion/roundup"
			{
				attribute<int64> att  (Domain) := roundUp_64(source/float32Round);
				attribute<bool>  test (Domain) := att == source/int64RoundUp;
				parameter<bool>  test_attr     := all(test);
			}
			container roundDown: url = "http://www.objectvision.nl/geodms/operators-a-functions/conversion/rounddown"
			{
				attribute<int32> att  (Domain) := RoundDown(source/float32Round);
				attribute<bool>  test (Domain) := att == source/int32RoundDown;
				parameter<bool>  test_attr     := all(test);
			}
			container roundDown_64: url = "http://www.objectvision.nl/geodms/operators-a-functions/conversion/rounddown"
			{
				attribute<int64> att  (Domain) := RoundDown_64(source/float32Round);
				attribute<bool>  test (Domain) := att == source/int64RoundDown;
				parameter<bool>  test_attr     := all(test);
			}
			container roundToZero: url = "http://www.objectvision.nl/geodms/operators-a-functions/conversion/roundtozero"
			{
				attribute<int32> att  (Domain) := RoundToZero(source/float32Round);
				attribute<bool>  test (Domain) := att == source/int32RoundToZero;
				parameter<bool>  test_attr     := all(test);
			}
			container roundToZero_64: url = "http://www.objectvision.nl/geodms/operators-a-functions/conversion/roundtozero"
			{
				attribute<int64> att  (Domain) := RoundToZero_64(source/float32Round);
				attribute<bool>  test (Domain) := att == source/int64RoundToZero;
				parameter<bool>  test_attr     := all(test);
			}
			container value: url = "http://www.objectvision.nl/geodms/operators-a-functions/conversion/value"
			{
				parameter<bool> test_param := 
					    Value(source/IntegerParam, source/int32Unit) = int32(7)
					 && Value(source/FloatParam, source/int32Unit)   = int32(-999.99) 
					 && Value(source/BoolParam, source/int32Unit)    = int32(1) 
					 && Not(isDefined(int32(source/stringParam)));
				attribute<int32>   att_int    (Domain) := value(source/IntegerAtt, source/int32Unit);
				attribute<bool>    test_int   (Domain) := att_int = source/valInteger;
				attribute<float64> att_float  (Domain) := value(source/IntegerAtt, source/float64Unit);
				attribute<bool>    test_float (Domain) := att_float = source/valFloat;
				attribute<bool>    att_bool   (Domain) := value(source/IntegerAtt, source/boolUnit);
				attribute<bool>    test_bool  (Domain) := att_bool = source/valBool;
	
				// To be implemented, Integer to string Conversion
				//attribute<string>  att_string  (Domain) := value(source/IntegerAtt, source/stringUnit);
				//attribute<bool>    test_string (Domain) := att_string = source/valstring;
				attribute<bool>  test         (Domain) := 
					   test_int 
					&& test_float 
					&& test_bool ;
				parameter<bool> test_attr := all(test);
			}
			container value_metric
			{
				container units
				{
					unit<float32> m      := BaseUnit('meter', float32);
					unit<float32> s      := BaseUnit('seconde', float32);
					unit<float32> ha     := 10000.0 * m * m;
					unit<float32> per_ha := 1.0 / ha;
				}
				parameter<units/per_ha> paramA := value(10, units/per_ha);
				parameter<units/per_ha> paramB := 10[units/per_ha];

				parameter<string> ValuesUnitA := PropValue(paramA, 'ValuesUnit');
				parameter<string> ValuesUnitB := PropValue(paramB, 'ValuesUnit');

				parameter<float64> MetricFactorA := GetMetricFactor(ValuesUnit(paramA));
				parameter<float64> MetricFactorB := GetMetricFactor(ValuesUnit(paramB));

				parameter <bool> test_param := lowercase(ValuesUnitA) = 'units/per_ha' && lowercase(ValuesUnitB) ='units/per_ha' && MetricFactorA = 0.0001 && MetricFactorB = 0.0001;
			}
			container convert: url = "http://www.objectvision.nl/geodms/operators-a-functions/conversion/convert"
			{
				unit<fpoint> LambertEA: Format = "EPSG:3035";
				unit<fpoint> rdc: Format = "EPSG:28992";
				
				unit<uint32> pointset: nrofrows = 4
				{
					attribute<LambertEA> point_lea:
					[
						(4106297.89, 3388715.54), (4110362.81, 3375737.69), // Borkum - Eemshaven
						(4106297.89, 3388715.54), (4115004.49, 3375613.75) // Borkum - Emden
					];
					attribute<rdc> point := convert(point_lea, rdc);
				}
				
				
				
				parameter <bool> test_param := 
					   Convert(source/IntegerParam, source/int32Unit) = int32(7) 
					&& Convert(source/FloatParam, source/int32Unit)   = int32(-999.99) 
					&& Convert(source/BoolParam, source/int32Unit)    = int32(1) 
					&& Not(isDefined(int32(source/stringParam)));
				attribute<int32>   att_int     (Domain) := convert(source/IntegerAtt, source/int32Unit);
				attribute<bool>    test_int    (Domain) := att_int = source/convertInteger;
				attribute<float64> att_float   (Domain) := convert(source/IntegerAtt, source/float64Unit);
				attribute<bool>    test_float  (Domain) := att_float = source/convertFloat;
				attribute<bool>    att_bool    (Domain) := convert(source/IntegerAtt, source/boolUnit);
				attribute<bool>    test_bool   (Domain) := att_bool = source/convertBool;
				attribute<string>  att_string  (Domain) := convert(source/stringAtt, source/stringUnit);
				attribute<bool>    test_string (Domain) := eq_or_both_null(att_string, source/convertstring);
				attribute<s>       att_metric  (Domain) := convert(att_float[m], s);
				attribute<s>       target_metric (Domain) : [0,1,256,-100,9999];
				attribute<bool>    test_metric (Domain) := eq_or_both_null(att_metric, target_metric);
				
				attribute<bool>    test        (Domain) := 
					   test_int 
					&& test_float 
					&& test_bool 
					&& test_string
					// && test_metric
					;
				parameter<bool> test_attr := all(test);
			}
			/*
			container literal
			{
				parameter<bool> test_param
					 :=    literal(source/IntegerParam) = uint32(7) "
						   "&& literal(source/FloatParam)   = float64(-999.99)"
						   "&& literal(source/BoolParam) "
						   "&& literal(source/stringParam)  = 'teststring';
				attribute<int32>   att_int      (Domain) := literal(source/IntegerAtt);
				attribute<bool>    test_int     (Domain) := att_int = source/IntegerAtt;
				attribute<float32> att_float    (Domain) := literal(source/FloatAtt);
				attribute<bool>    test_float   (Domain) := att_float = source/FloatAtt;
				attribute<bool>    att_bool     (Domain) := literal(source/BoolAtt);
				attribute<bool>    test_bool    (Domain) := att_bool = source/BoolAtt;
				attribute<string>  att_string   (Domain) := literal(source/stringAtt);
				attribute<bool>    test_string  (Domain) := att_string = source/stringAtt;
				attribute<bool>    test         (Domain) :=    test_int "
																   "&& test_float "
																   "&& test_bool "
																   "&& test_string;
				parameter<bool> test_attr                  := all(test);
			}*/
			container rgb: url = "http://www.objectvision.nl/geodms/operators-a-functions/conversion/rgb"
			{
				parameter<uint8>  red        := uint8(128);
				parameter<uint8>  green      := uint8(64);
				parameter<uint8>  blue       := uint8(192);
				parameter<uint32> param      := rgb(red,green,blue), DialogType = "Palette";
				parameter<bool>   test_param := param = 12599424;
			}
			container AsHex: url  = "http://www.objectvision.nl/geodms/operators-a-functions/conversion/ashex"
			{
				parameter<string> param         := AsHex(255);
				parameter<bool>   test_param    := param == '000000FF';
				attribute<string> att  (Domain) := AsHex(Source/IntegerAttHex);
				attribute<bool>   test (Domain) := att = Source/AsHex;
				parameter<bool>   test_attr     := all(test);
			}
			/*
			container UrlEncode
			{
				parameter<string> param         := UrlEncode('<>&abcdef ');
				parameter<bool>   test_param    := param == '&lt;&gt;&amp;abcdef&copy;';
				attribute<string> att  (Domain) := UrlEncode(Source/HTMLEncodeDecode);
				attribute<bool>   test (Domain) := att = Source/HTMLEncodeOk;
				parameter<bool>   test_attr     := all(test);
			}
			
			container HTMLEncode
			{
				parameter<string> param         := HtmlEncode('<>&abcdef ');
				parameter<bool>   test_param    := param == '&lt;&gt;&amp;abcdef&copy;';
				attribute<string> att  (Domain) := HTMLEncode(Source/HTMLEncodeDecode);
				attribute<bool>   test (Domain) := att = Source/HTMLEncodeOk;
				parameter<bool>   test_attr     := all(test);
			}
			*/
			container results
			{
				parameter<bool> test_params := 
					   uint2/test_param 
					&& uint2/test_param_u2 
					&& uint4/test_param 
					&& uint4/test_param_u4 
					&& uint8/test_param 
					&& uint8/test_param_b 
					&& uint16/test_param 
					&& uint16/test_param_w 
					&& uint32/test_param 
					&& uint32/test_param_u 
					&& uint64/test_param 
					&& uint64/test_param_u64 
					&& int8/test_param  
					&& int8/test_param_c 
					&& int16/test_param 
					&& int16/test_param_s 
					&& int32/test_param 
					&& int32/test_param_i
					&& int64/test_param 
					&& int64/test_param_i64 
					&& float32/test_param 
					&& float32/test_param_f 
					&& float64/test_param 
					&& float64/test_param_d 
					&& string/test_param 
					&& bool/test_param 
					&& value/test_param 
					&& value_metric/test_param 
					&& convert/test_param
					&& rgb/test_param
					&& AsHex/test_param;
				parameter<bool> test_attrs := 
					   uint2/test_attr 
					&& uint4/test_attr 
					&& uint8/test_attr 
					&& uint16/test_attr 
					&& uint32/test_attr 
					&& uint64/test_attr 
					&& int8/test_attr 
					&& int16/test_attr 
					&& int32/test_attr 
					&& int64/test_attr 
					&& float32/test_attr 
					&& float64/test_attr 
					&& string/test_attr 
					&& bool/test_attr 
					&& spoint/test_attr 
					&& wpoint/test_attr 
					&& ipoint/test_attr 
					&& upoint/test_attr 
					&& fpoint/test_attr 
					&& dpoint/test_attr 
					&& spolygon/test_attr 
					&& wpolygon/test_attr 
					&& ipolygon/test_attr 
					&& upolygon/test_attr 
					&& fpolygon/test_attr 
					&& dpolygon/test_attr 
					&& round/test_attr 
					&& round_64/test_attr 
					&& roundUp/test_attr 
					&& roundUp_64/test_attr 
					&& roundDown/test_attr 
					&& roundDown_64/test_attr 
					&& roundToZero/test_attr 
					&& roundToZero_64/test_attr 
					&& value/test_attr 
					&& convert/test_attr
					&& AsHex/test_attr;
				parameter<bool> tests := test_params && test_attrs;
			}
		}
	}
	container Aggregations
	{
		container srcDomainUU              := source(RegionDomain     , CityDomain     , CDomain);
		container srcDomainUT              := source(RegionDomain     , CityTiledDomain, CTiledDomain);
		container srcDomainTT              := source(RegionTiledDomain, CityTiledDomain, CTiledDomain);
		container srcDomainTU              := source(RegionTiledDomain, CityDomain     , CDomain);
		
		container EsrcDomainUU             := Esource(EDomain     , EDomain     , EDomain);
		container EsrcDomainUT             := Esource(EDomain     , ETiledDomain, ETiledDomain);
		container EsrcDomainTT             := Esource(ETiledDomain, ETiledDomain, ETiledDomain);
		container EsrcDomainTU             := Esource(ETiledDomain, EDomain     , EDomain);

		template source
		{
			// begin case parameters
			unit<uint32> RegionDomain;
			unit<uint32> CityDomain;
			unit<uint32> Nth_e_w_DomainUnit;
			// end case parameters

			container params
			{
				parameter<uint32> count              : [6];
				parameter<uint32> minNrInhabitants   : [175]; // MAX_VALUE(UInt32) decremented by 1 in GeoDMS 6.061 to be consistent with http://wiki.objectvision.nl/index.php/Value_Types
				parameter<string> minCityName        : ['Amsterdam'];
				parameter<uint32> minIndex           : [6];
				parameter<uint32> maxNrInhabitants   : [550];
				parameter<string> maxCityName        : ['Utrecht'];
				parameter<uint32> maxIndex           : [1];
				parameter<uint32> firstNrInhabitants : [550];
				parameter<string> firstCityName      : ['Amsterdam'];
				parameter<bool>   firstisCapital     : [True] ;
				parameter<uint32> lastNrInhabitants  : [175];
				parameter<string> lastCityName       : ['Haarlem'];
				parameter<bool>   lastisCapital      : [False];
				parameter<uint32> meanNrInhabitants  : [375];
				parameter<uint32> sumNrInhabitants   : [2250];
				parameter<uint32> modusLifeStyleCode : [1];
				parameter<uint32> modusNrSameValue   : [2];
				parameter<uint32> modus_weightedLSC  : [0];
				parameter<uint32> nth_elementNrInh   :[300];
				parameter<uint32> nth_element_wei_v0 : [1];
				parameter<uint32> nth_element_wei_v1 : [2];
				parameter<uint32> nth_element_wei_v2 : [7];
				parameter<uint32> nth_element_wei_v9 : [9];
				parameter<uint32> rth_elementNrInh   : [400];
				parameter<float32> varNrInhabitants  : [24166.67] ;
				parameter<float32> sdNrInhabitants   : [155.46] ;
				parameter<float32> corrNrInhabitants : [-0.89948];
				parameter<float32> covNrInhabitants  : [-156.25];
			}

			unit<uint32> Region := RegionDomain
			{
				attribute<Region>         RegionNr:                [0,1,2,3,4];
				attribute<DegreesCelsius> AvgDailyTemperature:     [12,11,null,14,13];
				attribute<uint32>         countNrInhabitants:      [1,2,1,1,0];
				attribute<uint32>         pcountRegionNr:          [1,2,1,2,0];
				attribute<uint32>         minNrInhabitants:        [550,500,300,200,4294967294]; // MAX_VALUE(UInt32) decremented by 1 in GeoDMS 6.061 to be consistent with http://wiki.objectvision.nl/index.php/Value_Types
				attribute<string>         minCityName:             ['Amsterdam','DenHaag','Utrecht','Eindhoven',''];
				attribute<uint32>         minIndex:                [1, 4, 3, 5, null];
				attribute<uint32>         maxNrInhabitants:        [550,525,300,200,0];
				attribute<uint32>         maxIndex:                [1, 2, 3, 5, null];
				attribute<string>         maxCityName:             ['Amsterdam','Rotterdam','Utrecht','Eindhoven',null];
				attribute<uint32>         firstNrInhabitants:      [550,525,300,200,null];
				attribute<string>         firstCityName:           ['Amsterdam','Rotterdam','Utrecht','Eindhoven',null];
				attribute<bool>           firstIsCapital:          [-1,0,0,0,0];
				attribute<uint32>         lastNrInhabitants:       [550,500,300,200,null];
				attribute<string>         lastCityName:            ['Amsterdam','DenHaag','Utrecht','Eindhoven',null];
				attribute<bool>           lastIsCapital:           [-1,0,0,0,0];
				attribute<float32>        meanNrInhabitants:       [550,512.5,300,200,null];
				attribute<uint32>         rth_elemNrInhabitants:   [550,512,300, 200, null];
				attribute<uint32>         nth_elemNrInhabitants:   [550,500,300, 200, null];
				attribute<uint32>         nth_element_weightedNrIn:[1,3,null,null,null];
				attribute<uint32>         sumNrInhabitants:        [550,1025,300,200,0];
				attribute<uint32>         modusCity:               [12,11,13,null,0];
				attribute<uint32>         modusLifeStyle:          [2,0,1,1,null];
				attribute<uint32>         modus_weightedLifeStyle: [1,0,2,null,0];
				attribute<float32>        sdNrInhabitants:         [0,12.5,0,0,null];
				attribute<float32>        varNrInhabitants:        [0,156.25,0,0,null];
				attribute<float32>        corrNrInhTemp:           [null,null,null,null,null];
				attribute<float32>        covNrInhTemp:            [0,0,null,0,null];
				attribute<bool>           condA:                   [-1,-1,-1,-1,-1];
				attribute<bool>           condB:                   [-1, 0,-1, 0,-1];
				attribute<bool>           condC:                   [ 0, 0, 0, 0, 0];
				attribute<bool>           allInh:                  [ false, false, true, false, true ];
				attribute<bool>           anyInh:                  [ true, true, false, false, false ];
			}

			unit<uint32> City := CityDomain
			{
				attribute<DegreesCelsius> AvgDailyTemperature:     [12,11,null,11,14,null,14];
				attribute<uint32>         LifeStyleCode:           [2,0,1,0,1,1,null];
				attribute<uint32>         NrInhabitants:           [550,525,300,500,200,175,null];
				attribute<bool>           isLarge                  := NrInhabitants >= 200;
				attribute<uint32>         NrSameValueA:            [3,3,2,2,375,null];
				attribute<uint32>         NrSameValueB:            [3,2,3,2,375,null];
				attribute<uint32>         NrSameValueC:            [3,2,2,3,375,null];
				attribute<uint32>         NrSameValueD:            [2,2,3,3,375,null];
				attribute<uint32>         NrSameValueE:            [2,3,2,3,375,null];
				attribute<uint32>         NrSameValueF:            [2,3,3,2,375,null];

				attribute<uint32>         Ranking:                 [1,3,6,9,10,21,50];
				attribute<bool>           isCapital:               [-1,0,0,0,0,0,0];
				attribute<string>         CityName:                ['Amsterdam','Rotterdam','Utrecht','DenHaag','Eindhoven','Haarlem',null];
				attribute<Region>         RegionNr:                [0,1,2,1,3,null,3];
				attribute<grid/units/GridDomain> GridNr := rlookup(point(int16(RegionNr),int16(RegionNr),spoint), id(grid/units/GridDomain));
				// results
				attribute<uint32>         CumulNrInhabitants:         [550,1075,1375,1875,2075,2250,2250];
				attribute<uint32>         CumulNrInhabitantsPerRegion:[550,525,300,1025,200,null, 200];
				attribute<uint32>         CumulIDRegion:              [0,0,0,1,0,null,1];
			}

			unit<uint32> nth_e_w_Domain := Nth_e_w_DomainUnit
			{
				attribute<UInt32>  Rank:     [ 10, 9, 8, 1, 2, 3, 7, 6, 5, 4 ];
				attribute<float32> Weight:   [  1, 1, 1, 3, 3, 3, 2, 2, 2, 2 ];
				attribute<Region>  RegionNr: [  1, 0, 2, 1, 3, 3, 0, 2, 1, 2 ];
			}
		}
		template Esource
		{
			// begin case parameters
			unit<uint32> RegionDomain;
			unit<uint32> CityDomain;
			unit<uint32> Nth_e_w_DomainUnit;
			// end case parameters

			container params
			{
				parameter<uint32> count              : [ 0 ]; // without the 0, count is initialized as null since GeoDms 8.xxx
				parameter<uint32> minNrInhabitants   : [4294967294]; // MAX_VALUE(UInt32) decremented by 1 in GeoDMS 6.061 to be consistent with http://wiki.objectvision.nl/index.php/Value_Types
				parameter<string> minCityName        : [''];
				parameter<uint32> minIndex           := 0 / 0;
				parameter<uint32> maxNrInhabitants   : [0]; // without the 0, count is initialized as null since GeoDms 8.xxx
				parameter<string> maxCityName        : ['']; // without the '', count is initialized as null since GeoDms 8.xxx
				parameter<uint32> maxIndex           :=  0 / 0;
				parameter<uint32> firstNrInhabitants :=  0 / 0;
				parameter<string> firstCityName      :=  string(0 / 0);
				parameter<bool>   firstisCapital     : [] ;
				parameter<uint32> lastNrInhabitants  :=  0 / 0;
				parameter<string> lastCityName       :=  string(0 / 0);
				parameter<bool>   lastisCapital      : [];
				parameter<uint32> meanNrInhabitants  :=  0 / 0;
				parameter<uint32> sumNrInhabitants   : [ 0 ];
				parameter<uint32> modusLifeStyleCode :=  0 / 0;
				parameter<uint32> modusNrSameValue   :=  0 / 0;
				parameter<uint32> modus_weightedLSC  :=  0 / 0;
				parameter<uint32> nth_elementNrInh   :=  0 / 0;
				parameter<uint32> nth_element_wei_v0 :=  0 / 0;
				parameter<uint32> nth_element_wei_v1 :=  0 / 0;
				parameter<uint32> nth_element_wei_v2 :=  0 / 0;
				parameter<uint32> nth_element_wei_v9 :=  0 / 0;
				parameter<uint32> rth_elementNrInh   :=  0 / 0;
				parameter<float32> varNrInhabitants  : [ 0.0 ] ;
				parameter<float32> sdNrInhabitants   : [ 0.0 ] ;
				parameter<float32> corrNrInhabitants : [ 0.0 ];
				parameter<float32> covNrInhabitants  : [ 0.0 ];
			}

			unit<uint32> Region := RegionDomain
			{
				attribute<uint32>         RegionNr:                [];
				attribute<DegreesCelsius> AvgDailyTemperature:     [];
				attribute<uint32>         countNrInhabitants:      [];
				attribute<uint32>         pcountRegionNr:          [];
				attribute<uint32>         minNrInhabitants:        []; // MAX_VALUE(UInt32) decremented by 1 in GeoDMS 6.061 to be consistent with http://wiki.objectvision.nl/index.php/Value_Types
				attribute<string>         minCityName:             [];
				attribute<uint32>         minIndex:                [];
				attribute<uint32>         maxNrInhabitants:        [];
				attribute<uint32>         maxIndex:                [];
				attribute<string>         maxCityName:             [];
				attribute<uint32>         firstNrInhabitants:      [];
				attribute<string>         firstCityName:           [];
				attribute<bool>           firstIsCapital:          [];
				attribute<uint32>         lastNrInhabitants:       [];
				attribute<string>         lastCityName:            [];
				attribute<bool>           lastIsCapital:           [];
				attribute<float32>        meanNrInhabitants:       [];
				attribute<uint32>         rth_elemNrInhabitants:   [];
				attribute<uint32>         nth_elemNrInhabitants:   [];
				attribute<uint32>         nth_element_weightedNrIn:[];
				attribute<uint32>         sumNrInhabitants:        [];
				attribute<uint32>         modusCity:               [];
				attribute<uint32>         modusLifeStyle:          [];
				attribute<uint32>         modus_weightedLifeStyle: [];
				attribute<float32>        sdNrInhabitants:         [];
				attribute<float32>        varNrInhabitants:        [];
				attribute<float32>        corrNrInhTemp:           [];
				attribute<float32>        covNrInhTemp:            [];
				attribute<bool>           condA:                   [];
				attribute<bool>           condB:                   [];
				attribute<bool>           condC:                   [];
				attribute<bool>           allInh:                  [];
				attribute<bool>           anyInh:                  [];
			}

			unit<uint32> City := CityDomain
			{
				attribute<DegreesCelsius> AvgDailyTemperature:     [];
				attribute<uint32>         LifeStyleCode:           [];
				attribute<uint32>         NrInhabitants:           [];
				attribute<bool>           isLarge                  := NrInhabitants >= 200;
				attribute<uint32>         NrSameValueA:            [];
				attribute<uint32>         NrSameValueB:            [];
				attribute<uint32>         NrSameValueC:            [];
				attribute<uint32>         NrSameValueD:            [];
				attribute<uint32>         NrSameValueE:            [];
				attribute<uint32>         NrSameValueF:            [];

				attribute<uint32>         Ranking:                 [];
				attribute<bool>           isCapital:               [];
				attribute<string>         CityName:                [];
				attribute<Region>         RegionNr:                [];
				attribute<grid/units/GridDomain> GridNr := rlookup(point(int16(RegionNr),int16(RegionNr),spoint), id(grid/units/GridDomain));
				// results
				attribute<uint32>         CumulNrInhabitants:         [];
				attribute<uint32>         CumulNrInhabitantsPerRegion:[];
				attribute<uint32>         CumulIDRegion:              [];
			}

			unit<uint32> nth_e_w_Domain := Nth_e_w_DomainUnit
			{
				attribute<UInt32>  Rank:     [];
				attribute<float32> Weight:   [];
				attribute<uint32>  RegionNr: [];
			}
		}

		container UnTiled2UnTiled  := Template(RegionDomain     , CityDomain     , CDomain     , srcDomainUU);
		container UnTiled2Tiled    := Template(RegionTiledDomain, CityDomain     , CDomain     , srcDomainUT);
		container Tiled2UnTiled    := Template(RegionDomain     , CityTiledDomain, CTiledDomain, srcDomainTU);
		container Tiled2Tiled      := Template(RegionTiledDomain, CityTiledDomain, CTiledDomain, srcDomainTT);

		container EUnTiled2UnTiled  := Template(EDomain         , EDomain        , EDomain      , EsrcDomainUU);
		container EUnTiled2Tiled    := Template(ETiledDomain    , EDomain        , EDomain      , EsrcDomainUT);
		container ETiled2UnTiled    := Template(EDomain         , ETiledDomain   , ETiledDomain , EsrcDomainTU);
		container ETiled2Tiled      := Template(ETiledDomain    , ETiledDomain   , ETiledDomain , EsrcDomainTT);

		Template Template
		{
			// begin case parameters
			unit<uint32> RegionDomain;
			unit<uint32> CityDomain;
			unit<uint32> CDomain;
			container src;
			// end case parameters
			
			container Params            := src/Params;
			unit<uint32> Region         := src/Region;
			unit<uint32> City           := src/City;
			unit<uint32> nth_e_w_Domain := src/nth_e_w_Domain;

			container count: url  = "http://www.objectvision.nl/geodms/operators-a-functions/aggregation/count"
			{
				parameter<bool>   test_param          := count(City/NrInhabitants) = params/count ;
				attribute<uint32> att        (Region) := count(City/NrInhabitants, City/RegionNr);
				attribute<bool>   test       (Region) := eq_or_both_null(att, Region/countNrInhabitants);
				parameter<bool>   test_attr           := all(test);
			}
			container pcount: url  = "http://www.objectvision.nl/geodms/operators-a-functions/aggregation/pcount"
			{
				attribute<uint32> att       (Region) := pcount(City/RegionNr);
				attribute<bool>   test      (Region) := att = Region/pcountRegionNr;
				parameter<bool>   test_attr          := all(test);
			}
			container has_any: url  = "http://www.objectvision.nl/geodms/operators-a-functions/aggregation/has_any"
			{
				attribute<bool>   att       (Region) := has_any(City/RegionNr);
				attribute<bool>   test      (Region) := att == (Region/pcountRegionNr > 0);
				parameter<bool>   test_attr          := all(test);
			}
			container min: url  = "http://www.objectvision.nl/geodms/operators-a-functions/aggregation/min"
			{
				parameter<bool>   test_param_uint32 := min(City/NrInhabitants) = params/minNrInhabitants ;
				parameter<bool>   test_param_string := min(City/CityName) = params/minCityName ;
				parameter<bool>   test_param        := test_param_uint32 && test_param_string;
	
				attribute<uint32> att_uint32  (Region) := min(City/NrInhabitants, City/RegionNr);
				attribute<bool>   test_uint32 (Region) := eq_or_both_null(att_uint32, Region/minNrInhabitants);
				attribute<string> att_string  (Region) := min(City/CityName, City/RegionNr);
				attribute<bool>   test_string (Region) := eq_or_both_null(att_string, Region/minCityName);
				parameter<bool>   test_attr            := all(test_uint32) && all(test_string);
			}
			container min_index: url  = "http://www.objectvision.nl/geodms/operators-a-functions/aggregation/max"
			{
				parameter<uint32> test := min_index(City/NrInhabitants);

				parameter<bool>   test_tuint32 := eq_or_both_null(min_index(City/NrInhabitants), params/minIndex);
//NYI			parameter<bool>   test_string := min_index(City/CityName) == 'Amsterdam';
				parameter<bool>   test_param := test_tuint32;
	
				attribute<City>   att_uint32          (Region) := min_index(City/NrInhabitants, City/RegionNr);
				attribute<City>   att_uint32_gridrel  (grid/units/GridDomain) := min_index(City/NrInhabitants, City/gridnr);
				
				attribute<bool>   test_uint32 (Region) := eq_or_both_null(att_uint32, Region/minIndex);
				parameter<bool>   test_attr            := all(test_uint32);
			}
			container max: url  = "http://www.objectvision.nl/geodms/operators-a-functions/aggregation/max"
			{
				parameter<bool>   test_param_uint32 := max(City/NrInhabitants) = params/maxNrInhabitants ;
				parameter<bool>   test_param_string := max(City/CityName) = params/maxCityName ;
				parameter<bool>   test_param        := test_param_uint32 && test_param_string;
	
				attribute<uint32> att_uint32          (Region) := max(City/NrInhabitants, City/RegionNr);
				attribute<uint32> att_uint32_gridrel  (grid/units/GridDomain) := max(City/NrInhabitants, City/gridnr);
				
				attribute<bool>   test_uint32 (Region) := eq_or_both_null(att_uint32, Region/maxNrInhabitants);
				attribute<string> att_string  (Region) := max(City/CityName, City/RegionNr);
				attribute<bool>   test_string (Region) := eq_or_both_null(att_string, MakeDefined(Region/maxCityName,''));
				parameter<bool>   test_attr            := all(test_uint32) && all(test_string);
			}
			container max_index: url  = "http://www.objectvision.nl/geodms/operators-a-functions/aggregation/max"
			{
				parameter<bool>   test_tuint32 := eq_or_both_null(max_index(City/NrInhabitants), params/maxIndex);
				parameter<bool>   test_param   := test_tuint32;
	
				attribute<City>   att_uint32          (Region) := max_index(City/NrInhabitants, City/RegionNr);
				attribute<City>   att_bool            (Region) := max_index(City/isLarge      , City/RegionNr);
				
				attribute<uint32> att_uint32_gridrel  (grid/units/GridDomain) := max_index(City/NrInhabitants, City/gridnr);
				
				attribute<bool>   test_uint32 (Region) := eq_or_both_null(att_uint32, Region/maxIndex);
				parameter<bool>   test_attr            := all(test_uint32);
			}
			container first: url  = "http://www.objectvision.nl/geodms/operators-a-functions/aggregation/first"
			{
				parameter<uint32> param_uint32 := first(City/NrInhabitants);
				parameter<string> param_string := first(City/CityName);

				parameter<bool>   test_param_uint32 := eq_or_both_null(param_uint32, params/firstNrInhabitants);
				parameter<bool>   test_param_string := eq_or_both_null(param_string, params/firstCityName);
				parameter<bool>   test_param_bool   := first(City/isCapital)     == params/firstisCapital ;
				parameter<bool>   test_param        := test_param_uint32 && test_param_string && test_param_bool;
	
				attribute<uint32> att_uint32  (Region) := first(City/NrInhabitants, City/RegionNr);
				attribute<bool>   test_uint32 (Region) := eq_or_both_null(att_uint32, Region/firstNrInhabitants);
				attribute<string> att_string  (Region) := first(City/CityName, City/RegionNr);
				attribute<bool>   test_string (Region) := eq_or_both_null(att_string, Region/firstCityName);
				attribute<bool>   att_bool    (Region) := first(City/isCapital, City/RegionNr);
				attribute<bool>   test_bool   (Region) := att_bool = Region/firstisCapital;
				parameter<bool>   test_attr            := all(test_uint32) && all(test_string) && all(test_bool);
			}
			container last: url  = "http://www.objectvision.nl/geodms/operators-a-functions/aggregation/last"
			{
				parameter<uint32> param_uint32 := last(City/NrInhabitants);
				parameter<string> param_string := last(City/CityName);

				parameter<bool>   test_param_uint32 := eq_or_both_null(param_uint32, params/lastNrInhabitants);
				parameter<bool>   test_param_string := eq_or_both_null(param_string, params/lastCityName);
				parameter<bool>   test_param_bool   := last(City/isCapital)     == params/lastisCapital ;
				parameter<bool>   test_param        := test_param_uint32 && test_param_string && test_param_bool;
	
				attribute<uint32> att_uint32  (Region) := last(City/NrInhabitants, City/RegionNr);
				attribute<bool>   test_uint32 (Region) := eq_or_both_null(att_uint32, Region/lastNrInhabitants);
				attribute<string> att_string  (Region) := last(City/CityName, City/RegionNr);
				attribute<bool>   test_string (Region) := eq_or_both_null(att_string, Region/lastCityName);
				attribute<bool>   att_bool    (Region) := last(City/isCapital, City/RegionNr);
				attribute<bool>   test_bool   (Region) := att_bool = Region/lastisCapital;
				parameter<bool>   test_attr            := all(test_uint32) && all(test_string) && all(test_bool);
			}
			container mean: url  = "http://www.objectvision.nl/geodms/operators-a-functions/aggregation/mean"
			{
				parameter<uint32>  param               := mean(City/NrInhabitants);
				parameter<bool>    test_param          := eq_or_both_null(param, params/meanNrInhabitants) ;
				
				attribute<float32> att        (Region) := mean(float32(City/NrInhabitants), City/RegionNr);
				attribute<bool>    test       (Region) := eq_or_both_null(att, Region/meanNrInhabitants);
				parameter<bool>    test_attr           := all(test);
			}
			container sum: url  = "http://www.objectvision.nl/geodms/operators-a-functions/aggregation/sum"
			{
				parameter<bool>    test_param          := sum(City/NrInhabitants) == params/sumNrInhabitants ;
				attribute<uint32>  att        (Region) := sum(City/NrInhabitants, City/RegionNr);
				attribute<float32> att_F32    (Region) := sum(Float32(City/NrInhabitants), City/RegionNr);
				attribute<bool>    test       (Region) := eq_or_both_null(att, Region/sumNrInhabitants);
				attribute<bool>    test_F32   (Region) := eq_or_both_null(att_F32, Float32(Region/sumNrInhabitants));
				parameter<bool>    test_attr           := all(test) && all(test_F32);
			}
			container sum_uint64: url  = "http://www.objectvision.nl/geodms/operators-a-functions/aggregation/sum"
			{
				attribute<uint16>  NrInhabitants_uint16(City) := uint16(City/NrInhabitants);
				attribute<uint64>  att        (Region) := sum_uint64(NrInhabitants_uint16, City/RegionNr);
				attribute<bool>    test       (Region) := eq_or_both_null(att, uint64(Region/sumNrInhabitants));
				parameter<bool>    test_attr           := all(test);
			}
			container sum_uint32: url  = "http://www.objectvision.nl/geodms/operators-a-functions/aggregation/sum"
			{
				attribute<uint16>  NrInhabitants_uint16(City) := uint16(City/NrInhabitants);
				attribute<uint32>  att        (Region) := sum_uint32(NrInhabitants_uint16, City/RegionNr);
				attribute<bool>    test       (Region) := eq_or_both_null(att, Region/sumNrInhabitants);
				parameter<bool>    test_attr           := all(test);
			}
			container sum_uint16: url  = "http://www.objectvision.nl/geodms/operators-a-functions/aggregation/sum"
			{
				attribute<int16>   NrInhabitants_int16(City) := int16(City/NrInhabitants);
				attribute<uint16>  att        (Region) := sum_uint16(NrInhabitants_int16, City/RegionNr);
				attribute<bool>    test       (Region) := eq_or_both_null(att, uint16(Region/sumNrInhabitants));
				parameter<bool>    test_attr           := all(test);
			}
			container sum_uint8: url  = "http://www.objectvision.nl/geodms/operators-a-functions/aggregation/sum"
			{
				attribute<int8>    NrInhabitants_int8(City) := int8(float32(City/NrInhabitants) / 10f);
				attribute<uint8>   att        (Region) := sum_uint8(NrInhabitants_int8, City/RegionNr);
				attribute<bool>    test       (Region) := eq_or_both_null(att, uint8(float32(Region/sumNrInhabitants) / 10f ));
				parameter<bool>    test_attr           := all(test);
			}
			container sum_int64: url  = "http://www.objectvision.nl/geodms/operators-a-functions/aggregation/sum"
			{
				attribute<int16>  NrInhabitants_uint16(City) := int16(City/NrInhabitants);
				attribute<int64>  att         (Region) := sum_int64(NrInhabitants_uint16, City/RegionNr);
				attribute<bool>   test        (Region) := eq_or_both_null(att, int64(Region/sumNrInhabitants));
				parameter<bool>   test_attr            := all(test);
			}
			container sum_int32: url  = "http://www.objectvision.nl/geodms/operators-a-functions/aggregation/sum"
			{
				attribute<int16>   NrInhabitants_uint16(City) := int16(City/NrInhabitants);
				attribute<int32>   att        (Region) := sum_int32(NrInhabitants_uint16, City/RegionNr);
				attribute<bool>    test       (Region) := eq_or_both_null(att, int32(Region/sumNrInhabitants));
				parameter<bool>    test_attr           := all(test);
			}
			container sum_int16: url  = "http://www.objectvision.nl/geodms/operators-a-functions/aggregation/sum"
			{
				attribute<int16>   NrInhabitants_int16(City) := int16(City/NrInhabitants);
				attribute<int16>   att        (Region) := sum_int16(NrInhabitants_int16, City/RegionNr);
				attribute<bool>    test       (Region) := eq_or_both_null(att, int16(Region/sumNrInhabitants));
				parameter<bool>    test_attr           := all(test);
			}
			container sum_int8: url  = "http://www.objectvision.nl/geodms/operators-a-functions/aggregation/sum"
			{
				attribute<int8>    NrInhabitants_int8(City) := int8(float32(City/NrInhabitants) / 10f);
				attribute<int8>    att        (Region) := sum_int8(NrInhabitants_int8, City/RegionNr);
				attribute<bool>    test       (Region) := eq_or_both_null(att, int8(float32(Region/sumNrInhabitants) / 10f ));
				parameter<bool>    test_attr           := all(test);
			}
			container sum_float64: url  = "http://www.objectvision.nl/geodms/operators-a-functions/aggregation/sum"
			{
				attribute<float32>  NrInhabitants_float32(City) := float32(City/NrInhabitants);
				attribute<float64> att        (Region) := sum_float64(NrInhabitants_float32, City/RegionNr);
				attribute<bool>    test       (Region) := eq_or_both_null(att, float64(Region/sumNrInhabitants));
				parameter<bool>    test_attr           := all(test);
			}
			container cumulate: url  = "http://www.objectvision.nl/geodms/operators-a-functions/aggregation/cumulate" // requires GeoDMS 6.061
			{
				attribute<uint32>  att (City)     := cumulate(City/NrInhabitants);
				attribute<bool>    test(City)     := att == City/CumulNrInhabitants;
				parameter<bool>    test_param     := all(test);
				attribute<uint32>  att_reg (City) := cumulate(City/NrInhabitants, City/RegionNr);
				attribute<bool>    test_reg(City) := eq_or_both_null(att_reg, City/CumulNrInhabitantsPerRegion);
				parameter<bool>    test_attr      := all(test_reg);
			}
			container cumulate_as_id: url  = "http://www.objectvision.nl/geodms/operators-a-functions/aggregation/cumulate" // requires GeoDMS 6.061
			{
				attribute<uint32>  att (City)     := cumulate(const(1,City,uint32));
				attribute<uint32>  nr (City)      := id(City);
				attribute<bool>    test(City)     := att == nr;
				parameter<bool>    test_param     := all(test);
				attribute<uint32>  att_reg (City) := cumulate(const(1,City,uint32), City/RegionNr)-1;
				attribute<bool>    test_reg(City) := eq_or_both_null(att_reg, City/CumulIDRegion);
				parameter<bool>    test_attr      := all(test_reg);
			}

			container modus: url  = "http://www.objectvision.nl/geodms/operators-a-functions/aggregation/modus"
			{
				parameter<uint32>  modus_lfc           := modus(City/LifeStyleCode);
				parameter<uint32>  modus_NrSameValueA  := modus(City/NrSameValueA);

				parameter<bool>    test_param          := eq_or_both_null(modus_lfc, params/modusLifeStyleCode) && param_NrSameValueA && param_NrSameValueB && param_NrSameValueC && param_NrSameValueD && param_NrSameValueE && param_NrSameValueF;
				parameter<bool>    param_NrSameValueA  := eq_or_both_null(modus(City/NrSameValueA), params/modusNrSameValue);
				parameter<bool>    param_NrSameValueB  := eq_or_both_null(modus(City/NrSameValueB), params/modusNrSameValue);
				parameter<bool>    param_NrSameValueC  := eq_or_both_null(modus(City/NrSameValueC), params/modusNrSameValue);
				parameter<bool>    param_NrSameValueD  := eq_or_both_null(modus(City/NrSameValueD), params/modusNrSameValue);
				parameter<bool>    param_NrSameValueE  := eq_or_both_null(modus(City/NrSameValueE), params/modusNrSameValue);
				parameter<bool>    param_NrSameValueF  := eq_or_both_null(modus(City/NrSameValueF), params/modusNrSameValue);

				attribute<uint32>  att        (Region) := modus(City/LifeStyleCode, City/RegionNr);
				attribute<int32>   att_int32  (Region) := modus(int32(City/LifeStyleCode), City/RegionNr);

				attribute<uint32> att_uint32_gridrel (grid/units/GridDomain) := modus(uint32(City/AvgDailyTemperature), City/gridnr);

				attribute<uint32> modus_temp_met_data (grid/units/GridDomain) :[12,null,null,null,null,null,11,null,null,null,null,null,null,null,null,null,null,null,14,null,null,null,null,null,null];
				
				attribute<uint32> modus_temp          (grid/units/GridDomain) := 
					#City == 0
						? const( 0 / 0, grid/units/GridDomain)
						: modus_temp_met_data;

				attribute<uint16>  att_uint16 (Region) := modus(uint16(City/LifeStyleCode), City/RegionNr);
				attribute<int16>   att_int16  (Region) := modus(int16(City/LifeStyleCode), City/RegionNr);
				attribute<uint8>   att_uint8  (Region) := modus(uint8(City/LifeStyleCode), City/RegionNr);
				attribute<int8>    att_int8   (Region) := modus(int8(City/LifeStyleCode), City/RegionNr);
				attribute<uint4>   att_uint4  (Region) := modus(uint4(City/LifeStyleCode), City/RegionNr);
				attribute<uint2>   att_uint2  (Region) := modus(uint2(City/LifeStyleCode), City/RegionNr);
	//			attribute<string>  att_string (Region) := modus(string(City/LifeStyleCode), City/RegionNr);
				attribute<bool>    att_bool   (Region) := modus(bool(City/LifeStyleCode), City/RegionNr);
	
				attribute<bool>    test         (Region)                := eq_or_both_null(att, Region/modusLifeStyle);
				attribute<bool>    test_gridrel (grid/units/GridDomain) := eq_or_both_null(att_uint32_gridrel, modus_temp);

				parameter<bool>    test_attr := all(test) && all(test_gridrel);
			}
			container modus_weighted: url  = "http://www.objectvision.nl/geodms/operators-a-functions/aggregation/modus_weighted"
			{
				parameter<bool>    test_param          := eq_or_both_null(modus_weighted(City/LifeStyleCode, City/nrinhabitants), params/modus_weightedLSC);
				attribute<uint32>  att        (Region) := modus_weighted(City/LifeStyleCode, City/nrinhabitants, City/RegionNr);
				attribute<int32>   att_int32  (Region) := modus_weighted(int32(City/LifeStyleCode), City/nrinhabitants, City/RegionNr);
				attribute<uint16>  att_uint16 (Region) := modus_weighted(uint16(City/LifeStyleCode), City/nrinhabitants, City/RegionNr);
				attribute<int16>   att_int16  (Region) := modus_weighted(int16(City/LifeStyleCode), City/nrinhabitants, City/RegionNr);
				attribute<uint8>   att_uint8  (Region) := modus_weighted(uint8(City/LifeStyleCode), City/nrinhabitants, City/RegionNr);
				attribute<int8>    att_int8   (Region) := modus_weighted(int8(City/LifeStyleCode), City/nrinhabitants, City/RegionNr);
				attribute<uint4>   att_uint4  (Region) := modus_weighted(uint4(City/LifeStyleCode), City/nrinhabitants, City/RegionNr);
				attribute<uint2>   att_uint2  (Region) := modus_weighted(uint2(City/LifeStyleCode), City/nrinhabitants, City/RegionNr);
	//			attribute<string>  att_string (Region) := modus_weighted(string(City/LifeStyleCode), City/nrinhabitants, City/RegionNr);
				attribute<bool>    att_bool   (Region) := modus_weighted(bool(City/LifeStyleCode), City/nrinhabitants, City/RegionNr);
	
				attribute<bool>    test       (Region) := eq_or_both_null(att, Region/modusLifeStyle);
				parameter<bool>    test_attr           := all(test);
			}
			container nth_element: url  = "http://www.objectvision.nl/geodms/operators-a-functions/aggregation/nthelement"
			{
				parameter<bool>    test_param          := eq_or_both_null(nth_element(City/NrInhabitants, 2), params/nth_elementNrInh) ;
				attribute<uint32>  att        (Region) := nth_element(City/NrInhabitants, const(0, Region), City/RegionNr);
				attribute<bool>    test       (Region) := eq_or_both_null(att, Region/nth_elemNrInhabitants);
				parameter<bool>    test_attr           := all(test);
			}
			container nth_element_weighted: url = "http://www.objectvision.nl/geodms/operators-a-functions/aggregation/nthelementweighted"
			{
				parameter<uint32> test_v0 := nth_element_weighted(nth_e_w_Domain/Rank, 0f, nth_e_w_Domain/Weight);
				parameter<uint32> test_v1 := nth_element_weighted(nth_e_w_Domain/Rank, 3f,  nth_e_w_Domain/Weight);
				parameter<uint32> test_v2 := nth_element_weighted(nth_e_w_Domain/Rank, 15f, nth_e_w_Domain/Weight);

				parameter<Bool>   test_param_extra := eq_or_both_null(test_v0, params/nth_element_wei_v0) && eq_or_both_null(test_v1, params/nth_element_wei_v1) && eq_or_both_null(test_v2, params/nth_element_wei_v2) && not(IsDefined(test_v9));
				parameter<uint32> test_v9          := nth_element_weighted(nth_e_w_Domain/Rank, 1000f, nth_e_w_Domain/Weight);
				parameter<Bool>   test_param       := test_param_extra && eq_or_both_null(nth_element_weighted(City/Ranking, float32(1800), float32(City/nrinhabitants)), params/nth_element_wei_v9);
	
				attribute<uint32> att  (Region) := nth_element_weighted(City/Ranking, float32(400), float32(City/nrinhabitants),City/RegionNr);
				attribute<bool>   test (Region) := eq_or_both_null(att, Region/nth_element_weightedNrIn);
				parameter<bool>   test_attr     := all(test);
			}
			container rth_element: url = "http://www.objectvision.nl/geodms/operators-a-functions/aggregation/rth_element"
			{
				parameter<bool>    test_param          := eq_or_both_null(rth_element(City/NrInhabitants, float32(0.5)), params/rth_elementNrInh);
				attribute<uint32>  att        (Region) := rth_element(City/NrInhabitants, const(float32(0.5), Region), City/RegionNr);
				attribute<bool>    test       (Region) := eq_or_both_null(att, Region/rth_elemNrInhabitants);
				parameter<bool>    test_attr           := all(test);
			}
			container var: url = "http://www.objectvision.nl/geodms/operators-a-functions/aggregation/var"
			{
				parameter<float32> param               := var(float32(City/NrInhabitants));
				
				parameter<bool>    test_param          := float_isNearby(param, params/varNrInhabitants, Dif_all_float32) || isNull(param);
				attribute<float32> att        (Region) := var(float32(City/NrInhabitants), City/RegionNr);
				attribute<bool>    test       (Region) := float_isNearby(att, Region/varNrInhabitants, Dif_all_float32) ;
				parameter<bool>    test_attr           := all(test);
			}
			container sd: url = "http://www.objectvision.nl/geodms/operators-a-functions/aggregation/sd"
			{
				parameter<float32> param               := sd(float32(City/NrInhabitants));

				parameter<bool>    test_param          := float_isNearby(param, params/sdNrInhabitants, Dif_all_float32) || isNull(param);
				attribute<float32> att        (Region) := sd(float32(City/NrInhabitants), City/RegionNr);
				attribute<bool>    test       (Region) := float_isNearby(att, Region/sdNrInhabitants, Dif_all_float32) ;
				parameter<bool>    test_attr           := all(test);
			}
			container corr: url = "http://www.objectvision.nl/geodms/operators-a-functions/aggregation/corr"
			{
				parameter<float32> param               := corr(float32(City/NrInhabitants), City/AvgDailyTemperature);

				parameter<bool>    test_param          := float_isNearby(param, params/corrNrInhabitants, Dif_all_float32) || isNull(param);
				attribute<float32> att        (Region) := corr(float32(City/NrInhabitants), float32(City/AvgDailyTemperature), City/RegionNr);
				attribute<bool>    test       (Region) := eq_or_both_null(att, Region/corrNrInhTemp);
				parameter<bool>    test_attr           := all(test);
			}
			container cov: url = "http://www.objectvision.nl/geodms/operators-a-functions/aggregation/cov"
			{
				parameter<float32> param               := cov(float32(City/NrInhabitants), City/AvgDailyTemperature);

				parameter<bool>    test_param          := float_isNearby(param, params/covNrInhabitants, Dif_all_float32) || isNull(param);
				attribute<float32> att        (Region) := cov(float32(City/NrInhabitants), float32(City/AvgDailyTemperature), City/RegionNr);
				attribute<bool>    test       (Region) := eq_or_both_null(att, Region/covNrInhTemp);
				parameter<bool>    test_attr           := all(test);
			}
			container all: url = "http://www.objectvision.nl/geodms/operators-a-functions/aggregation/all"
			{
				parameter<bool> test_param          := all(True);
				attribute<bool> test_region(Region) := all(City/NrInhabitants < 500, City/RegionNr); // has region a city >= 500 [Inh]
				parameter<bool> test_attr := #(Region) > 0
					?	 all(test_region == Region/allInh)
						&& all(Region/condA) 
						&& not(all(Region/condB)) 
						&& not(all(Region/condC))
					: True;
			}
			container any: url = "http://www.objectvision.nl/geodms/operators-a-functions/aggregation/any"
			{
				parameter<bool> test_param := any(True);
				attribute<bool> test_region(Region) := any(City/NrInhabitants >= 500, City/RegionNr); // has region a city >= 500 [Inh]
				parameter<bool> test_attr  := #(Region) > 0
					?	 all(test_region ==  Region/anyInh)
						&&     any(Region/condA) 
						&&     any(Region/condB) 
						&& not(any(Region/condC))
					: True;
			}
			container reg_count: url = "http://www.objectvision.nl/geodms/operators-a-functions/aggregation/reg_count" // Not yet tested for tiled data
			{
				container units
				{
					unit<uint32> Domain: nrofrows = 10;
					unit<uint8>  RegioA: nrofrows = 5;
					unit<uint8>  RegioB: nrofrows = 3;
					unit<uint8>  Class:  nrofrows = 4
					{
						attribute<string> label: ['class1','class2','class3','class4'];
					}
				}
				container Regios
				{
					attribute<units/RegioA> A (units/Domain): [0,0,1,2,3,0,4,2,1,0];
					attribute<units/RegioB> B (units/Domain): [1,0,2,2,0,0,1,2,1,0];
				}
				attribute<units/Class> src (units/Domain): [0,1,3,2,0,1,2,1,0,3]; // class-value for each domain-element
				attribute<string>      refs(units/Class):  ['A','A','B','A']; // partitioning-name for each class
	
				container references // expected results
				{
					attribute<uint32> class1 (units/regioA):[1,1,0,1,0];
					attribute<uint32> class2 (units/regioA):[2,0,1,0,0];
					attribute<uint32> class3 (units/regioB):[0,1,1];
					attribute<uint32> class4 (units/regioA):[1,1,0,0,0];
				}
				container attributes := reg_count(src, units/Class/label, Regios, refs);
				container tests
				{
					attribute<bool> class1 (units/regioA) := attributes/class1 == references/class1;
					attribute<bool> class2 (units/regioA) := attributes/class2 == references/class2;
					attribute<bool> class3 (units/regioB) := attributes/class3 == references/class3;
					attribute<bool> class4 (units/regioA) := attributes/class4 == references/class4;
				}
				parameter<bool> test_attr := all(tests/class1) && all(tests/class2) && all(tests/class3) && all(tests/class4);
			}
			container reg_count_uint16: url = "http://www.objectvision.nl/geodms/operators-a-functions/aggregation/reg_count" // Not yet tested for tiled data
			{
				container units
				{
					unit<uint32> Domain: nrofrows = 10;
					unit<uint8>  RegioA: nrofrows = 5;
					unit<uint8>  RegioB: nrofrows = 3;
					unit<uint8>  Class:  nrofrows = 4
					{
						attribute<string> label: ['class1','class2','class3','class4'];
					}
				}
				container Regios
				{
					attribute<units/RegioA> A (units/Domain): [0,0,1,2,3,0,4,2,1,0];
					attribute<units/RegioB> B (units/Domain): [1,0,2,2,0,0,1,2,1,0];
				}
				attribute<units/Class> src (units/Domain): [0,1,3,2,0,1,2,1,0,3]; // class-value for each domain-element
				attribute<string>      refs(units/Class):  ['A','A','B','A']; // partitioning-name for each class
	
				container references // expected results
				{
					attribute<uint16> class1 (units/regioA):[1,1,0,1,0];
					attribute<uint16> class2 (units/regioA):[2,0,1,0,0];
					attribute<uint16> class3 (units/regioB):[0,1,1];
					attribute<uint16> class4 (units/regioA):[1,1,0,0,0];
				}
				container attributes := reg_count_uint16(src, units/Class/label, Regios, refs);
				container tests
				{
					attribute<bool> class1 (units/regioA) := attributes/class1 == references/class1;
					attribute<bool> class2 (units/regioA) := attributes/class2 == references/class2;
					attribute<bool> class3 (units/regioB) := attributes/class3 == references/class3;
					attribute<bool> class4 (units/regioA) := attributes/class4 == references/class4;
				}
				parameter<bool> test_attr := all(tests/class1) && all(tests/class2) && all(tests/class3) && all(tests/class4);
			}
			container reg_count_uint8: url = "http://www.objectvision.nl/geodms/operators-a-functions/aggregation/reg_count" // Not yet tested for tiled data
			{
				container units
				{
					unit<uint32> Domain: nrofrows = 10;
					unit<uint8>  RegioA: nrofrows = 5;
					unit<uint8>  RegioB: nrofrows = 3;
					unit<uint8>  Class:  nrofrows = 4
					{
						attribute<string> label: ['class1','class2','class3','class4'];
					}
				}
				container Regios
				{
					attribute<units/RegioA> A (units/Domain): [0,0,1,2,3,0,4,2,1,0];
					attribute<units/RegioB> B (units/Domain): [1,0,2,2,0,0,1,2,1,0];
				}
				attribute<units/Class> src (units/Domain): [0,1,3,2,0,1,2,1,0,3]; // class-value for each domain-element
				attribute<string>      refs(units/Class):  ['A','A','B','A']; // partitioning-name for each class
	
				container references // expected results
				{
					attribute<uint8> class1 (units/regioA):[1,1,0,1,0];
					attribute<uint8> class2 (units/regioA):[2,0,1,0,0];
					attribute<uint8> class3 (units/regioB):[0,1,1];
					attribute<uint8> class4 (units/regioA):[1,1,0,0,0];
				}
				container attributes := reg_count_uint8(src, units/Class/label, Regios, refs);
				container tests
				{
					attribute<bool> class1 (units/regioA) := attributes/class1 == references/class1;
					attribute<bool> class2 (units/regioA) := attributes/class2 == references/class2;
					attribute<bool> class3 (units/regioB) := attributes/class3 == references/class3;
					attribute<bool> class4 (units/regioA) := attributes/class4 == references/class4;
				}
				parameter<bool> test_attr := all(tests/class1) && all(tests/class2) && all(tests/class3) && all(tests/class4);
			}
			container reg_count_empty: url = "http://www.objectvision.nl/geodms/operators-a-functions/aggregation/reg_count" // Not yet tested for tiled data
			{
				container units
				{
					unit<uint32> Domain: nrofrows = 0;
					unit<uint8>  RegioA: nrofrows = 0;
					unit<uint8>  RegioB: nrofrows = 0;
					unit<uint8>  Class:  nrofrows = 0
					{
						attribute<string> label: [];
					}
				}
				container Regios
				{
					attribute<units/RegioA> A (units/Domain): [];
					attribute<units/RegioB> B (units/Domain): [];
				}
				attribute<units/Class> src (units/Domain): []; // class-value for each domain-element
				attribute<string>      refs(units/Class):  []; // partitioning-name for each class
	
				container references // expected results
				{
					attribute<uint32> class1 (units/regioA):[];
					attribute<uint32> class2 (units/regioA):[];
					attribute<uint32> class3 (units/regioB):[];
					attribute<uint32> class4 (units/regioA):[];
				}
				container attributes := reg_count(src, units/Class/label, Regios, refs);

				unit<uint32> reg_count_subitems:= SubItem_PropValues(attributes,'name');

				parameter<bool> test_attr := #reg_count_subitems = 0;
			}
			container results
			{
				parameter<bool> test_params := 
					   count/test_param
					&& min/test_param
					&& min_index/test_param
					&& max/test_param
					&& max_index/test_param
					&& first/test_param
					&& last/test_param
					&& mean/test_param
					&& sum/test_param
					&& modus/test_param
					&& modus_weighted/test_param
					&& cumulate/test_param
					&& cumulate_as_id/test_param
					&& nth_element/test_param
					&& nth_element_weighted/test_param
					&& rth_element/test_param
					&& var/test_param
					&& sd/test_param
					&& corr/test_param
					&& cov/test_param
					&& all/test_param
					&& any/test_param;
				parameter<bool> test_attr := 
					   count/test_attr
					&& pcount/test_attr
					&& has_any/test_attr
					&& min/test_attr
					&& min_index/test_attr
					&& max/test_attr
					&& max_index/test_attr
					&& first/test_attr
					&& last/test_attr
					&& mean/test_attr
					&& sum/test_attr
					&& sum_uint32/test_attr
					&& sum_uint16/test_attr
					&& sum_uint8/test_attr
					&& sum_uint64/test_attr
					&& sum_int32/test_attr
					&& sum_int16/test_attr
					&& sum_int8/test_attr
					&& sum_int64/test_attr
					&& sum_float64/test_attr
					
					&& modus/test_attr
					&& modus_weighted/test_attr
					&& cumulate/test_attr
					&& cumulate_as_id/test_attr
					&& nth_element/test_attr
					&& nth_element_weighted/test_attr
					&& rth_element/test_attr
					&& var/test_attr
					&& sd/test_attr
					&& corr/test_attr
					&& cov/test_attr
					&& all/test_attr 
					&& any/test_attr 
					&& reg_count/test_attr
					&& reg_count_uint16/test_attr
					&& reg_count_uint8/test_attr
					&& reg_count_empty/test_attr;
				parameter<bool> tests := test_params && test_attr;
			}
		}
	}
	container Predicates
	{
		container srcDomain       := source(ADomain);
		container srcEDomain      := Esource(EDomain);

		container srcTiledDomain  := source(ATiledDomain);
		container srcETiledDomain := Esource(ETiledDomain);

		template source
		{
			// begin case parameters
			unit<uint32> Domain;
			// end case parameters
			parameter<bool>    BoolParam        := true;
			parameter<uint32>  IntegerParam     := 7;
			parameter<uint32>  IntegerZeroParam := 0;
			parameter<float64> FloatParam       := -999.99;
			parameter<string>  stringParam      := substr('hallo',0,0);

			attribute<uint8>   IntegerAtt         (Domain): [0,null,1,-100,9999];
			attribute<int8>    SignedIntAtt       (Domain): [1,10,100,-59,0];
			attribute<float32> FloatAtt           (Domain): [0,null,9999999,-2.5,99.9];
			attribute<float32> DefFloatAtt        (Domain): [0,0,9999999,-2.5,99.9];
			attribute<bool>    BoolAtt            (Domain): [0,-1,-1,0,-1];
			attribute<string>  stringAtt          (Domain): ['Hello','null',null,'Two words','88a'];
			attribute<uint8>   MakeDefineduint8   (Domain): [0,0,1,0,0];
			attribute<float32> MakeDefinedfloat32 (Domain): [0,0,9999999,-2.5,99.9];
			attribute<bool>    MakeDefinedBool    (Domain): [0,-1,-1,0,-1];
			attribute<string>  MakeDefinedstring  (Domain): ['Hello','null','test','Two words','88a'];
			attribute<bool>    isDefineduint8     (Domain): [-1,0,-1,0,0];
			attribute<bool>    isDefinedfloat32   (Domain): [-1,0,-1,-1,-1];
			attribute<bool>    isDefinedBool      (Domain): [-1,-1,-1,-1,-1];
			attribute<bool>    isDefinedstring    (Domain): [-1,-1,0,-1,-1];
			attribute<bool>    isNullUint8        (Domain): [0,-1,0,-1,-1];
			attribute<bool>    isNullfloat32      (Domain): [0,-1,0,0,0];
			attribute<bool>    isNullBool         (Domain): [0,0,0,0,0];
			attribute<bool>    isNullstring       (Domain): [0,0,-1,0,0];
			attribute<bool>    isPositiveint8     (Domain): [-1,-1,-1,0,0];
			attribute<bool>    isPositivefloat32  (Domain): [0,0,-1,0,-1];
			attribute<bool>    isNegativeint8     (Domain): [0,0,0,-1,0];
			attribute<bool>    isNegativefloat32  (Domain): [0,0,0,-1,0];
			attribute<bool>    isZeroInt8         (Domain): [0,0,0,0,-1];
			attribute<bool>    isZerofloat32      (Domain): [-1,0,0,0,0];
		}
		template Esource
		{
			// begin case parameters
			unit<uint32> Domain;
			// end case parameters
			parameter<bool>    BoolParam        := true;
			parameter<uint32>  IntegerParam     := 7;
			parameter<uint32>  IntegerZeroParam := 0;
			parameter<float64> FloatParam       := -999.99;
			parameter<string>  stringParam      := substr('hallo',0,0);

			attribute<uint8>   IntegerAtt         (Domain): [];
			attribute<int8>    SignedIntAtt       (Domain): [];
			attribute<float32> FloatAtt           (Domain): [];
			attribute<float32> DefFloatAtt        (Domain): [];
			attribute<bool>    BoolAtt            (Domain): [];
			attribute<string>  stringAtt          (Domain): [];
			attribute<uint8>   MakeDefineduint8   (Domain): [];
			attribute<float32> MakeDefinedfloat32 (Domain): [];
			attribute<bool>    MakeDefinedBool    (Domain): [];
			attribute<string>  MakeDefinedstring  (Domain): [];
			attribute<bool>    isDefineduint8     (Domain): [];
			attribute<bool>    isDefinedfloat32   (Domain): [];
			attribute<bool>    isDefinedBool      (Domain): [];
			attribute<bool>    isDefinedstring    (Domain): [];
			attribute<bool>    isNullUint8        (Domain): [];
			attribute<bool>    isNullfloat32      (Domain): [];
			attribute<bool>    isNullBool         (Domain): [];
			attribute<bool>    isNullstring       (Domain): [];
			attribute<bool>    isPositiveint8     (Domain): [];
			attribute<bool>    isPositivefloat32  (Domain): [];
			attribute<bool>    isNegativeint8     (Domain): [];
			attribute<bool>    isNegativefloat32  (Domain): [];
			attribute<bool>    isZeroInt8         (Domain): [];
			attribute<bool>    isZerofloat32      (Domain): [];
		}

		container UnTiled  := Template(ADomain,srcDomain);
		container Tiled    := Template(ATiledDomain,srcTiledDomain);
		container EUnTiled := Template(EDomain,srcEDomain);
		container ETiled   := Template(ETiledDomain,srcETiledDomain);
	
		Template Template
		{
			unit<uint32> Domain;
			container source;

			container MakeDefined: url = "http://www.objectvision.nl/geodms/operators-a-functions/predicates/makedefined"
			{
				attribute<uint8>   att_int     (Domain) := MakeDefined(source/IntegerAtt, uint8(0));
				attribute<bool>    test_int    (Domain) := att_int = Source/makeDefineduint8;
				attribute<float32> att_float   (Domain) := MakeDefined(source/FloatAtt, float32(0.0));
				attribute<bool>    test_float  (Domain) := att_float = Source/makeDefinedfloat32;
				attribute<string>  att_string  (Domain) := MakeDefined(source/stringAtt, 'test');
				attribute<bool>    test_string (Domain) := att_string = Source/makeDefinedstring;
				attribute<bool>    test        (Domain) := test_int && test_float && test_string;
				parameter<bool>    test_attr            := all(test);
			}
			container IsDefined: url = "http://www.objectvision.nl/geodms/operators-a-functions/predicates/isdefined"
			{
				parameter<bool> test_param           := isDefined(source/IntegerParam) && isDefined(source/FloatParam) && isDefined(source/stringParam);
				attribute<bool> att_int     (Domain) := IsDefined(source/IntegerAtt);
				attribute<bool> test_int    (Domain) := att_int = source/IsDefineduint8;
				attribute<bool> att_float   (Domain) := IsDefined(source/FloatAtt);
				attribute<bool> test_float  (Domain) := att_float = source/IsDefinedfloat32;
				attribute<bool> att_string  (Domain) := IsDefined(source/stringAtt);
				attribute<bool> test_string (Domain) := att_string = source/IsDefinedstring;
				attribute<bool> test        (Domain) := test_int && test_float && test_string;
				parameter<bool> test_attr            := all(test);
			}
			container IsNull: url = "http://www.objectvision.nl/geodms/operators-a-functions/predicates/isnull"
			{
				parameter<bool> test_param           := isDefined(source/IntegerParam) && isDefined(source/FloatParam) && isDefined(source/stringParam);
				attribute<bool> att_int     (Domain) := IsNull(source/IntegerAtt);
				attribute<bool> test_int    (Domain) := att_int = source/IsNulluint8;
				attribute<bool> att_float   (Domain) := IsNull(source/FloatAtt);
				attribute<bool> test_float  (Domain) := att_float = source/IsNullfloat32;
				attribute<bool> att_string  (Domain) := IsNull(source/stringAtt);
				attribute<bool> test_string (Domain) := att_string = source/IsNullstring;
				attribute<bool> test        (Domain) := test_int && test_float && test_string;
				parameter<bool> test_attr            := all(test);
			}
			container IsPositive: url = "http://www.objectvision.nl/geodms/operators-a-functions/predicates/ispositive"
			{
				parameter<bool> test_param          := isPositive(int32(source/IntegerParam)) && not(isPositive(source/FloatParam));
				attribute<bool> att_int    (Domain) := isPositive(source/SignedIntAtt);
				attribute<bool> test_int   (Domain) := att_int = source/isPositiveint8;
				attribute<bool> att_float  (Domain) := isPositive(source/FloatAtt);
				attribute<bool> test_float (Domain) := att_float = source/isPositivefloat32;
				attribute<bool> test       (Domain) := test_int && test_float;
				parameter<bool> test_attr           := all(test);
			}
			container IsNegative: url = "http://www.objectvision.nl/geodms/operators-a-functions/predicates/isnegative"
			{
				parameter<bool> test_param          := not(isNegative(int32(source/IntegerParam))) && isNegative(source/FloatParam);
				attribute<bool> att_int    (Domain) := isNegative(source/SignedIntAtt);
				attribute<bool> test_int   (Domain) := att_int = source/isNegativeint8;
				attribute<bool> att_float  (Domain) := isNegative(source/FloatAtt);
				attribute<bool> test_float (Domain) := att_float = source/isNegativefloat32;
				attribute<bool> test       (Domain) := test_int && test_float;
				parameter<bool> test_attr           := all(test);
			}
			container IsZero: url = "http://www.objectvision.nl/geodms/operators-a-functions/predicates/iszero"
			{
				parameter<bool> test_param          := isZero(int32(source/IntegerZeroParam)) && isZero(uint32(source/IntegerZeroParam));
				attribute<bool> att_int    (Domain) := isZero(source/SignedIntAtt);
				attribute<bool> test_int   (Domain) := att_int = source/isZeroint8;
				attribute<bool> att_float  (Domain) := isZero(source/FloatAtt);
				attribute<bool> test_float (Domain) := att_float = source/isZerofloat32;
				attribute<bool> test       (Domain) := test_int && test_float;
				parameter<bool> test_attr           := all(test);
			}
			container results
			{
				parameter<bool> test_params := 
							   IsDefined/test_param 
							&& IsNull/test_param 
							&& IsPositive/test_param 
							&& IsNegative/test_param 
							&& IsZero/test_param;
				parameter<bool> test_attrs := 
							    MakeDefined/test_attr 
							&& IsDefined/test_attr 
							&& IsNull/test_attr 
							&& IsPositive/test_attr 
							&& IsNegative/test_attr 
							&& IsZero/test_attr;
				parameter<bool> tests := test_params && test_attrs;
			}
		}
	}
	container Logical
	{
		container srcDomain       := source(ADomain);
		container srcEDomain      := Esource(EDomain);

		container srcTiledDomain  := source(ATiledDomain);
		container srcETiledDomain := Esource(ETiledDomain);

		template source
		{
			unit<uint32> Domain;

			parameter<bool>    ParamTrue  := true;
			parameter<bool>    ParamFalse := false;

			attribute<float32> floatA     (Domain): [0,1,2,3,null];
			attribute<float32> floatB     (Domain): [2,2,2,2,2];

			attribute<uint8>   uint8A     (Domain): [0,1,2,3,null];
			attribute<uint8>   uint8B     (Domain): [2,2,2,2,2];
			attribute<int32>   int32A     (Domain): [0,1,2,3,null];

			attribute<bool>    A          (Domain): [0,0,-1,-1,0];
			attribute<bool>    B          (Domain): [0,-1,0,-1,-1];
			attribute<float32> iifA       (Domain): [0,0,1,1,0];
			attribute<bool>    andAB      (Domain): [0,0,0,-1,0];
			attribute<bool>    orAB       (Domain): [0,-1,-1,-1,-1];
			attribute<bool>    notA       (Domain): [-1,-1,0,0,-1];
			attribute<bool>    notUint8   (Domain): [-1,0,0,0,0];
			attribute<bool>    notInt32A  (Domain): [-1,0,0,0,0];

			attribute<bool>    none       (Domain): [0,0,0,0,0];
			attribute<string>  switchcase (Domain): ['A<B','A<B','A=B','A>B','Missing'];
			attribute<uint8>   bitandAB   (Domain): [0,0,2,2,null];
			attribute<uint8>   bitorAB    (Domain): [2,3,2,3,null];

			attribute<uint8>   complement (Domain): [null,254,253,252,null];
		}
		template Esource
		{
			unit<uint32> Domain;

			parameter<bool>    ParamTrue  := true;
			parameter<bool>    ParamFalse := false;

			attribute<float32> floatA     (Domain): [];
			attribute<float32> floatB     (Domain): [];

			attribute<uint8>   uint8A     (Domain): [];
			attribute<uint8>   uint8B     (Domain): [];
			attribute<int32>   int32A     (Domain): [];
			attribute<bool>    A          (Domain): [];
			attribute<bool>    B          (Domain): [];
			attribute<float32> iifA       (Domain): [];
			attribute<bool>    andAB      (Domain): [];
			attribute<bool>    orAB       (Domain): [];
			attribute<bool>    notA       (Domain): [];
			attribute<bool>    notUint8   (Domain): [];
			attribute<bool>    notInt32A  (Domain): [];

			attribute<bool>    none       (Domain): [];
			attribute<string>  switchcase (Domain): [];
			attribute<uint8>   bitandAB   (Domain): [];
			attribute<uint8>   bitorAB    (Domain): [];

			attribute<uint8>   complement (Domain): [];
		}

		container UnTiled  := Template(ADomain, srcDomain);
		container Tiled    := Template(ATiledDomain, srcTiledDomain);
		container EUnTiled := Template(EDomain, srcEDomain);
		container ETiled   := Template(ETiledDomain, srcETiledDomain);

		Template Template
		{
			unit<uint32> Domain;
			container source;

			container iif_op: url = "http://www.objectvision.nl/geodms/operators-a-functions/logical/iif"
			{
				parameter<bool>    test_param    := source/Paramtrue && not(source/ParamFalse) ? true : false;
				attribute<float32> att  (Domain) := source/floatA >= source/floatB ? float32(1) : float32(0);
				attribute<bool>    test (Domain) := att = source/iifA;
				parameter<bool>    test_attr     := all(test);
			}
			container iif: url = "http://www.objectvision.nl/geodms/operators-a-functions/logical/iif"
			{
				parameter<bool>    test_param    := iif(source/Paramtrue && not(source/ParamFalse), true, false);
				attribute<float32> att  (Domain) := iif(source/floatA >= source/floatB, float32(1), float32(0));
				attribute<bool>    test (Domain) := att = source/iifA;
				parameter<bool>    test_attr     := all(test);
			}
			container and_op: url = "http://www.objectvision.nl/geodms/operators-a-functions/logical/and"
			{
				parameter<bool> test_param    := source/Paramtrue && not(source/ParamFalse);
				attribute<bool> att  (Domain) := source/A && source/B;
				attribute<bool> test (Domain) := att = source/andAB;
				parameter<bool> test_attr     := all(test);
			}
			container and: url = "http://www.objectvision.nl/geodms/operators-a-functions/logical/and"
			{
				parameter<bool>  test_param          := and(source/Paramtrue && not(source/ParamFalse));
				attribute<bool>  att        (Domain) := and(source/A, source/B);
				attribute<bool>  test       (Domain) := att = source/andAB;
				attribute<uint8> att_uint8  (Domain) := and(source/uint8A);
				attribute<bool>  test_uint8 (Domain) := eq_or_both_null(att_uint8, source/uint8A);
				attribute<int32> att_int32  (Domain) := and(source/int32A);
				attribute<bool>  test_int32 (Domain) := eq_or_both_null(att_int32, source/int32A);

				parameter<bool> test_attr     := all(test) && all(test_uint8) && all(test_int32);
			}
			container or_op: url = "http://www.objectvision.nl/geodms/operators-a-functions/logical/or"
			{
				parameter<bool> test_param    := source/Paramtrue || source/ParamFalse;
				attribute<bool> att  (Domain) := source/A || source/B;
				attribute<bool> test (Domain) := att = source/orAB;
				parameter<bool> test_attr     := all(test);
			}
			container or: url = "http://www.objectvision.nl/geodms/operators-a-functions/logical/or"
			{
				parameter<bool>  test_param          := or(source/Paramtrue, source/ParamFalse);
				attribute<bool>  att        (Domain) := or(source/A, source/B);
				attribute<bool>  test       (Domain) := att = source/orAB;
				
				attribute<uint8> att_uint8  (Domain) := or(source/uint8A);
				attribute<bool>  test_uint8 (Domain) := eq_or_both_null(att_uint8, source/uint8A);
				attribute<int32> att_int32  (Domain) := or(source/int32A);
				attribute<bool>  test_int32 (Domain) := eq_or_both_null(att_int32, source/int32A);
				
				parameter<bool> test_attr            := all(test) && all(test_uint8) && all(test_int32);
			}
			container not_op: url = "http://www.objectvision.nl/geodms/operators-a-functions/logical/not"
			{
				parameter<bool> test_param    := !source/ParamFalse;
				attribute<bool> att  (Domain) := !source/A;
				attribute<bool> test (Domain) := att = source/notA;
				parameter<bool> test_attr     := all(test);
			}
			container not: url = "http://www.objectvision.nl/geodms/operators-a-functions/logical/not"
			{
				parameter<bool> test_param          := not(source/ParamFalse);
				attribute<bool> att        (Domain) := not(source/A);
				attribute<bool> test       (Domain) := att = source/notA;
				attribute<bool> att_uint8  (Domain) := not(source/uint8A);
				attribute<bool> test_uint8 (Domain) := att_uint8 = source/notUint8;
				attribute<bool> att_int32  (Domain) := not(source/int32A);
				attribute<bool> test_int32 (Domain) := att_int32 = source/notInt32A;

				parameter<bool> test_attr     := all(test) && all(test_uint8) && all(test_int32);
			}
			container bitand
			{
				parameter<bool>  test_param    :=!bitand(source/Paramtrue, source/ParamFalse);
				attribute<uint8> att  (Domain) := bitand(source/uint8A, source/uint8B);
				attribute<bool>  test (Domain) := eq_or_both_null(att, source/bitandAB);
				parameter<bool>  test_attr     := all(test);
			}
			container bitor
			{
				parameter<bool>  test_param    := bitor(source/Paramtrue, source/ParamFalse);
				attribute<uint8> att  (Domain) := bitor(source/uint8A, source/uint8B);
				attribute<bool>  test (Domain) := eq_or_both_null(att, source/bitorAB);
				parameter<bool>  test_attr     := all(test);
			}
			container complement
			{
				parameter<bool>   test_param    := complement(source/ParamFalse);
				attribute<uint8>  att  (Domain) := complement(source/uint8A);
				attribute<bool>   test (Domain) := eq_or_both_null(att,source/complement);
				parameter<bool>   test_attr     := all(test);
			}
			container switchcase: url  = "http://www.objectvision.nl/geodms/operators-a-functions/logical/switchcase"
			{
				attribute<string> att (Domain)
					 := switch(
						  case( Source/floatA < Source/floatB, 'A<B')
						, case( Source/floatA > Source/floatB, 'A>B')
						, case( Source/floatA = Source/floatB, 'A=B')
						, 'Missing'
						);
				attribute<bool> test (Domain) := att == source/switchcase;
				parameter<bool> test_attr     := all(test);
			}
			container results
			{
				parameter<bool> test_params := 
					   iif_op/test_param 
					&& iif/test_param 
					&& and_op/test_param 
					&& and/test_param 
					&& or_op/test_param 
					&& or/test_param 
					&& not_op/test_param 
					&& not/test_param 
					&& bitand/test_param
					&& bitor/test_param
					&& complement/test_param
					;
	
				parameter<bool> test_attrs :=
					   iif_op/test_attr 
					&& iif/test_attr 
					&& and_op/test_attr 
					&& and/test_attr 
					&& or_op/test_attr 
					&& or/test_attr 
					&& not_op/test_attr 
					&& not/test_attr 
					&& bitand/test_attr
					&& bitor/test_attr
					&& switchcase/test_attr
					&& complement/test_attr
					;
				parameter<bool> tests := test_params && test_attrs;
			}
		}
	}
	container Relational
	{
		container srcUnTiled2UnTiledDomain := Source(CityDomain      , RegionDomain      , CountryDomain,      RoadDomain);
		container srcUnTiled2TiledDomain   := Source(CityDomain      , RegionTiledDomain , CountryTiledDomain, RoadTiledDomain);
		container srcTiled2UnTiledDomain   := Source(CityTiledDomain , RegionDomain      , CountryDomain,      RoadDomain);
		container srcTiled2TiledDomain     := Source(CityTiledDomain , RegionTiledDomain , CountryTiledDomain, RoadTiledDomain);

		container srcEDomain               := ESource(EDomain        , EDomain           , EDomain,            Edomain);
		container srcETiledDomain          := ESource(ETiledDomain   , ETiledDomain      , ETiledDomain,       ETiledDomain);

		template Source
		{
			// begin case parameters
			unit<uint32> CityDomain;
			unit<uint32> RegionDomain;
			unit<uint32> CountryDomain;
			unit<uint32> RoadDomain;
			// end case parameters

			unit<uint32> Region := RegionDomain
			{
				attribute<Region>         RegionNr:                [0,1,2,3,4];
				attribute<DegreesCelsius> AvgDailyTemperature:     [12,11,null,14,13];
				attribute<RegionEK>       RegionCode:              [100,200,300,400,500];
				attribute<uint32>         indexTemp:               [2,1,0,4,3];
				attribute<uint32>         invertRegion:            [1,4,3,7,null];
				attribute<m>              length:                  [120,1750,500,null,1499];
				attribute<string>         year:                    ['1995','2005','2015','2025','2035'];
				attribute<uint32>         uniqueTst:               [100,200,300,400];
				attribute<CountryDomain>  CountryDomain_rel:       [0,0,1,1,2];
			}

			unit <uint32> City := CityDomain
			{
				attribute<DegreesCelsius> AvgDailyTemperature:     [12,11,null,11,14,null,14];
				attribute<RegionEK>       RegionCode:              [100,200,300,200,400,null,400];
				attribute<Region>         RegionNr:                [0,1,2,1,3,null,3];
				attribute<uint32>         indexTemp:               [3,6,2,4,1,5,7];
				attribute<uint32>         direct_indexTemp:        [2,5,1,3,0,4,6];
				attribute<uint32>         SubIndexTemp:            [3,6,2,4,1,5,7];
				attribute<m2>             area:                    [400,350,300,325,250,null,200];
			}

			unit <uint32> Road := RoadDomain
			{
				attribute<CountryDomain>  CountryDomain_rel:       [1,0,2];
			}

			attribute<uint32> Year (RegionDomain): [1990, 2000, 2010, 2020, 2030];

			unit<uint32> NoordHollandBigCities := range(BaseUnit('NHC',uint32), 0, 5)
			{
				attribute<string> CityNames: ['Amsterdam','Haarlem','Alkmaar','Zaanstad','Purmerend'];
			}
			unit<uint32> ZuidHollandBigCities := range(BaseUnit('ZHC',uint32), 0, 5)
			{
				attribute<string> CityNames: ['Rotterdam','DenHaag','Leiden','Dordrecht','Leiden'];
			}
			unit<uint32> Years := RegionDomain
			{
				attribute<string> Names: ['1995','2005','2015','2025','2035'];
			}
			unit<uint32> Years20thCentury := range(uint32, 1900, 1999);
			unit<uint32> FirstWorldWar :=range(uint32, 1914, 1918);
			unit<uint32> SecondWorldWar :=range(uint32, 1940, 1945);

			attribute<uint32> att_large (UDomain1) := const(2,UDomain1);
		}
		template ESource
		{
			// begin case parameters
			unit<uint32> CityDomain;
			unit<uint32> RegionDomain;
			unit<uint32> CountryDomain;
			unit<uint32> RoadDomain;
			// end case parameters

			unit<uint32> Region := RegionDomain
			{
				attribute<Region>         RegionNr:                [];
				attribute<DegreesCelsius> AvgDailyTemperature:     [];
				attribute<RegionEK>       RegionCode:              [];
				attribute<uint32>         indexTemp:               [];
				attribute<uint32>         invertRegion:            [];
				attribute<m>              length:                  [];
				attribute<string>         year:                    [];
				attribute<uint32>         uniqueTst:               [];
				attribute<CountryDomain>  CountryDomain_rel:       [];
			}

			unit <uint32> City := CityDomain
			{
				attribute<DegreesCelsius> AvgDailyTemperature:     [];
				attribute<RegionEK>       RegionCode:              [];
				attribute<Region>         RegionNr:                [];
				attribute<uint32>         indexTemp:               [];
				attribute<uint32>         direct_indexTemp:        [];
				attribute<uint32>         SubIndexTemp:            [];
				attribute<m2>             area:                    [];
			}

			unit <uint32> Road := RoadDomain
			{
				attribute<CountryDomain>  CountryDomain_rel:       [];
			}

			attribute<uint32> Year (RegionDomain): [];

			unit<uint32> NoordHollandBigCities : nrofrows = 0
			{
				attribute<string> CityNames: [];
			}
			unit<uint32> ZuidHollandBigCities : nrofrows = 0
			{
				attribute<string> CityNames: [];
			}
			unit<uint32> Years := RegionDomain
			{
				attribute<string> Names: [];
			}
			unit<uint32> Years20thCentury : nrofrows = 0;
			unit<uint32> FirstWorldWar    : nrofrows = 0;
			unit<uint32> SecondWorldWar   : nrofrows = 0;

			attribute<uint32> att_large (UDomain1) := const(2,UDomain1);
		}

		container UnTiled2UnTiled  := Template(srcUnTiled2UnTiledDomain/Region, srcUnTiled2UnTiledDomain/City, srcUnTiled2UnTiledDomain/Years, srcUnTiled2UnTiledDomain);
		container UnTiled2Tiled    := Template(srcUnTiled2TiledDomain/Region  , srcUnTiled2TiledDomain/City  , srcUnTiled2TiledDomain/Years  , srcUnTiled2TiledDomain);
		container Tiled2UnTiled    := Template(srcTiled2UnTiledDomain/Region  , srcTiled2UnTiledDomain/City  , srcTiled2UnTiledDomain/Years  , srcTiled2UnTiledDomain);
		container Tiled2Tiled      := Template(srcTiled2TiledDomain/Region    , srcTiled2TiledDomain/City    , srcTiled2TiledDomain/Years    , srcTiled2TiledDomain);

		container EunTiled         := Template(EDomain, EDomain, EDomain, srcEDomain);
		container ETiled           := Template(ETiledDomain, ETiledDomain, ETiledDomain, srcETiledDomain);

		container ResultUnitTiled
		{
			unit<uint32> src: nrofrows = 500000
			{
				attribute<ATiledDomain> ATiledDomain_rel := (float32(id(.)) / 100000f)[ATiledDomain];
			}
	
			unit<uint32> unique := unique(id(src))
			{
				parameter<bool> test_attr := max(values) = #. - 1 && values[25001] == 25001;
			}
			
			unit<uint32> combine := combine(src, ATiledDomain)
			{
				parameter<float32> mean_nr_1 : =mean(float32(nr_1));
				parameter<bool> test_attr := sum(nr_2) = 5000000 && float_isNearby(mean(float32(nr_1)), 250000f, dif_all_float32) && #. == 2500000 && nr_1[2265850] == 453170 && nr_2[2265850] == 0;
			}
			unit<uint32> join_equal_values:= join_equal_values(src/ATiledDomain_rel , id(ATiledDomain))
			{
				parameter<bool> test_attr := sum(nr_2_rel) = 1000000 && float_isNearby(mean(float32(nr_1_rel)), 249999.5f, dif_all_float32) && #. == 500000;
			}
		}

		Template Template
		{
			// begin case parameters
			unit<uint32> Region;
			unit<uint32> City;
			unit<uint32> Years;
			container Source;
			// end case parameters

			container id: url  = "http://www.objectvision.nl/geodms/operators-a-functions/id"
			{
				attribute<uint32> att  (Region) := ID(Region);
				attribute<bool>   test (Region) := att = Source/Region/RegionNr;
				parameter<bool>   test_attr            := all(test);
			}
			container mapping
			{
				attribute<Years>  years_rel (Region) := mapping(Region,Source/Years);
				attribute<string> att       (Region) := Source/Years/Names[years_rel];
				attribute<bool>   test      (Region) := att == Source/Region/year;
				parameter<bool>   test_attr                 := all(test);
			}
			container mapping_count
			{
				attribute<uint32>                    count              (Grid/units/GridDomain3000) := mapping_count(Grid/units/GridDomain15, Grid/units/GridDomain3000, uint32);
				attribute<uint16>                    count_uint16       (Grid/units/GridDomain3000) := mapping_count(Grid/units/GridDomain15, Grid/units/GridDomain3000, uint16);
				attribute<Grid/units/GridDomain3000> GridDomain3000_rel (Grid/units/GridDomain15)   := mapping(Grid/units/GridDomain15,Grid/units/GridDomain3000);
				attribute<uint32>                    pcount             (Grid/units/GridDomain3000) := pcount(GridDomain3000_rel);
				attribute<bool>                      test1              (Grid/units/GridDomain3000) := count == pcount;
				attribute<bool>                      test2              (Grid/units/GridDomain3000) := count_uint16 == uint16(pcount);
				attribute<bool>                      test               (Grid/units/GridDomain3000) := test1 && test2;
				parameter<bool>                      test_attr          := all(test);
			}
			container lookup_op: url  = "http://www.objectvision.nl/geodms/operators-a-functions/lookup"
			{
				attribute<DegreesCelsius> att  (City) := Source/Region/AvgDailyTemperature[Source/City/RegionNr];
				attribute<bool>           test (City) := eq_or_both_null(att, Source/City/AvgDailyTemperature);
				parameter<bool>           test_attr   := all(test);
			}
			container lookup: url  = "http://www.objectvision.nl/geodms/operators-a-functions/lookup"
			{
				attribute<DegreesCelsius> att  (City) := lookup(Source/City/RegionNr, Source/Region/AvgDailyTemperature);
				attribute<DegreesCelsius> att2 (City) := Source/City/RegionNr->AvgDailyTemperature; // arrow operator
				attribute<bool>           test (City) := eq_or_both_null(att, Source/City/AvgDailyTemperature);
				parameter<bool>           test_attr := all(test);
			}
			container rlookup: url  = "http://www.objectvision.nl/geodms/operators-a-functions/rlookup"
			{
				attribute<Region> att  (City) := rlookup(Source/City/RegionCode, Source/Region/RegionCode);
				attribute<bool>   test        (City) := eq_or_both_null(att, Source/City/RegionNr);
				parameter<bool>   test_attr   := all(test);
			}
			container rjoin: url  = "http://www.objectvision.nl/geodms/operators-a-functions/rjoin"
			{
				attribute<DegreesCelsius> att  (City) := rjoin(Source/City/RegionCode, Source/Region/RegionCode, Source/Region/AvgDailyTemperature);
				attribute<bool>           test (City) := eq_or_both_null(att, Source/City/AvgDailyTemperature);
				parameter<bool>           test_attr   := all(test);
			}

			container index: url = "http://www.objectvision.nl/geodms/operators-a-functions/index"
			{
				attribute<City> att  (City) := index(Source/City/AvgDailyTemperature);
				attribute<bool>        test (City) := att = Source/City/indexTemp;
				parameter<bool> test_attr   := all(test);
				attribute<DegreesCelsius> AvgDailyTemperature_sorted (City):= Source/City/AvgDailyTemperature[att];
				attribute<City> ranking  (City):= rlookup(Source/City/AvgDailyTemperature, AvgDailyTemperature_sorted);
				
			}
			container direct_index: url  = "http://www.objectvision.nl/geodms/operators-a-functions/direct_index"
			{
				attribute<uint32> att    (City) := direct_index(Source/City/AvgDailyTemperature);
				attribute<bool>   test   (City) := att = Source/City/direct_indexTemp;
				parameter<bool>   test_attr     := all(test);
			}
			/*
			container subindex: url  = "http://www.objectvision.nl/dms/Operator/Subindex.htm"
			{
				attribute<City>   att  (City) := subindex(index/att, City/RegionCode[index/att], City/AvgDailyTemperature);
				attribute<bool>   test (City) := att = City/SubIndexTemp;
				parameter<bool>   test_attr := all(test);
			}*/
			container invert: url  = "http://www.objectvision.nl/geodms/operators-a-functions/invert"
			{
				attribute<City>   att  (Region) := invert(Source/City/RegionNr);
				attribute<bool>   test        (Region) := eq_or_both_null(att, Source/Region/invertRegion);
				parameter<bool>   test_attr          := all(test);
			}
			/*
			container invert_all: url  = "http://www.objectvision.nl/dms/Operator/invert_all.htm"
			{
				attribute<uint32> att       (Region) := invert_all(City/RegionCode);
				//attribute<bool>   test      (Region) := eq_or_both_null(att, Region/invertRegion);
				//parameter<bool>   test_attr           := all(test);
			}*/
			container subset
			{
				unit<uint32> s_uint32 := subset(Source/City/RegionCode = 200)
				{
					attribute<bool> att  := const(200, ., uint32) = Source/City/RegionCode[nr_OrgEntity];
					parameter<bool> test := all(att);
				}

				unit<uint8>  u_uint8  : nrofrows = 1;
				unit<uint16> u_uint16 : nrofrows = 1;
				unit<uint64> u_uint64 : nrofrows = 1;
				unit<bool>   u_bool;
				
				unit<fpoint> rdc_m := range(fpoint, point(300000f,0f), point(625000f,280000f))
				,  label = "rijksdriehoekmeting in meters";
				
				unit<spoint> u_spoint := range(gridset(rdc_m,point(     -100f,     100f, rdc_m),point(625000f, 10000f, rdc_m),spoint),point(0s,0s),point(3250s, 2700s))
				{
					attribute<.> id := id(.);
				}
				unit<wpoint> u_wpoint := range(gridset(rdc_m,point(     -100f,     100f, rdc_m),point(625000f, 10000f, rdc_m),wpoint),point(0w,0w),point(3250w, 2700w))
				{
					attribute<.> id := id(.);
				}
				unit<ipoint> u_ipoint := range(gridset(rdc_m,point(     -100f,     100f, rdc_m),point(625000f, 10000f, rdc_m),ipoint),point(0i,0i),point(3250i, 2700i))
				{
					attribute<.> id := id(.);
				}
				unit<upoint> u_upoint := range(gridset(rdc_m,point(     -100f,     100f, rdc_m),point(625000f, 10000f, rdc_m),upoint),point(0u,0u),point(3250u, 2700u))
				{
					attribute<.> id := id(.);
				}

				unit<uint8> s_uint8 := subset(id(u_uint8) == 0b)
				{
					attribute<bool> att  := nr_OrgEntity == 0b;
					parameter<bool> test := all(att);
				}

				unit<uint16> s_uint16 := subset(id(u_uint16) == 0w)
				{
					attribute<bool> att  := nr_OrgEntity == 0w;
					parameter<bool> test := all(att);
				}

				unit<uint64> s_uint64 := subset(id(u_uint64) == 0u64)
				{
					attribute<bool> att  := nr_OrgEntity == 0u64;
					parameter<bool> test := all(att);
				}

				unit<uint32> s_bool := subset(id(u_bool) == True)
				{
					attribute<bool> att  := nr_OrgEntity == True;
					parameter<bool> test := all(att);
				}
				
				unit<uint32> s_spoint := subset(pointcol(id(u_spoint)) == 0s && pointrow(id(u_spoint)) == 0s)
				{
					attribute<bool> att  := pointcol(nr_OrgEntity) == 0s && pointrow(nr_OrgEntity) == 0s;
					parameter<bool> test := all(att);
				}
				unit<uint32> s_wpoint := subset(pointcol(id(u_wpoint)) == 0w && pointrow(id(u_wpoint)) == 0w)
				{
					attribute<bool> att  := pointcol(nr_OrgEntity) == 0w && pointrow(nr_OrgEntity) == 0w;
					parameter<bool> test := all(att);
				}
				unit<uint64> s_ipoint := subset(pointcol(id(u_ipoint)) == 0i && pointrow(id(u_ipoint)) == 0i)
				{
					attribute<bool> att  := pointcol(nr_OrgEntity) == 0i && pointrow(nr_OrgEntity) == 0i;
					parameter<bool> test := all(att);
				}
				unit<uint64> s_upoint := subset(pointcol(id(u_upoint)) == 0u && pointrow(id(u_upoint)) == 0u)
				{
					attribute<bool> att  := pointcol(nr_OrgEntity) == 0u && pointrow(nr_OrgEntity) == 0u;
					parameter<bool> test := all(att);
				}
				parameter<bool> test := s_uint32/test && s_uint8/test && s_uint16/test && s_uint64/test && s_bool/test && s_spoint/test && s_wpoint/test && s_ipoint/test && s_upoint/test;
			}
			container subset_uint32
			{
				unit<uint32> s_uint32 := subset_uint32(Source/City/RegionCode = 200)
				{
					attribute<bool> att  := const(200, ., uint32) = Source/City/RegionCode[nr_OrgEntity];
					parameter<bool> test := all(att);
				}

				unit<uint8>  u_uint8  : nrofrows = 1;
				unit<uint16> u_uint16 : nrofrows = 1;
				unit<uint64> u_uint64 : nrofrows = 1;
				unit<bool>   u_bool;
				
				unit<fpoint> rdc_m := range(fpoint, point(300000f,0f), point(625000f,280000f))
				,  label = "rijksdriehoekmeting in meters";
				
				unit<spoint> u_spoint := range(gridset(rdc_m,point(     -100f,     100f, rdc_m),point(625000f, 10000f, rdc_m),spoint),point(0s,0s),point(3250s, 2700s))
				{
					attribute<.> id := id(.);
				}
				unit<wpoint> u_wpoint := range(gridset(rdc_m,point(     -100f,     100f, rdc_m),point(625000f, 10000f, rdc_m),wpoint),point(0w,0w),point(3250w, 2700w))
				{
					attribute<.> id := id(.);
				}
				unit<ipoint> u_ipoint := range(gridset(rdc_m,point(     -100f,     100f, rdc_m),point(625000f, 10000f, rdc_m),ipoint),point(0i,0i),point(3250i, 2700i))
				{
					attribute<.> id := id(.);
				}
				unit<upoint> u_upoint := range(gridset(rdc_m,point(     -100f,     100f, rdc_m),point(625000f, 10000f, rdc_m),upoint),point(0u,0u),point(3250u, 2700u))
				{
					attribute<.> id := id(.);
				}

				unit<uint32> s_uint8 := subset_uint32(id(u_uint8) == 0b)
				{
					attribute<bool> att  := nr_OrgEntity == 0b;
					parameter<bool> test := all(att);
				}

				unit<uint32> s_uint16 := subset_uint32(id(u_uint16) == 0w)
				{
					attribute<bool> att  := nr_OrgEntity == 0w;
					parameter<bool> test := all(att);
				}

				unit<uint32> s_uint64 := subset_uint32(id(u_uint64) == 0u64)
				{
					attribute<bool> att  := nr_OrgEntity == 0u64;
					parameter<bool> test := all(att);
				}

				unit<uint32> s_bool := subset_uint32(id(u_bool) == True)
				{
					attribute<bool> att  := nr_OrgEntity == True;
					parameter<bool> test := all(att);
				}
				
				unit<uint32> s_spoint := subset_uint32(pointcol(id(u_spoint)) == 0s && pointrow(id(u_spoint)) == 0s)
				{
					attribute<bool> att  := pointcol(nr_OrgEntity) == 0s && pointrow(nr_OrgEntity) == 0s;
					parameter<bool> test := all(att);
				}
				unit<uint32> s_wpoint := subset_uint32(pointcol(id(u_wpoint)) == 0w && pointrow(id(u_wpoint)) == 0w)
				{
					attribute<bool> att  := pointcol(nr_OrgEntity) == 0w && pointrow(nr_OrgEntity) == 0w;
					parameter<bool> test := all(att);
				}
				unit<uint32> s_ipoint := subset_uint32(pointcol(id(u_ipoint)) == 0i && pointrow(id(u_ipoint)) == 0i)
				{
					attribute<bool> att  := pointcol(nr_OrgEntity) == 0i && pointrow(nr_OrgEntity) == 0i;
					parameter<bool> test := all(att);
				}
				unit<uint32> s_upoint := subset_uint32(pointcol(id(u_upoint)) == 0u && pointrow(id(u_upoint)) == 0u)
				{
					attribute<bool> att  := pointcol(nr_OrgEntity) == 0u && pointrow(nr_OrgEntity) == 0u;
					parameter<bool> test := all(att);
				}
				parameter<bool> test := s_uint32/test && s_uint8/test && s_uint16/test && s_uint64/test && s_bool/test && s_spoint/test && s_wpoint/test && s_ipoint/test && s_upoint/test;
			}
			container subset_uint16
			{
				unit<uint16> s_uint32 := subset_uint16(Source/City/RegionCode = 200)
				{
					attribute<bool> att  := const(200, ., uint32) = Source/City/RegionCode[nr_OrgEntity];
					parameter<bool> test := all(att);
				}

				unit<uint8>  u_uint8  : nrofrows = 1;
				unit<uint16> u_uint16 : nrofrows = 1;
				unit<uint64> u_uint64 : nrofrows = 1;
				unit<bool>   u_bool;
				
				unit<fpoint> rdc_m := range(fpoint, point(300000f,0f), point(625000f,280000f))
				,  label = "rijksdriehoekmeting in meters";
				
				unit<spoint> u_spoint := range(gridset(rdc_m,point(     -100f,     100f, rdc_m),point(625000f, 10000f, rdc_m),spoint),point(0s,0s),point(3250s, 2700s))
				{
					attribute<.> id := id(.);
				}
				unit<wpoint> u_wpoint := range(gridset(rdc_m,point(     -100f,     100f, rdc_m),point(625000f, 10000f, rdc_m),wpoint),point(0w,0w),point(3250w, 2700w))
				{
					attribute<.> id := id(.);
				}
				unit<ipoint> u_ipoint := range(gridset(rdc_m,point(     -100f,     100f, rdc_m),point(625000f, 10000f, rdc_m),ipoint),point(0i,0i),point(3250i, 2700i))
				{
					attribute<.> id := id(.);
				}
				unit<upoint> u_upoint := range(gridset(rdc_m,point(     -100f,     100f, rdc_m),point(625000f, 10000f, rdc_m),upoint),point(0u,0u),point(3250u, 2700u))
				{
					attribute<.> id := id(.);
				}

				unit<uint16> s_uint8 := subset_uint16(id(u_uint8) == 0b)
				{
					attribute<bool> att  := nr_OrgEntity == 0b;
					parameter<bool> test := all(att);
				}

				unit<uint16> s_uint16 := subset_uint16(id(u_uint16) == 0w)
				{
					attribute<bool> att  := nr_OrgEntity == 0w;
					parameter<bool> test := all(att);
				}

				unit<uint16> s_uint64 := subset_uint16(id(u_uint64) == 0u64)
				{
					attribute<bool> att  := nr_OrgEntity == 0u64;
					parameter<bool> test := all(att);
				}

				unit<uint16> s_bool := subset_uint16(id(u_bool) == True)
				{
					attribute<bool> att  := nr_OrgEntity == True;
					parameter<bool> test := all(att);
				}
				
				unit<uint16> s_spoint := subset_uint16(pointcol(id(u_spoint)) == 0s && pointrow(id(u_spoint)) == 0s)
				{
					attribute<bool> att  := pointcol(nr_OrgEntity) == 0s && pointrow(nr_OrgEntity) == 0s;
					parameter<bool> test := all(att);
				}
				unit<uint16> s_wpoint := subset_uint16(pointcol(id(u_wpoint)) == 0w && pointrow(id(u_wpoint)) == 0w)
				{
					attribute<bool> att  := pointcol(nr_OrgEntity) == 0w && pointrow(nr_OrgEntity) == 0w;
					parameter<bool> test := all(att);
				}
				unit<uint16> s_ipoint := subset_uint16(pointcol(id(u_ipoint)) == 0i && pointrow(id(u_ipoint)) == 0i)
				{
					attribute<bool> att  := pointcol(nr_OrgEntity) == 0i && pointrow(nr_OrgEntity) == 0i;
					parameter<bool> test := all(att);
				}
				unit<uint16> s_upoint := subset_uint16(pointcol(id(u_upoint)) == 0u && pointrow(id(u_upoint)) == 0u)
				{
					attribute<bool> att  := pointcol(nr_OrgEntity) == 0u && pointrow(nr_OrgEntity) == 0u;
					parameter<bool> test := all(att);
				}
				parameter<bool> test := s_uint32/test && s_uint8/test && s_uint16/test && s_uint64/test && s_bool/test && s_spoint/test && s_wpoint/test && s_ipoint/test && s_upoint/test;
			}
			container subset_uint8
			{
				unit<uint8> s_uint32 := subset_uint8(Source/City/RegionCode = 200)
				{
					attribute<bool> att  := const(200, ., uint32) = Source/City/RegionCode[nr_OrgEntity];
					parameter<bool> test := all(att);
				}

				unit<uint8>  u_uint8  : nrofrows = 1;
				unit<uint16> u_uint16 : nrofrows = 1;
				unit<uint64> u_uint64 : nrofrows = 1;
				unit<bool>   u_bool;
				
				unit<fpoint> rdc_m := range(fpoint, point(300000f,0f), point(625000f,280000f))
				,  label = "rijksdriehoekmeting in meters";
				
				unit<spoint> u_spoint := range(gridset(rdc_m,point(     -100f,     100f, rdc_m),point(625000f, 10000f, rdc_m),spoint),point(0s,0s),point(3250s, 2700s))
				{
					attribute<.> id := id(.);
				}
				unit<wpoint> u_wpoint := range(gridset(rdc_m,point(     -100f,     100f, rdc_m),point(625000f, 10000f, rdc_m),wpoint),point(0w,0w),point(3250w, 2700w))
				{
					attribute<.> id := id(.);
				}
				unit<ipoint> u_ipoint := range(gridset(rdc_m,point(     -100f,     100f, rdc_m),point(625000f, 10000f, rdc_m),ipoint),point(0i,0i),point(3250i, 2700i))
				{
					attribute<.> id := id(.);
				}
				unit<upoint> u_upoint := range(gridset(rdc_m,point(     -100f,     100f, rdc_m),point(625000f, 10000f, rdc_m),upoint),point(0u,0u),point(3250u, 2700u))
				{
					attribute<.> id := id(.);
				}

				unit<uint8> s_uint8 := subset_uint8(id(u_uint8) == 0b)
				{
					attribute<bool> att  := nr_OrgEntity == 0b;
					parameter<bool> test := all(att);
				}

				unit<uint8> s_uint16 := subset_uint8(id(u_uint16) == 0w)
				{
					attribute<bool> att  := nr_OrgEntity == 0w;
					parameter<bool> test := all(att);
				}

				unit<uint8> s_uint64 := subset_uint8(id(u_uint64) == 0u64)
				{
					attribute<bool> att  := nr_OrgEntity == 0u64;
					parameter<bool> test := all(att);
				}

				unit<uint8> s_bool := subset_uint8(id(u_bool) == True)
				{
					attribute<bool> att  := nr_OrgEntity == True;
					parameter<bool> test := all(att);
				}
				
				unit<uint8> s_spoint := subset_uint8(pointcol(id(u_spoint)) == 0s && pointrow(id(u_spoint)) == 0s)
				{
					attribute<bool> att  := pointcol(nr_OrgEntity) == 0s && pointrow(nr_OrgEntity) == 0s;
					parameter<bool> test := all(att);
				}
				unit<uint8> s_wpoint := subset_uint8(pointcol(id(u_wpoint)) == 0w && pointrow(id(u_wpoint)) == 0w)
				{
					attribute<bool> att  := pointcol(nr_OrgEntity) == 0w && pointrow(nr_OrgEntity) == 0w;
					parameter<bool> test := all(att);
				}
				unit<uint8> s_ipoint := subset_uint8(pointcol(id(u_ipoint)) == 0i && pointrow(id(u_ipoint)) == 0i)
				{
					attribute<bool> att  := pointcol(nr_OrgEntity) == 0i && pointrow(nr_OrgEntity) == 0i;
					parameter<bool> test := all(att);
				}
				unit<uint8> s_upoint := subset_uint8(pointcol(id(u_upoint)) == 0u && pointrow(id(u_upoint)) == 0u)
				{
					attribute<bool> att  := pointcol(nr_OrgEntity) == 0u && pointrow(nr_OrgEntity) == 0u;
					parameter<bool> test := all(att);
				}
				parameter<bool> test := s_uint32/test && s_uint8/test && s_uint16/test && s_uint64/test && s_bool/test && s_spoint/test && s_wpoint/test && s_ipoint/test && s_upoint/test;
			}

			container select_unit: url  = "http://www.objectvision.nl/geodms/operators-a-functions/select_unit"
			{
				unit<uint32> ZHCities := select_unit(Source/City/RegionCode = 200)
				{
					attribute<bool> att := const(200, ., uint32) = select_data(., Source/City/RegionCode = 200, Source/City/RegionCode);
				}
				parameter<bool> test := all(ZHCities/att);
			}

			container select_afew
			{
				unit<uint32> selection := select_afew(Source/City, Source/City/RegionCode = 200)
				{
					attribute<bool> att := AvgDailyTemperature == const(11[DegreesCelsius ],.) && RegionCode == const(200,.);
				}
				unit<uint32> select_subitems := SubItem_PropValues(selection,'name'); 
				parameter<bool> test := all(selection/att) && #select_subitems == 9;
			}
			container select_afew_uint32
			{
				unit<uint32> selection := select_afew_uint32(Source/City, Source/City/RegionCode = 200)
				{
					attribute<bool> att := AvgDailyTemperature == const(11[DegreesCelsius ],.) && RegionCode == const(200,.);
				}
				unit<uint32> select_subitems := SubItem_PropValues(selection,'name'); 
				parameter<bool> test := all(selection/att) && #select_subitems == 9;
			}
			container select_afew_uint16
			{
				unit<uint16> selection := select_afew_uint16(Source/City, Source/City/RegionCode = 200)
				{
					attribute<bool> att := AvgDailyTemperature == const(11[DegreesCelsius ],.) && RegionCode == const(200,.);
				}
				unit<uint32> select_subitems := SubItem_PropValues(selection,'name'); 
				parameter<bool> test := all(selection/att) && #select_subitems == 9;
			}
			container select_afew_uint8
			{
				unit<uint8> selection := select_afew_uint8(Source/City, Source/City/RegionCode = 200)
				{
					attribute<bool> att := AvgDailyTemperature == const(11[DegreesCelsius ],.) && RegionCode == const(200,.);
				}
				unit<uint32> select_subitems := SubItem_PropValues(selection,'name'); 
				parameter<bool> test := all(selection/att) && #select_subitems == 9;
			}
			
			container select_many
			{
				unit<uint32> selection := select_many(Source/City, Source/City/RegionCode = 200)
				{
					attribute<bool> att := AvgDailyTemperature == const(11[DegreesCelsius ],.) && RegionCode == const(200,.);
				}
				unit<uint32> select_subitems := SubItem_PropValues(selection,'name'); 
				parameter<bool> test := all(selection/att) && #select_subitems == 8;
			}
			container select_many_uint32
			{
				unit<uint32> selection := select_many_uint32(Source/City, Source/City/RegionCode = 200)
				{
					attribute<bool> att := AvgDailyTemperature == const(11[DegreesCelsius ],.) && RegionCode == const(200,.);
				}
				unit<uint32> select_subitems := SubItem_PropValues(selection,'name'); 
				parameter<bool> test := all(selection/att) && #select_subitems == 8;
			}
			container select_many_uint16
			{
				unit<uint16> selection := select_many_uint16(Source/City, Source/City/RegionCode = 200)
				{
					attribute<bool> att := AvgDailyTemperature == const(11[DegreesCelsius ],.) && RegionCode == const(200,.);
				}
				unit<uint32> select_subitems := SubItem_PropValues(selection,'name'); 
				parameter<bool> test := all(selection/att) && #select_subitems == 8;
			}
			container select_many_uint8
			{
				unit<uint8> selection := select_many_uint8(Source/City, Source/City/RegionCode = 200)
				{
					attribute<bool> att := AvgDailyTemperature == const(11[DegreesCelsius ],.) && RegionCode == const(200,.);
				}
				unit<uint32> select_subitems := SubItem_PropValues(selection,'name'); 
				parameter<bool> test := all(selection/att) && #select_subitems == 8;
			}

			container unique: url  = "http://www.objectvision.nl/geodms/operators-a-functions/unique"
			{
				unit<uint32>      Regions       := unique(Source/City/RegionCode)
				{
					attribute<uint32> att := Source/Region/uniqueTst[id(Regions)[Source/Region]];
				}
				parameter<bool>   test          := all(Regions/Values == Regions/att);
			}
			container union: url  = "http://www.objectvision.nl/geodms/operators-a-functions/union"
			{
				unit<uint32>    unit_ProvCity   := union(Source/NoordHollandBigCities/CityNames, Source/ZuidHollandBigCities/CityNames)
				{
					attribute<string> CityNamesWithEntries:   ['Amsterdam','Haarlem','Alkmaar','Zaanstad','Purmerend','Rotterdam','DenHaag','Leiden','Dordrecht','Leiden'];
					attribute<string> CityNamesWithoutEntries:[];
					attribute<string> CityNames:= = #(.) > 0 ? 'CityNamesWithEntries' : 'CityNamesWithoutEntries';
				}
				attribute<bool> test (unit_ProvCity) := unit_ProvCity/UnionData = unit_ProvCity/CityNames;
				parameter<bool> test_attr            := all(test);
			}
			container union_unit: url  = "http://www.objectvision.nl/geodms/operators-a-functions/union_unit"
			{
				unit<uint32>    unit_ProvCity        := union_unit(Source/NoordHollandBigCities, Source/ZuidHollandBigCities);

				unit<uint16>    unit_ProvCity_uint16 := union_unit_uint16(Source/NoordHollandBigCities, Source/ZuidHollandBigCities);
				unit<uint32>    unit_ProvCity_uint32 := union_unit_uint32(Source/NoordHollandBigCities, Source/ZuidHollandBigCities);
				unit<uint64>    unit_ProvCity_uint64 := union_unit_uint64(Source/NoordHollandBigCities, Source/ZuidHollandBigCities);
				unit<uint8>     unit_ProvCity_uint8  := union_unit_uint8(Source/NoordHollandBigCities, Source/ZuidHollandBigCities);

				parameter<bool> test_uint16 := sum(id(unit_ProvCity_uint16)) == 45w;
				parameter<bool> test_uint32 := sum(id(unit_ProvCity_uint32)) == 45u;
				parameter<bool> test_uint64 := sum(id(unit_ProvCity_uint64)) == 45u64;
				parameter<bool> test_uint8  := sum(id(unit_ProvCity_uint8))  == 45b;

				parameter<bool> test        := #(unit_ProvCity) > 0 
					? nrofrows(unit_ProvCity) = 10 && test_uint16 && test_uint32 && test_uint64 && test_uint8
					: nrofrows(unit_ProvCity) = 0;
			}
			
			container union_data: url = "http://www.objectvision.nl/geodms/operators-a-functions/union_data"
			{
				attribute<string> CityNamesSrcWithEntries    (union_unit/unit_ProvCity) : ['Amsterdam','Haarlem','Alkmaar','Zaanstad','Purmerend','Rotterdam','DenHaag','Leiden','Dordrecht','Leiden'];
				attribute<string> CityNamesSrcWithoutEntries (union_unit/unit_ProvCity) : [];
				attribute<string> CityNamesSrc               (union_unit/unit_ProvCity) := = #(union_unit/unit_ProvCity) > 0 ? 'CityNamesSrcWithEntries' : 'CityNamesSrcWithoutEntries';

				attribute<string> CityNames                  (union_unit/unit_ProvCity) := union_data(union_unit/unit_ProvCity, Source/NoordHollandBigCities/CityNames, Source/ZuidHollandBigCities/CityNames);
				attribute<bool>   test                       (union_unit/unit_ProvCity) := CityNames == CityNamesSrc;
				parameter<bool>   test_attr                                             := all(test);
			}
			container union_data_single
			{
				attribute<uint32> att  (UDomain2) := union_data(UDomain2, Source/att_large);
				attribute<bool>   test (UDomain2) := att == 2;
				parameter<bool>   test_attr       := all(test);
			}
			container combine: url  = "http://www.objectvision.nl/geodms/operators-a-functions/combine"
			{
				unit<uint32>    unit_CityForEachYear  := combine(Source/NoordHollandBigCities, Source/Years);
				
				unit<uint32>    unit_two_bools        : nrofrows = 4
				{
					attribute<bool> A: [True,True,False, False];
					attribute<bool> B: [True,False,True, False];
				}

				unit<uint16>    unit_CityForEachYear_uint16 := combine_uint16(Source/NoordHollandBigCities, Source/Years);
				unit<uint32>    unit_CityForEachYear_uint32 := combine_uint32(Source/NoordHollandBigCities, Source/Years);
				unit<uint64>    unit_CityForEachYear_uint64 := combine_uint64(Source/NoordHollandBigCities, Source/Years);
				unit<uint8>     unit_CityForEachYear_uint8  := combine_uint8(Source/NoordHollandBigCities, Source/Years);

				parameter<bool>  test_uint16 := sum(id(unit_CityForEachYear_uint16)) == 300w;
				parameter<bool>  test_uint32 := sum(id(unit_CityForEachYear_uint32)) == 300u;
				parameter<bool>  test_uint64 := sum(id(unit_CityForEachYear_uint64)) == 300u64;
				parameter<bool>  test_uint8_uint16  := sum(uint16(id(unit_CityForEachYear_uint8 ))) == 300w;
				parameter<uint8> sum_uint8  := sum(id(unit_CityForEachYear_uint8 ));
				parameter<bool>  test_uint8  := sum_uint8 == 44b;
				parameter<bool>  test_default := sum(unit_CityForEachYear/nr_1) == 50 && sum(unit_CityForEachYear/nr_2) == 50 && unit_CityForEachYear/nr_1[14]  ==  2 && unit_CityForEachYear/nr_2[14]  ==  4;
				
				parameter<bool> test        := #(unit_CityForEachYear) > 0 
					? test_default && test_uint16 && test_uint32 && test_uint64 && test_uint8 && test_uint8_uint16
					: nrofrows(unit_CityForEachYear) = 0;
			}
			container combine_data
			{
				attribute<combine/unit_CityForEachYear> CityForEachYear_rel (combine/unit_CityForEachYear) := 
					combine_data(combine/unit_CityForEachYear, combine/unit_CityForEachYear/nr_2, combine/unit_CityForEachYear/nr_1);

				attribute<combine/unit_CityForEachYear> att_two_bools (combine/unit_two_bools) := 
					combine_data(combine/unit_two_bools, combine/unit_two_bools/A, combine/unit_two_bools/B);

				attribute<uint32> okWithEntries    (combine/unit_CityForEachYear) : [0,5,10,15,20,1,6,11,16,21,2,7,12,17,22,3,8,13,18,23,4,9,14,19,24];
				attribute<uint32> okWithoutEntries (combine/unit_CityForEachYear) : [];
				attribute<uint32> ok               (combine/unit_CityForEachYear) := = #(combine/unit_CityForEachYear) > 0 ? 'okWithEntries' : 'okWithoutEntries';

				attribute<bool>   test_attr        (combine/unit_CityForEachYear) := CityForEachYear_rel == ok;
				parameter<bool>   test                                     := all(test_attr);
			}

			container merge
			{
				container src
				{
					unit<float32> eur;
					attribute<uint8> keuze       (ADomain) : [0,2,1,null,1];
					attribute<eur>   KostenAuto  (ADomain) : [18,28,38,48,58];
					attribute<eur>   KostenOv    (ADomain) : [15,25,35,45,55];
					attribute<eur>   KostenFiets (ADomain) : [12,22,32,42,52];
				}
				attribute<src/eur> KostenTransport (ADomain) := merge(src/keuze, src/eur, src/KostenAuto, src/KostenOv, src/KostenFiets);
				attribute<src/eur> ok              (ADomain) : [18,22,35,null,55];
				attribute<bool>    test_attr       (ADomain) := eq_or_both_null(KostenTransport, ok);
				parameter<bool>    test                      := all(test_attr);
			}

			container merge_empty
			{
				container src
				{
					unit<float32> eur;
					attribute<uint8> keuze       (EDomain) : [];
					attribute<eur>   KostenAuto  (EDomain) : [];
					attribute<eur>   KostenOv    (EDomain) : [];
					attribute<eur>   KostenFiets (EDomain) : [];
				}
				attribute<src/eur> KostenTransport (EDomain) := merge(src/keuze, src/eur, src/KostenAuto, src/KostenOv, src/KostenFiets);
				attribute<src/eur> ok              (EDomain) : [];
				attribute<bool>    test_attr       (EDomain) := eq_or_both_null(KostenTransport, ok);
				parameter<bool>    test                      := all(test_attr);
			}
			container join_equal_values
			{
				unit<uint32> Region_City := join_equal_values(Source/Region/CountryDomain_rel , Source/Road/CountryDomain_rel)
				{
					parameter<bool> isEmpty := #Region_City == 0;

					attribute<uint32> nr_1_rel_OK: [0,1,2,3,4];
					attribute<uint32> nr_2_rel_OK: [1,1,0,0,2];
					attribute<uint32> nr_X_rel_OK: [0,0,1,1,2];
					
					attribute<uint32> nr_1_rel_empty_OK: [];
					attribute<uint32> nr_2_rel_empty_OK: [];
					attribute<uint32> nr_X_rel_empty_OK: [];

					attribute<bool> test_nr_1_rel := = isEmpty ? 'nr_1_rel == nr_1_rel_empty_OK' : 'nr_1_rel == nr_1_rel_OK';
					attribute<bool> test_nr_2_rel := = isEmpty ? 'nr_2_rel == nr_2_rel_empty_OK' : 'nr_2_rel == nr_2_rel_OK';
					attribute<bool> test_nr_X_rel := = isEmpty ? 'nr_X_rel == nr_X_rel_empty_OK' : 'nr_X_rel == nr_X_rel_OK';

					parameter<bool> attr_test := all(test_nr_1_rel) && all(test_nr_2_rel) && all(test_nr_X_rel);
				}

				unit<uint8> Region_City_uint8 := join_equal_values_uint8(Source/Region/CountryDomain_rel , Source/Road/CountryDomain_rel)
				{
					parameter<bool> isEmpty := #Region_City == 0;

					attribute<uint32> nr_1_rel_OK: [0,1,2,3,4];
					attribute<uint32> nr_2_rel_OK: [1,1,0,0,2];
					attribute<uint32> nr_X_rel_OK: [0,0,1,1,2];
					
					attribute<uint32> nr_1_rel_empty_OK: [];
					attribute<uint32> nr_2_rel_empty_OK: [];
					attribute<uint32> nr_X_rel_empty_OK: [];

					attribute<bool> test_nr_1_rel := = isEmpty ? 'nr_1_rel == nr_1_rel_empty_OK' : 'nr_1_rel == nr_1_rel_OK';
					attribute<bool> test_nr_2_rel := = isEmpty ? 'nr_2_rel == nr_2_rel_empty_OK' : 'nr_2_rel == nr_2_rel_OK';
					attribute<bool> test_nr_X_rel := = isEmpty ? 'nr_X_rel == nr_X_rel_empty_OK' : 'nr_X_rel == nr_X_rel_OK';
					
					parameter<bool> attr_test := all(test_nr_1_rel) && all(test_nr_2_rel) && all(test_nr_X_rel);
				}

				unit<uint16> Region_City_uint16 := join_equal_values_uint16(Source/Region/CountryDomain_rel , Source/Road/CountryDomain_rel)
				{
					parameter<bool> isEmpty := #Region_City == 0;

					attribute<uint32> nr_1_rel_OK: [0,1,2,3,4];
					attribute<uint32> nr_2_rel_OK: [1,1,0,0,2];
					attribute<uint32> nr_X_rel_OK: [0,0,1,1,2];
					
					attribute<uint32> nr_1_rel_empty_OK: [];
					attribute<uint32> nr_2_rel_empty_OK: [];
					attribute<uint32> nr_X_rel_empty_OK: [];

					attribute<bool> test_nr_1_rel := = isEmpty ? 'nr_1_rel == nr_1_rel_empty_OK' : 'nr_1_rel == nr_1_rel_OK';
					attribute<bool> test_nr_2_rel := = isEmpty ? 'nr_2_rel == nr_2_rel_empty_OK' : 'nr_2_rel == nr_2_rel_OK';
					attribute<bool> test_nr_X_rel := = isEmpty ? 'nr_X_rel == nr_X_rel_empty_OK' : 'nr_X_rel == nr_X_rel_OK';
					
					parameter<bool> attr_test := all(test_nr_1_rel) && all(test_nr_2_rel) && all(test_nr_X_rel);
				}

				unit<uint32> Region_City_uint32 := join_equal_values_uint32(Source/Region/CountryDomain_rel , Source/Road/CountryDomain_rel)
				{
					parameter<bool> isEmpty := #Region_City == 0;

					attribute<uint32> nr_1_rel_OK: [0,1,2,3,4];
					attribute<uint32> nr_2_rel_OK: [1,1,0,0,2];
					attribute<uint32> nr_X_rel_OK: [0,0,1,1,2];
					
					attribute<uint32> nr_1_rel_empty_OK: [];
					attribute<uint32> nr_2_rel_empty_OK: [];
					attribute<uint32> nr_X_rel_empty_OK: [];

					attribute<bool> test_nr_1_rel := = isEmpty ? 'nr_1_rel == nr_1_rel_empty_OK' : 'nr_1_rel == nr_1_rel_OK';
					attribute<bool> test_nr_2_rel := = isEmpty ? 'nr_2_rel == nr_2_rel_empty_OK' : 'nr_2_rel == nr_2_rel_OK';
					attribute<bool> test_nr_X_rel := = isEmpty ? 'nr_X_rel == nr_X_rel_empty_OK' : 'nr_X_rel == nr_X_rel_OK';

					parameter<bool> attr_test := all(test_nr_1_rel) && all(test_nr_2_rel) && all(test_nr_X_rel);
				}

				unit<uint64> Region_City_uint64 := join_equal_values_uint64(Source/Region/CountryDomain_rel , Source/Road/CountryDomain_rel)
				{
					parameter<bool> isEmpty := #Region_City == 0;

					attribute<uint32> nr_1_rel_OK: [0,1,2,3,4];
					attribute<uint32> nr_2_rel_OK: [1,1,0,0,2];
					attribute<uint32> nr_X_rel_OK: [0,0,1,1,2];
					
					attribute<uint32> nr_1_rel_empty_OK: [];
					attribute<uint32> nr_2_rel_empty_OK: [];
					attribute<uint32> nr_X_rel_empty_OK: [];

					attribute<bool> test_nr_1_rel := = isEmpty ? 'nr_1_rel == nr_1_rel_empty_OK' : 'nr_1_rel == nr_1_rel_OK';
					attribute<bool> test_nr_2_rel := = isEmpty ? 'nr_2_rel == nr_2_rel_empty_OK' : 'nr_2_rel == nr_2_rel_OK';
					attribute<bool> test_nr_X_rel := = isEmpty ? 'nr_X_rel == nr_X_rel_empty_OK' : 'nr_X_rel == nr_X_rel_OK';

					parameter<bool> attr_test := all(test_nr_1_rel) && all(test_nr_2_rel) && all(test_nr_X_rel);
				}

				parameter<bool> attr_test := Region_City/attr_test && Region_City_uint8/attr_test && Region_City_uint16/attr_test && Region_City_uint32/attr_test && Region_City_uint64/attr_test;
			}

			container results
			{
				parameter<bool> tests := 
				   id/test_attr 
				&& mapping/test_attr 
				&& mapping_count/test_attr 
				&& lookup_op/test_attr 
				&& lookup/test_attr 
				&& rlookup/test_attr 
				&& rjoin/test_attr 
				&& index/test_attr 
				&& direct_index/test_attr 
				&& invert/test_attr 
				&& subset/test 
				&& subset_uint32/test 
				&& subset_uint16/test 
				&& subset_uint8/test 
				&& select_unit/test
				&& select_afew/test
				&& select_afew_uint32/test
				&& select_afew_uint32/test
				&& select_afew_uint32/test
				&& select_many/test
				&& select_many_uint32/test
				&& select_many_uint32/test
				&& select_many_uint32/test
				&& unique/test 
				&& union/test_attr 
				&& union_unit/test 
				&& union_data/test_attr 
				&& combine/test 
				&& combine_data/test 
				&& merge/test
				&& merge_empty/test
				&& join_equal_values/attr_test;
			}
		}
	}
	container Classify
	{
		container srcDomain       :=  Source(DistrictDomain);
		container srcEDomain      := ESource(EDomain);
		container srcTiledDomain  :=  Source(DistrictTiledDomain);
		container srcETiledDomain := ESource(ETiledDomain);
		
		template Source
		{
			// begin case parameters
			unit<uint32> DistrictDomain;
			// begin case parameters

			unit<uint32> District := DistrictDomain
			,	DialogType = "Map"
			,	DialogData = "Location"
			{
				attribute<nrPersons> NrInhabitants:
					[550,1025,300,200,0,null,300,2,20,55,860,1025,1025,100,750];
				attribute<point_rd> Location := point(float32(id(.)),float32(id(.)),point_rd);
			}

			unit<uint32> ClassDomain: nrofrows = 4
			{
				attribute<nrPersons> Classes
				:	DialogType = "Classification"
				,	[0,100,300,800];
				attribute<nrPersons> UniqueValues  : [0,2,20,55];
				attribute<nrPersons> EqualCount    : [0,55,300,860];
				attribute<nrPersons> EqualInterval : [0,341,683,1025];
				attribute<nrPersons> JenksFisher   : [0,200,550,860];
				attribute<nrPersons> NonzeroJenksFisher   : [0,2,300,750];
				
				attribute<nrPersons> LogInterval   : [0,10,100,1000];
			}

			unit<uint8>  ClassDomainOneClass: nrofrows = 1
			{
				attribute<nrPersons> ok
				:	DialogType = "Classification"
				,	[0];
			}

		}
		
		template ESource
		{
			// begin case parameters
			unit<uint32> DistrictDomain;
			// begin case parameters

			unit<uint32> District : nrofrows = 0
			{
				attribute<nrPersons> NrInhabitants: [];
				attribute<point_rd> Location := point(float32(id(.)),float32(id(.)),point_rd);
			}

			unit<uint32> ClassDomain: nrofrows = 0
			{
				attribute<nrPersons> Classes
				:	DialogType = "Classification"
				,	[];
				attribute<nrPersons> UniqueValues  : [];
				attribute<nrPersons> EqualCount    : [];
				attribute<nrPersons> EqualInterval : [];
				attribute<nrPersons> JenksFisher   : [];
				attribute<nrPersons> LogInterval   : [];
			}

			unit<uint8>  ClassDomainOneClass: nrofrows = 0
			{
				attribute<nrPersons> ok
				:	DialogType = "Classification"
				,	[];
			}
		}

		container UnTiled2UnTiled := Template(DistrictDomain      , ClassDomainManyClasses, srcDomain);
		container Tiled2UnTiled   := Template(DistrictTiledDomain , ClassDomainManyClasses, srcTiledDomain);
		
		container EUntiled := Template(EDomain, uint8(EDomain), srcEDomain);

		container ResultUnitTiled
		{
			attribute<nrPersons> att_many_classes  (point/ResultUnitTiled/dyna_point_tiled/CalcPoint) := ClassifyUniqueValues(id(point/ResultUnitTiled/dyna_point_tiled/CalcPoint), point/ResultUnitTiled/dyna_point_tiled/CalcPoint);
		}

		// To Tiled is not considedered relevant as the class units usually do not have a lot of elements
		// It is also not testable at the moment as the TileUnit function is not implemented for uint8. 

		Template Template
		{
			unit<uint32> DistrictDomain;
			unit<uint8>  ClassDomainManyClasses;

			container src;
			unit<uint32> District            := src/District;
			unit<uint32> ClassDomain         := src/ClassDomain;
			unit<uint8>  ClassDomainOneClass := src/ClassDomainOneClass;

			container Classify: url = "http://www.objectvision.hosting.it-rex.nl/geodms/operators-a-functions/Classify/Classify"
			{
				attribute<ClassDomain> att                 (District) := classify(District/NrInhabitants, ClassDomain/Classes);
				attribute<ClassDomain> att_okwithvalues    (District) : [2,3,2,1,0,null,2,0,0,0,3,3,3,1,2];
				attribute<ClassDomain> att_okwithoutvalues (District) : [];
				attribute<ClassDomain> att_ok              (District) := = #District == 0 ? 'att_okwithoutvalues' : 'att_okwithvalues';
				
				attribute<bool>        test   (District) := eq_or_both_null(att, att_ok); 
				parameter<bool>        test_attr         := all(test);
			}
			container ClassifyUniqueValues: url = "http://www.objectvision.hosting.it-rex.nl/geodms/operators-a-functions/Classify/ClassifyUniqueValues"
			{
				attribute<nrPersons> att_one_class       (ClassDomainOneClass) := ClassifyUniqueValues(District/NrInhabitants, ClassDomainOneClass);
				attribute<bool>      test_one_class      (ClassDomainOneClass) := eq_or_both_null(att_one_class, ClassDomainOneClass/ok);

				attribute<nrPersons> att                 (ClassDomain) := ClassifyUniqueValues(District/NrInhabitants, ClassDomain);
				attribute<bool>      test                (ClassDomain) := eq_or_both_null(att, ClassDomain/UniqueValues);

				attribute<nrPersons> att_many_classes                 (ClassDomainManyClasses) := ClassifyUniqueValues(District/NrInhabitants, ClassDomainManyClasses);
				attribute<nrPersons> att_many_classes_okwithvalues    (ClassDomainManyClasses) : [0,2,20,55,100,200,300,550,750,860,1025,1025,1025,1025,1025,1025,1025,1025,1025,1025];
				attribute<nrPersons> att_many_classes_okwithoutvalues (ClassDomainManyClasses) := const(0 /0 ,ClassDomainManyClasses) ;
				attribute<nrPersons> att_many_classes_ok              (ClassDomainManyClasses) := = #District == 0 ? 'att_many_classes_okwithoutvalues' : 'att_many_classes_okwithvalues';

				attribute<bool>      test_many_classes                (ClassDomainManyClasses) := eq_or_both_null(att_many_classes, att_many_classes_ok);

				parameter<bool>      test_attr := all(test_one_class) && all(test) && all(test_many_classes);
			}
			container ClassifyEqualCount: url = "http://www.objectvision.hosting.it-rex.nl/geodms/operators-a-functions/Classify/ClassifyEqualCount"
			{
				attribute<nrPersons> att_one_class       (ClassDomainOneClass) := ClassifyEqualCount(District/NrInhabitants, ClassDomainOneClass);
				attribute<bool>      test_one_class      (ClassDomainOneClass) := eq_or_both_null(att_one_class, ClassDomainOneClass/ok);

				attribute<nrPersons> att                 (ClassDomain) := ClassifyEqualCount(District/NrInhabitants, ClassDomain);
				attribute<bool>      test                (ClassDomain) := eq_or_both_null(att, ClassDomain/EqualCount);

				attribute<nrPersons> att_many_classes                 (ClassDomainManyClasses) := ClassifyEqualCount(District/NrInhabitants, ClassDomainManyClasses);
				attribute<nrPersons> att_many_classes_okwithvalues    (ClassDomainManyClasses) : [0,2,20,55,100,200,300,550,750,860,1025,1025,1025,1025,1025,1025,1025,1025,1025,1025];
				attribute<nrPersons> att_many_classes_okwithoutvalues (ClassDomainManyClasses) := const(0 /0 ,ClassDomainManyClasses) ;
				attribute<nrPersons> att_many_classes_ok              (ClassDomainManyClasses) := = #District == 0 ? 'att_many_classes_okwithoutvalues' : 'att_many_classes_okwithvalues';

				attribute<bool>      test_many_classes                (ClassDomainManyClasses) := eq_or_both_null(att_many_classes, att_many_classes_ok);

				parameter<bool>      test_attr := all(test_one_class) && all(test) && all(test_many_classes);
			}
			container ClassifyEqualInterval: url = "http://www.objectvision.hosting.it-rex.nl/geodms/operators-a-functions/Classify/ClassifyEqualInterval"
			{
				attribute<nrPersons> att_one_class       (ClassDomainOneClass) := ClassifyEqualInterval(District/NrInhabitants, ClassDomainOneClass);
				attribute<bool>      test_one_class      (ClassDomainOneClass) := eq_or_both_null(att_one_class, ClassDomainOneClass/ok);

				attribute<nrPersons> att                 (ClassDomain) := ClassifyEqualInterval(District/NrInhabitants, ClassDomain);
				attribute<bool>      test                (ClassDomain) := eq_or_both_null(att, ClassDomain/EqualInterval);

				attribute<nrPersons> att_many_classes                 (ClassDomainManyClasses) := ClassifyEqualInterval(District/NrInhabitants, ClassDomainManyClasses);
				attribute<nrPersons> att_many_classes_okwithvalues    (ClassDomainManyClasses) : [0,53,107,161,215,269,323,377,431,485,539,593,647,701,755,809,863,917,971,1024];
				attribute<nrPersons> att_many_classes_okwithoutvalues (ClassDomainManyClasses) := const(0 /0 ,ClassDomainManyClasses) ;
				attribute<nrPersons> att_many_classes_ok              (ClassDomainManyClasses) := = #District == 0 ? 'att_many_classes_okwithoutvalues' : 'att_many_classes_okwithvalues';

				attribute<bool>      test_many_classes   (ClassDomainManyClasses) := eq_or_both_null(att_many_classes, att_many_classes_ok);

				parameter<bool>      test_attr := all(test_one_class) && all(test) && all(test_many_classes);

			}
			container ClassifyJenksFisher: url = "http://www.objectvision.hosting.it-rex.nl/geodms/operators-a-functions/Classify/ClassifyJenksFisher"
			{
				attribute<nrPersons> att_one_class       (ClassDomainOneClass) := ClassifyJenksFisher(District/NrInhabitants, ClassDomainOneClass);
				attribute<bool>      test_one_class      (ClassDomainOneClass) := eq_or_both_null(att_one_class, ClassDomainOneClass/ok);

				attribute<nrPersons> att                 (ClassDomain) := ClassifyJenksFisher(District/NrInhabitants, ClassDomain);
				attribute<bool>      test                (ClassDomain) := eq_or_both_null(att, ClassDomain/JenksFisher);

				attribute<nrPersons> att_many_classes                 (ClassDomainManyClasses) := ClassifyJenksFisher(District/NrInhabitants, ClassDomainManyClasses);
				attribute<nrPersons> att_many_classes_okwithvalues    (ClassDomainManyClasses) : [0,2,20,55,100,200,300,550,750,860,1025,1025,1025,1025,1025,1025,1025,1025,1025,1025];
				attribute<nrPersons> att_many_classes_okwithoutvalues (ClassDomainManyClasses) := const(0 /0 ,ClassDomainManyClasses) ;
				attribute<nrPersons> att_many_classes_ok              (ClassDomainManyClasses) := = #District == 0 ? 'att_many_classes_okwithoutvalues' : 'att_many_classes_okwithvalues';

				attribute<bool>      test_many_classes   (ClassDomainManyClasses) := eq_or_both_null(att_many_classes, att_many_classes_ok);

				parameter<bool>      test_attr := all(test_one_class) && all(test) && all(test_many_classes);

			}
			container ClassifyNonzeroJenksFisher 
			{
				attribute<nrPersons> att_one_class       (ClassDomainOneClass) := ClassifyNonzeroJenksFisher (District/NrInhabitants, ClassDomainOneClass);
				attribute<bool>      test_one_class      (ClassDomainOneClass) := eq_or_both_null(att_one_class, ClassDomainOneClass/ok);

				attribute<nrPersons> att                 (ClassDomain) := ClassifyNonzeroJenksFisher (District/NrInhabitants, ClassDomain);
				attribute<bool>      test                (ClassDomain) := eq_or_both_null(att, ClassDomain/NonzeroJenksFisher);

				attribute<nrPersons> att_many_classes                 (ClassDomainManyClasses) := ClassifyNonzeroJenksFisher (District/NrInhabitants, ClassDomainManyClasses);
				attribute<nrPersons> att_many_classes_okwithvalues    (ClassDomainManyClasses) : [0,2,20,55,100,200,300,550,750,860,1025,1025,1025,1025,1025,1025,1025,1025,1025,1025];
				attribute<nrPersons> att_many_classes_okwithoutvalues (ClassDomainManyClasses) := const(0 /0 ,ClassDomainManyClasses) ;
				attribute<nrPersons> att_many_classes_ok              (ClassDomainManyClasses) := = #District == 0 ? 'att_many_classes_okwithoutvalues' : 'att_many_classes_okwithvalues';

				attribute<bool>      test_many_classes   (ClassDomainManyClasses) := eq_or_both_null(att_many_classes, att_many_classes_ok);

				parameter<bool>      test_attr := all(test_one_class) && all(test) && all(test_many_classes);

			}
			container ClassifyLogInterval: url = "http://www.objectvision.hosting.it-rex.nl/geodms/operators-a-functions/Classify/ClassifyLogInterval"
			{
				attribute<nrPersons> att_one_class       (ClassDomainOneClass) := ClassifyLogInterval(District/NrInhabitants, ClassDomainOneClass);
				attribute<bool>      test_one_class      (ClassDomainOneClass) := eq_or_both_null(att_one_class, ClassDomainOneClass/ok);

				attribute<nrPersons> att                 (ClassDomain) := ClassifyLogInterval(District/NrInhabitants, ClassDomain);
				attribute<bool>      test                (ClassDomain) := eq_or_both_null(att, ClassDomain/LogInterval);

				attribute<nrPersons> att_many_classes                 (ClassDomainManyClasses) := ClassifyLogInterval(District/NrInhabitants, ClassDomainManyClasses);
				attribute<nrPersons> att_many_classes_okwithvalues    (ClassDomainManyClasses) : [0,2,5,10,20,50,100,200,500,1000,1000,1000,1000,1000,1000,1000,1000,1000,1000,1000];
				attribute<nrPersons> att_many_classes_okwithoutvalues (ClassDomainManyClasses) := const(0 /0 ,ClassDomainManyClasses) ;
				attribute<nrPersons> att_many_classes_ok              (ClassDomainManyClasses) := = #District == 0 ? 'att_many_classes_okwithoutvalues' : 'att_many_classes_okwithvalues';

				attribute<bool>      test_many_classes   (ClassDomainManyClasses) := eq_or_both_null(att_many_classes, att_many_classes_ok);

				parameter<bool>      test_attr := all(test_one_class) && all(test) && all(test_many_classes);
			}
			container results
			{
				parameter<bool> tests := 
					   Classify/test_attr 
					&& ClassifyUniqueValues/test_attr 
					&& ClassifyEqualCount/test_attr 
					&& ClassifyEqualInterval/test_attr 
					&& ClassifyJenksFisher/test_attr 
					&& ClassifyLogInterval/test_attr ;
			}
		}
	}
	container Rescale
	{
		container srcUnTiled2UnTiled := Source(RegionDomain, CityDomain);
		container srcUntiled2Tiled   := Source(RegionDomain,CityTiledDomain);
		container srcTiled2UnTiled   := Source(RegionTiledDomain,CityTiledDomain);
		container srcTiled2Tiled     := Source(RegionTiledDomain,CityTiledDomain);

		container srcEUnTiled        := ESource(EDomain,EDomain);
		container srcETiled          := ESource(ETiledDomain,ETiledDomain);

		template source
		{
			unit<uint32> RegionDomain;
			unit<uint32> CityDomain;

			unit<uint32> Region := RegionDomain
			{
				attribute<uint32>  sumNrInhabitants : [550,1025,300,200,0];
				attribute<uint32>  timestamp        : [2000,2002,2004,2006,2008];
				attribute<float32> quantity_source  : [1500,2000,2400.3,2750,2820];
			}
			unit<uint32> City := CityDomain
			{
				attribute<DegreesCelsius> AvgDailyTemperature:    [12,11,null,11,14,null,14];
				attribute<uint32>         LifeStyleCode:          [2,0,1,0,1,1,null];
				attribute<uint32>         NrInhabitants:          [550,525,300,500,200,175,null];
				attribute<string>         RegionName:             ['NoordHolland','ZuidHolland','Utrecht','ZuidHolland','NoordBrabant',null,null];
				attribute<Region>         RegionNr:               [0,1,2,1,3,null,3];
				attribute<m2>             area:                   [400,350,300,325,250,null,200];
				attribute<uint32>         scalesum2NrInhabitants: [120,105,90,97,75,null,60];
				attribute<uint32>         scalesum3NrInhabitants: [550,531,300,493,111,null,88];
				attribute<float32>        RescaleNrInhabitants:   [10,9.4,4,8.8,1.6,1,null];
				attribute<float32>        NormalizeNrInhabitants: [1.12572,0.964901,-0.482451,0.804084,-1.12572,-1.28654,null];
				attribute<uint32>         yr:                     [ 2000  , 2001  ,  2002, 2003   , 2004  , 2005   ,2006];
				attribute<float32>        quantity_interpolated:  [ 1500.0, 1750.0,  2000, 2200.15, 2400.3, 2575.15,2750];
				attribute<uint32>         ramp:                   [0,11,23,35,46,58,70];
				attribute<uint32>         ramp_open:              [0,10,20,30,40,50,60];
				attribute<uint32>         ramp_rgb:               [65280,2806784,5614080,8355584,11162880,13904384,16711680];
				attribute<uint32>         ramp_open_rgb:          [65535,65498,65462,65425,65389,65352,65316];
			}
		}
		template Esource
		{
			unit<uint32> RegionDomain;
			unit<uint32> CityDomain;

			unit<uint32> Region := RegionDomain
			{
				attribute<uint32>  sumNrInhabitants : [];
				attribute<uint32>  timestamp        : [];
				attribute<float32> quantity_source  : [];
			}
			unit<uint32> City := CityDomain
			{
				attribute<DegreesCelsius> AvgDailyTemperature:    [];
				attribute<uint32>         LifeStyleCode:          [];
				attribute<uint32>         NrInhabitants:          [];
				attribute<string>         RegionName:             [];
				attribute<Region>         RegionNr:               [];
				attribute<m2>             area:                   [];
				attribute<uint32>         scalesum2NrInhabitants: [];
				attribute<uint32>         scalesum3NrInhabitants: [];
				attribute<float32>        RescaleNrInhabitants:   [];
				attribute<float32>        NormalizeNrInhabitants: [];
				attribute<uint32>         yr:                     [];
				attribute<float32>        quantity_interpolated:  [];
				attribute<uint32>         ramp:                   [];
				attribute<uint32>         ramp_open:              [];
				attribute<uint32>         ramp_rgb:               [];
				attribute<uint32>         ramp_open_rgb:          [];
			}
		}
		
		container UnTiled2UnTiled := Template(RegionDomain,CityDomain, srcUnTiled2UnTiled);
		container Untiled2Tiled   := Template(RegionDomain,CityTiledDomain, srcUntiled2Tiled);
		container Tiled2UnTiled   := Template(RegionTiledDomain,CityDomain, srcTiled2UnTiled);
		container Tiled2Tiled     := Template(RegionTiledDomain,CityTiledDomain, srcTiled2Tiled);
		container Euntiled        := Template(EDomain,EDomain, srcEUnTiled);
		container ETiled          := Template(ETiledDomain,ETiledDomain, srcETiled);

		Template Template
		{
			// begin case parameters
			unit<uint32> RegionDomain;
			unit<uint32> CityDomain;
			container src;
			// end case parameters

			unit<uint32> Region := src/Region;
			unit<uint32> City   := src/City;

			container scalesum2: url = "http://www.objectvision.hosting.it-rex.nl/geodms/operators-a-functions/rescale/scalesum"
			{
				attribute<uint32> att  (City) := uint32(scalesum(City/Area, 550f));
				attribute<bool>   test (City) := eq_or_both_null(att, City/scalesum2NrInhabitants); 
				parameter<bool>   test_attr   := all(test);
			}
			container scalesum3: url = "http://www.objectvision.hosting.it-rex.nl/geodms/operators-a-functions/rescale/scalesum"
			{
				attribute<uint32>  att  (City) := uint32(scalesum(City/Area, City/RegionNr, float32(Region/sumNrInhabitants)));
				attribute<bool>    test (City) := eq_or_both_null(att, City/scalesum3NrInhabitants); 
				parameter<bool>    test_attr   := all(test);
			}
			container rescale: url = "http://www.objectvision.hosting.it-rex.nl/geodms/operators-a-functions/rescale/rescale"
			{
				// De volgende integer varianten geven geen bruikbare resultaten
				attribute<uint32>  att1 (City) := rescale(City/NrInhabitants, 1, 10 );
				attribute<uint32>  att5 (City) := rescale(City/NrInhabitants, 5, 10 );
				attribute<float32> att  (City) := rescale(float32(City/NrInhabitants), float32(1), float32(10));
				attribute<float32> att_0_1  (City) := rescale(float32(City/NrInhabitants), float32(0), float32(1));

				attribute<bool>    test (City) := eq_or_both_null(att, City/RescaleNrInhabitants); 
				parameter<bool>    test_attr   := all(test);
			}
			container normalize: url = "http://www.objectvision.hosting.it-rex.nl/geodms/operators-a-functions/rescale/normalize"
			{
				// De volgende integer varianten geven geen bruikbare resultaten
				attribute<uint32>  att1 (City) := normalize(City/NrInhabitants, 1, 10 );
				attribute<uint32>  att5 (City) := normalize(City/NrInhabitants, 5, 10 );
				attribute<float32> att  (City) := normalize(float32(City/NrInhabitants), float32(0), float32(1));
				attribute<bool>    test (City) := iif(id(City) <= 6, float_isNearby(att, City/NormalizeNrInhabitants, Dif_all_float32), IsNull(att)); 
				parameter<bool>    test_attr   := all(test);
			}
			container interpolate_linear: url  = "http://www.objectvision.hosting.it-rex.nl/geodms/operators-a-functions/rescale/interpolate_linear"
			{
				attribute<float32> att  (City) := interpolate_linear(City/yr, Region/timestamp, Region/quantity_source);
				attribute<bool>    test (City) := float_isNearby(att, City/quantity_interpolated, Dif_all_float32); 
				parameter<bool>    test_attr   := all(test);
			}
			container ramp
			{
				attribute<uint32> att (City) := ramp(0,70,City), DialogType = "BrushColor";
				attribute<bool>   test(City) := eq_or_both_null(att, City/ramp); 

				parameter<bool>   test_attr  := all(test);
			}
			container ramp_open
			{
				attribute<uint32> att  (City) := ramp_open(0,70,City), DialogType = "BrushColor";
				attribute<bool>   test (City) := eq_or_both_null(att, City/ramp_open); 

				parameter<bool>   test_attr   := all(test);
			}
			container ramp_rgb
			{
				attribute<uint32> BrushColor(City) := ramp_rgb(rgb(0,255,0), rgb(0, 0,255),City), DialogType = "BrushColor";
				attribute<bool>   test      (City) := eq_or_both_null(BrushColor, City/ramp_rgb); 

				parameter<bool>   test_attr        := all(test);
			}
			container ramp_open_rgb
			{
				attribute<uint32> BrushColor (City) := ramp_open_rgb(rgb(255,255,0), rgb(0, 255, 0),City), DialogType = "BrushColor";
				attribute<bool>   test       (City) := eq_or_both_null(BrushColor, City/ramp_open_rgb);

				parameter<bool>   test_attr         := all(test);
			}


			container results
			{
				parameter<bool> tests := 
					   scalesum2/test_attr 
					&& scalesum3/test_attr 
					&& rescale/test_attr 
					&& normalize/test_attr 
					&& interpolate_linear/test_attr
					&& ramp/test_attr
					&& ramp_open/test_attr
					&& ramp_rgb/test_attr
					&& ramp_open_rgb/test_attr
					;
			}
		}
	}
	container Constants
	{
		container srcDomain       := source(ADomain);
		container srcTiledDomain  := source(ATiledDomain);

		container srcEDomain      := Esource(EDomain);
		container srcETiledDomain := Esource(ETiledDomain);

		template source
		{
			// begin case parameters
			unit<uint32> Domain;
			// end case parameters

			parameter<bool>    ParamTrue    := true;
			parameter<bool>    ParamFalse   := false;
			parameter<uint32>  ParamNumeric := 7;

			attribute<bool>    Atrue         (Domain): [-1,-1,-1,-1,-1];
			attribute<bool>    Bfalse        (Domain): [0,0,0,0,0];
			attribute<uint32>  constInt      (Domain): [2,2,2,2,2];
			attribute<float32> constFloat    (Domain): [-4.5,-4.5,-4.5,-4.5,-4.5];
			attribute<bool>    constBool     (Domain): [-1,-1,-1,-1,-1];
			attribute<string>  conststring   (Domain): ['constant','constant','constant','constant','constant'];
		}
		template Esource
		{
			// begin case parameters
			unit<uint32> Domain;
			// end case parameters

			parameter<bool>    ParamTrue    := true;
			parameter<bool>    ParamFalse   := false;
			parameter<uint32>  ParamNumeric := 7;

			attribute<bool>    Atrue         (Domain): [];
			attribute<bool>    Bfalse        (Domain): [];
			attribute<uint32>  constInt      (Domain): [];
			attribute<float32> constFloat    (Domain): [];
			attribute<bool>    constBool     (Domain): [];
			attribute<string>  conststring   (Domain): [];
		}

		container UnTiled  := Template(ADomain     , srcDomain);
		container Tiled    := Template(ATiledDomain, srcTiledDomain);
		container EUnTiled := Template(EDomain     , srcEDomain);
		container ETiled   := Template(ETiledDomain, srcETiledDomain);

		Template Template
		{
			unit<uint32> Domain;
			container source;

			container const: url  = "http://www.objectvision.hosting.it-rex.nl/geodms/operators-a-functions/constants/const" 
			{
				parameter<bool>    test_param           := source/ParamNumeric = 7;
				attribute<uint32>  att_int     (Domain) := const(2, Domain);
				attribute<bool>    test_int    (Domain) := att_int = source/constInt;
				attribute<float32> att_float   (Domain) := const(-4.5f, Domain);
				attribute<bool>    test_float  (Domain) := att_float = source/constFloat;
				attribute<bool>    att_bool    (Domain) := const(true, Domain);
				attribute<bool>    test_bool   (Domain) := att_bool = source/constBool;
				attribute<string>  att_string  (Domain) := const('constant', Domain);
				attribute<bool>    test_string (Domain) := att_string = source/conststring;
				attribute<bool>    test        (Domain) := test_int &&  test_float &&  test_bool &&  test_string;
				parameter<bool>    test_attr            := all(test);
			}
			container const_3_arguments: url  = "http://www.objectvision.hosting.it-rex.nl/geodms/operators-a-functions/constants/const" 
			{
				parameter<bool>    test_param             := source/ParamNumeric = 7;
				attribute<uint32>  att_int     (Domain) := const(2, Domain, uint32);
				attribute<bool>    test_int    (Domain) := att_int = source/constInt;
				attribute<float32> att_float   (Domain) := const(-4.5, Domain, float32);
				attribute<bool>    test_float  (Domain) := att_float = source/constFloat;
				attribute<bool>    att_bool    (Domain) := const(true, Domain, bool);
				attribute<bool>    test_bool   (Domain) := att_bool = source/constBool;
				attribute<string>  att_string  (Domain) := const('constant', Domain, string);
				attribute<bool>    test_string (Domain) := att_string = source/conststring;
				attribute<bool>    test        (Domain) := test_int &&  test_float &&  test_bool &&  test_string;
				parameter<bool>    test_attr            := all(test);
			}
			container true_const: url  = "http://www.objectvision.hosting.it-rex.nl/geodms/operators-a-functions/constants/true"
			{
				parameter<bool> test_param    := source/Paramtrue = true;
				attribute<bool> test (Domain) := source/Atrue = true;
				parameter<bool> test_attr     := all(test);
			}
			container false_const: url  = "http://www.objectvision.hosting.it-rex.nl/geodms/operators-a-functions/constants/false"
			{
				parameter<bool> test_param    := source/Paramfalse = false;
				attribute<bool> test (Domain) := source/Bfalse = false;
				parameter<bool> test_attr     := all(test);
			}
			container pi: url  = "http://www.objectvision.hosting.it-rex.nl/geodms/operators-a-functions/constants/pi"
			{
				parameter<float64> param      := pi();
				parameter <bool>   test_param := float_isNearby(param, 3.14159265, Dif_all_float64);
			}
			container results
			{
				parameter<bool> test_params :=
					   const/test_param 
					&& const_3_arguments/test_param 
					&& true_const/test_param 
					&& false_const/test_param
					&& pi/test_param;

				parameter<bool> test_attrs := 
					   const/test_attr 
					&& const_3_arguments/test_attr 
					&& true_const/test_attr 
					&& false_const/test_attr ;
				parameter<bool> tests := test_params && test_attrs;
			}
		}
	}
	container Trigonometric
	{
		container srcDomain       := source(ADomain);
		container srcTiledDomain  := source(ATiledDomain);

		container srcEDomain      := Esource(EDomain);
		container srcETiledDomain := Esource(ETiledDomain);

		template source
		{
			// begin case parameters
			unit<uint32> Domain;
			// end case parameters

			attribute<float64> angles     (Domain): [0,30,45,420,null];
			attribute<float64> angles_rad (Domain):= angles * pi() / float64(180), DisableStorage = "True";
			attribute<float64> sin        (Domain): [0,0.5,0.707107,0.866025,null];
			attribute<float64> cos        (Domain): [1,0.866026,0.707107,0.5,null];
			attribute<float64> tan        (Domain): [0,0.57735,1,1.732051,null];
			attribute<float64> atan       (Domain): [0,0.52359,0.78539,1.04719,null];
		}

		template Esource
		{
			// begin case parameters
			unit<uint32> Domain;
			// end case parameters

			attribute<float64> angles     (Domain): [];
			attribute<float64> angles_rad (Domain):= angles * pi() / float64(180), DisableStorage = "True";
			attribute<float64> sin        (Domain): [];
			attribute<float64> cos        (Domain): [];
			attribute<float64> tan        (Domain): [];
			attribute<float64> atan       (Domain): [];
		}

		container UnTiled  := Template(ADomain     , srcDomain);
		container Tiled    := Template(ATiledDomain, srcTiledDomain);
		container EUnTiled := Template(EDomain     , srcEDomain);
		container ETiled   := Template(ETiledDomain, srcETiledDomain);

		Template Template
		{
			unit<uint32> Domain;
			container source;

			container sinus:
				Using = "Source",
				url = "http://www.objectvision.hosting.it-rex.nl/geodms/operators-a-functions/trigonometric/sin"
			{
				attribute<float64> att  (Domain) := sin(angles_rad);
				attribute<bool>    test (Domain) := float_isNearby(att, sin, Dif_all_float64);
				parameter<bool>    test_attr     := all(test);
			}
			container cosinus:
				Using = "Source",
				url = "http://www.objectvision.hosting.it-rex.nl/geodms/operators-a-functions/trigonometric/cos"
			{
				attribute<float64> att  (Domain) := cos(angles_rad);
				attribute<bool>    test (Domain) := float_isNearby(att, cos, Dif_all_float64);
				parameter<bool>    test_attr     := all(test);
			}
			container tangens:
				Using = "Source",
				url = "http://www.objectvision.hosting.it-rex.nl/geodms/operators-a-functions/trigonometric/tan"
			{
				attribute<float64> att  (Domain) := tan(angles_rad);
				attribute<bool>    test (Domain) := float_isNearby(att, tan, Dif_all_float64);
				parameter<bool>    test_attr     := all(test);
			}
			container arctangens:
				Using = "Source",
				url = "http://www.objectvision.hosting.it-rex.nl/geodms/operators-a-functions/trigonometric/atan"
			{
				attribute<float64> att  (Domain) := atan(tangens/att);
				attribute<bool>    test (Domain) := float_isNearby(att, atan, Dif_all_float64);
				parameter<bool>    test_attr     := all(test);
			}
			container results
			{
				parameter<bool> tests := 
					   sinus/test_attr
					&& cosinus/test_attr
					&& tangens/test_attr
					&& arctangens/test_attr ;
			}
		}
	}
	container Point
	{
		container srcUnTiled2Untiled  := Source(ADomain,      HDomain,      DistrictPointsDomain,      RDomain,      PandPointsDomain      , PandDomain);
		container srcTiled2Untiled    := Source(ATiledDomain, HDomain,      DistrictPointsTiledDomain, RDomain,      PandPointsTiledDomain , PandDomain);
		container srcUnTiled2Tiled    := Source(ADomain,      HTiledDomain, DistrictPointsDomain,      RTiledDomain, PandPointsDomain      , PandTiledDomain);
		container srcTiled2Tiled      := Source(ATiledDomain, HTiledDomain, DistrictPointsTiledDomain, RTiledDomain, PandPointsTiledDomain , PandTiledDomain);

		container EsrcUnTiled2Untiled := ESource(EDomain     , EDomain,      EDomain,      EDomain,      EDomain      , EDomain);
		container EsrcTiled2Untiled   := ESource(ETiledDomain, EDomain,      ETiledDomain, EDomain,      ETiledDomain , ETiledDomain);
		container EsrcUnTiled2Tiled   := ESource(EDomain,      ETiledDomain, EDomain,      ETiledDomain, EDomain      , ETiledDomain);
		container EsrcTiled2Tiled     := ESource(ETiledDomain, ETiledDomain, ETiledDomain, ETiledDomain, ETiledDomain , ETiledDomain);

		template Source
		{
			// begin case parameters
			unit<uint32> ODomain;
			unit<uint32> DDomain;
			unit<uint32> DistrictPointsDomain;
			unit<uint32> DistrictDomain;
			unit<uint32> PandPointsDomain;
			unit<uint32> PandDomain;
			// end case parameters

			unit<uint32> origin := ODomain
			,	DialogData  = "location"
			,	DialogType  = "Map"
			{
				attribute<float32>  x: [115135,111803,114903,111353,111741];
				attribute<float32>  y: [401331,399476,399289,401729,398696];
				attribute<point_rd> location := point(y, x, point_rd), Label = "Origins"
				{
					parameter<color>    SymbolColor:     DialogType = "SymbolColor",      = rgb(0,0,0);
					parameter<fontsize> SymbolSize:      DialogType = "SymbolSize",       = value(20, fontsize);
					parameter<m>        SymbolWorldSize: DialogType = "SymbolWorldSize",  = value(20, m);
				}
				attribute<m>           distXY:         [0,26.9258,53.8516,80.7775,107.703];
				attribute<m2>          sqrdistXY:      [0,725,2900,6525,11600];
				attribute<m>           distRoads:      [0,1962.96,824.535,928.425,1192.06];
				attribute<destination> service_area:   [0,1,2,3,1];
				attribute<point_rd>    location2 := point((float32(id(origin) * 25) + y), (float32(int32(id(origin))* -10) + x), point_rd);
				attribute<float32>     districtX:      [112180,113902,112743,114237,112396];
				attribute<float32>     districtY:      [402429,401986,401318,402376,403667];
				attribute<point_rd>    district_location := point(districtY, districtX, point_rd), Label = "Origins";
				attribute<district>    districtPol:    [6,4,1,5,null];
				attribute<uint32>      connect_points: [0,1,2,3,1];
				attribute<uint32>      SpatialIndex:   [0,1,10,63,86];
				attribute<string>      originnr_str := string(id(origin)), DialogType = "LabelText"
				{
					parameter<float32> LabelSize: DialogType = "LabelSize",  = float32(14);
				}
			}
			unit<uint32> destination := DDomain
			,	DialogData  = "location"
			,	DialogType  = "Map"
			{
				attribute<float32>  x: [115135,112601,114903,112156];
				attribute<float32>  y: [401331,399138,398600,401729];

				attribute<point_rd> location := point(y, x, point_rd), Label = "Destinations"
				{
					parameter<color>    SymbolColor:     DialogType = "SymbolColor",      = rgb(255,0,0),        DisableStorage = "True";
					parameter<fontsize> SymbolSize:      DialogType = "SymbolSize",       = value(30, fontsize), DisableStorage = "True";
					parameter<m>        SymbolWorldSize: DialogType = "SymbolWorldSize",  = value(25, m),        DisableStorage = "True";
				}
				attribute<string> destinationnr_str := string(id(destination)), DialogType = "LabelText"
				{
					parameter<float32> LabelSize: DialogType = "LabelSize", = float32(14);
				}
			}
			unit<uint32> pointset := DistrictPointsDomain
			{
				attribute<point_rd> point:
				[
					 {403025,113810},{402552,113711},{402558,113646},{402428,113636},{402448,113472},{402480,113244},{402503,113057},{402570,112883},{402576,112884},{402578,112876},{402647,112740},{402697,112555},{402698,112554},{402973,112471},{402977,112473},{403544,112312},{403552,112612},{403434,112809},{403298,113032},{403171,113401},{403025,113810}
					,{400990,113269},{400888,113291},{400886,113192},{400883,113120},{400916,112666},{400893,112424},{400817,112176},{400864,112187},{401157,112293},{401322,112404},{401494,112519},{401597,112589},{401558,112840},{401553,112888},{401288,112945},{401065,113187},{400990,113269}
					,{401238,115099},{401047,115164},{400978,114523},{400965,114314},{400926,113796},{400919,113685},{400888,113291},{400990,113269},{401065,113187},{401288,112945},{401553,112888},{401510,113137},{401550,113377},{401602,113684},{401642,113915},{401567,114437},{401475,114991},{401462,115075},{401238,115099}
					,{402174,113703},{402076,113691},{402076,113690},{401742,113655},{401723,113659},{401602,113684},{401510,113137},{401553,112888},{402697,112555},{402647,112740},{402578,112876},{402577,112876},{402576,112884},{402570,112883},{402503,113057},{402480,113244},{402448,113472},{402446,113472},{402428,113636},{402426,113634},{402414,113716},{402281,113770},{402174,113703}
					,{401531,114646},{401567,114437},{401642,113915},{401602,113684},{401723,113659},{401742,113655},{402077,113690},{402076,113691},{402076,113690},{402077,113690},{402174,113703},{402281,113770},{402272,113831},{402263,113896},{402199,114330},{402194,114374},{402223,114390},{402197,114497},{402086,114462},{402049,114612},{401988,114592},{401980,114626},{401803,114574},{401790,114655},{401765,114673},{401757,114803},{401545,114739},{401567,114983},{401475,114991},{401531,114646}
					,{402757,114546},{402404,114445},{402317,114418},{402192,114373},{402263,113896},{402281,113770},{402414,113716},{402428,113636},{402558,113646},{402552,113711},{403025,113810},{402870,114237},{402757,114546}
					,{405282,113562},{405282,113561},{405183,113537},{404996,113582},{404923,113297},{404776,113283},{404669,113160},{404669,113068},{404576,113022},{404353,113116},{404300,112976},{404256,112989},{404154,112857},{404063,112893},{403939,112611},{403770,112450},{403792,112379},{403544,112312},{402977,112473},{402973,112471},{402698,112554},{402697,112555},{401553,112888},{401558,112840},{401597,112589},{401494,112519},{401322,112404},{401157,112293},{400943,112215},{401063,111873},{401234,111711},{401477,111716},{401653,111646},{402133,111453},{402382,111433},{402859,111567},{403372,111821},{403701,111952},{403834,112009},{403934,112040},{404010,112054},{404157,112066},{404271,112054},{404555,111996},{404649,111969},{404664,111986},{404631,112040},{404620,112098},{405013,112720},{405495,113478},{405454,113512},{405415,113601},{405353,113625},{405282,113562}
				];
				attribute<district> districtnr:
				[
					0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
					1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
					2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
					3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,
					4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,
					5,5,5,5,5,5,5,5,5,5,5,5,5,
					6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6
				];
				attribute<uint32> ordinal:
				[
					0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,
					0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,
					0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,
					0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,
					0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,
					0,1,2,3,4,5,6,7,8,9,10,11,12,
					0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53
				];
			}
			unit<uint32> district := DistrictDomain
			{
				attribute<point_rd> border (.,polygon) := points2sequence(pointset/point, pointset/districtnr, pointset/ordinal);
			}

			unit<uint32> vbo := HDomain
			{
				attribute<float32>  x: [252885,93675.9,28107.4,82023.3];
				attribute<float32>  y: [593641,450424,380344,429314];
				attribute<point_rd> geometry := point(x, y, point_rd), Label = "Origins"
				{
					parameter<color>    SymbolColor:     DialogType = "SymbolColor",      = rgb(0,0,0);
					parameter<fontsize> SymbolSize:      DialogType = "SymbolSize",       = value(20, fontsize);
					parameter<m>        SymbolWorldSize: DialogType = "SymbolWorldSize",  = value(20, m);
				}
				attribute<uint32> point_in_ranked_polygon_ok : [0,3,18,15];
			}
			unit<uint32> pand_pointset := PandPointsDomain
			{
				attribute<point_rd> point:
				[
					 {252865, 593646},{252865, 593646},{252874, 593647},{252874, 593647},{252886, 593648},{252887, 593634},{252884, 593634},{252866, 593632},{252865, 593646},{93659.3, 450420},{93676.3, 450441},{93692.5, 450427},
					 {93675.5, 450407},{93659.3, 450420},{93659.3, 450420},{93676.3, 450441},{93692.5, 450427},{93675.5, 450407},{93659.3, 450420},{93659.3, 450420},{93676.3, 450441},{93692.5, 450427},{93675.5, 450407},{93659.3, 450420},
					 {93659.3, 450420},{93676.3, 450441},{93692.5, 450427},{93675.5, 450407},{93659.3, 450420},{93659.3, 450420},{93676.3, 450441},{93692.5, 450427},{93675.5, 450407},{93659.3, 450420},{93659.3, 450420},{93676.3, 450441},
					 {93692.5, 450427},{93675.5, 450407},{93659.3, 450420},{93659.3, 450420},{93676.3, 450441},{93692.5, 450427},{93675.5, 450407},{93659.3, 450420},{93659.3, 450420},{93676.3, 450441},{93692.5, 450427},{93675.5, 450407},
					 {93659.3, 450420},{93659.3, 450420},{93676.3, 450441},{93692.5, 450427},{93675.5, 450407},{93659.3, 450420},{93659.3, 450420},{93676.3, 450441},{93692.5, 450427},{93675.5, 450407},{93659.3, 450420},{93659.3, 450420},
					 {93676.3, 450441},{93692.5, 450427},{93675.5, 450407},{93659.3, 450420},{93659.3, 450420},{93676.3, 450441},{93692.5, 450427},{93675.5, 450407},{93659.3, 450420},{93659.3, 450420},{93676.3, 450441},{93692.5, 450427},
					 {93675.5, 450407},{93659.3, 450420},{93659.3, 450420},{93676.3, 450441},{93692.5, 450427},{93675.5, 450407},{93659.3, 450420},{81978.4, 429342},{81994.5, 429357},{82011.9, 429339},{82026, 429324},{82023.1, 429321},
					 {82024.2, 429320},{82034.6, 429309},{82020, 429295},{82008.5, 429307},{82009.9, 429309},{81978.5, 429342},{81978.4, 429342},{28111.3, 380374},{28134.9, 380351},{28090.1, 380305},{28066.5, 380328},{28111.3, 380374},
					 {28055.5, 380274},{28043.3, 380286},{28159.9, 380406},{28171, 380395},{28143.8, 380366},{28135.5, 380375},{28117.8, 380357},{28126.7, 380348},{28100.1, 380321},{28090.4, 380330},{28073.1, 380311},{28081.6, 380303},
					 {28055.5, 380274},{28100, 380322},{28089.2, 380332},{28115, 380360},{28126.7, 380348},{28100, 380322},{28160.3, 380403},{28168.7, 380395},{28054.4, 380277},{28045.6, 380285},{28160.3, 380403},{81966.2, 429322},
					 {81967.2, 429330},{81982, 429342},{81981.9, 429343},{81999.9, 429358},{82014.4, 429340},{82013.1, 429339},{82026.9, 429322},{82025.6, 429321},{82029.1, 429317},{82033.7, 429312},{82040, 429304},{82031.6, 429297},
					 {82032.6, 429296},{82015.3, 429282},{82003.7, 429295},{82003.5, 429296},{81994.3, 429288},{81991.1, 429292},{81994.2, 429294},{81991.5, 429298},{81988.4, 429295},{81966.2, 429322}
				];
				attribute<pand> pand_rel:
				[
				  0,0,0,0,0,0,0,0,0,1,1,1,1,1,2,2,2,2,2,3,3,3,3,3,4,4,4,4,4,5,5,5,5,5,6,6,6,6,6,7,7,7,7,7,8,8,8,8,8,9,9,9,9,9,10,10,10,10,10,11,11,11,11,11,12,12,12,12,12,13,13,13,13,13,14,14,14,14,14,15,15,15,15,
				 15,15,15,15,15,15,15,15,16,16,16,16,16,17,17,17,17,17,17,17,17,17,17,17,17,17,18,18,18,18,18,19,19,19,19,19,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20
				];
				attribute<uint32> ordinal:
				[
					0,1,2,3,4,5,6,7,8,0,1,2,3,4,0,1,2,3,4,0,1,2,3,4,0,1,2,3,4,0,1,2,3,4,0,1,2,3,4,0,1,2,3,4,0,1,2,3,4,0,1,2,3,4,0,1,2,3,4,0,1,2,3,4,0,1,2,3,4,0,1,2,3,4,0,1,2,3,4,0,1,2,3,4,5,6,7,8,9,10,11,0,1,2,3,4,
					0,1,2,3,4,5,6,7,8,9,10,11,12,0,1,2,3,4,0,1,2,3,4,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22
				];
			}
			unit<uint32> pand := PandDomain
			{
				attribute<point_rd> geometry (.,polygon) := points2sequence(pand_pointset/point, pand_pointset/pand_rel, pand_pointset/ordinal);
				attribute<uint32>   first_rel_OK  : [0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,2,2,3,3];
				attribute<uint32>   second_rel_OK : [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,16,17,18,19,15,20];
				attribute<float32>  rank          := abs(1f / area(geometry, float32));
			}
		}
		template ESource
		{
			// begin case parameters
			unit<uint32> ODomain;
			unit<uint32> DDomain;
			unit<uint32> DistrictPointsDomain;
			unit<uint32> DistrictDomain;
			unit<uint32> PandPointsDomain;
			unit<uint32> PandDomain;
			// end case parameters

			unit<uint32> origin := ODomain
			,	DialogData  = "location"
			,	DialogType  = "Map"
			{
				attribute<float32>  x: [];
				attribute<float32>  y: [];
				attribute<point_rd> location := point(y, x, point_rd), Label = "Origins"
				{
					parameter<color>    SymbolColor:     DialogType = "SymbolColor",      = rgb(0,0,0);
					parameter<fontsize> SymbolSize:      DialogType = "SymbolSize",       = value(20, fontsize);
					parameter<m>        SymbolWorldSize: DialogType = "SymbolWorldSize",  = value(20, m);
				}
				attribute<m>           distXY:         [];
				attribute<m2>          sqrdistXY:      [];
				attribute<m>           distRoads:      [];
				attribute<destination> service_area:   [];
				attribute<point_rd>    location2 := point((float32(id(origin) * 25) + y), (float32(int32(id(origin))* -10) + x), point_rd);
				attribute<float32>     districtX:      [];
				attribute<float32>     districtY:      [];
				attribute<point_rd>    district_location := point(districtY, districtX, point_rd), Label = "Origins";
				attribute<district>    districtPol:    [];
				attribute<uint32>      connect_points: [];
				attribute<uint32>      SpatialIndex:   [];
				attribute<string>      originnr_str := string(id(origin)), DialogType = "LabelText"
				{
					parameter<float32> LabelSize: DialogType = "LabelSize",  = float32(14);
				}
			}
			unit<uint32> destination := DDomain
			,	DialogData  = "location"
			,	DialogType  = "Map"
			{
				attribute<float32>  x: [];
				attribute<float32>  y: [];

				attribute<point_rd> location := point(y, x, point_rd), Label = "Destinations"
				{
					parameter<color>    SymbolColor:     DialogType = "SymbolColor",      = rgb(255,0,0),        DisableStorage = "True";
					parameter<fontsize> SymbolSize:      DialogType = "SymbolSize",       = value(30, fontsize), DisableStorage = "True";
					parameter<m>        SymbolWorldSize: DialogType = "SymbolWorldSize",  = value(25, m),        DisableStorage = "True";
				}
				attribute<string> destinationnr_str := string(id(destination)), DialogType = "LabelText"
				{
					parameter<float32> LabelSize: DialogType = "LabelSize", = float32(14);
				}
			}
			unit<uint32> pointset := DistrictPointsDomain
			{
				attribute<point_rd> point:
				[
				];
				attribute<district> districtnr:
				[
				];
				attribute<uint32> ordinal:
				[
				];
			}
			unit<uint32> district := DistrictDomain
			{
				attribute<point_rd> border (.,polygon) := points2sequence(pointset/point, pointset/districtnr, pointset/ordinal);
			}
			unit<uint32> vbo := district
			{
				attribute<point_rd> geometry : [];
				attribute<uint32> point_in_ranked_polygon_ok: [];
			}
			unit<uint32> pand := district
			{
				attribute<point_rd> geometry (poly) := district/border;
				attribute<float32>  rank            := 1f / area(geometry, float32);

				attribute<uint32>   first_rel_OK:    [];
				attribute<uint32>   second_rel_OK: [];
			}

		}
		container UnTiled2Untiled := Template(ADomain,      HDomain,      DistrictPointsDomain,      RDomain       ,HDomain ,PandDomain      , srcUnTiled2Untiled);
		container Tiled2Untiled   := Template(ATiledDomain, HDomain,      DistrictPointsTiledDomain, RDomain       ,HDomain ,PandDomain      , srcTiled2Untiled);
		container UnTiled2Tiled   := Template(ADomain,      HTiledDomain, DistrictPointsDomain,      RTiledDomain  ,HDomain ,PandTiledDomain , srcUnTiled2Tiled);
		container Tiled2Tiled     := Template(ATiledDomain, HTiledDomain, DistrictPointsTiledDomain, RTiledDomain  ,HDomain ,PandTiledDomain , srcTiled2Tiled);

		container EUnTiled2Untiled := Template(EDomain     , EDomain,      EDomain,      EDomain      , EDomain , EDomain        , EsrcUnTiled2Untiled);
		container ETiled2Untiled   := Template(ETiledDomain, EDomain,      ETiledDomain, EDomain      , EDomain , EDomain        , EsrcTiled2Untiled);
		container EUnTiled2Tiled   := Template(EDomain,      ETiledDomain, EDomain,      ETiledDomain , ETiledDomain , ETiledDomain   , EsrcUnTiled2Tiled);
		container ETiled2Tiled     := Template(ETiledDomain, ETiledDomain, ETiledDomain, ETiledDomain , ETiledDomain , ETiledDomain   , EsrcTiled2Tiled);
		
		container ResultUnitTiled
		{
			container dyna_point_tiled:
				Using = "source",
				url = "http://www.objectvision.hosting.it-rex.nl/geodms/operators-a-functions/point/dyna_point"
			{
				attribute<float32> xp        (ATiledDomain) : [371391, 371384, 371378, 371369, 371364];
				attribute<float32> yp        (ATiledDomain) : [ 13732,  13738,  13746,  13758,  13764];
				attribute<float32> xn        (ATiledDomain) : [371384, 371378, 371369, 371364, 371360];
				attribute<float32> yn        (ATiledDomain) : [ 13738,  13746,  13758,  13764,  13768];
				attribute<fpoint>  point     (ATiledDomain) := point(yp,xp,fpoint);
				attribute<fpoint>  nextpoint (ATiledDomain) := point(yn,xn,fpoint);
				parameter<float32> CalcDist                 := float32(0.0001);
				unit<uint32> CalcPoint                      := dyna_point(point, nextpoint, CalcDist)
				{
					attribute<float32> x          := PointCol(point);
					attribute<float32> y          := PointRow(point);
					parameter<bool>    test_point := float_isNearby(mean(x), 371378.637f, Dif_all_float32) && float_isNearby(mean(y), 13745.7163f, Dif_all_float32);
					parameter<bool>    test_attr  := test_point && #. == 476867 && sum(SequenceNr) = 860582 && max(Ordinal) == 149999 && ordinal[270787] == 78591;
				}
			}
		}


		Template Template
		{
			// begin case parameters
			unit<uint32> origin;
			unit<uint32> DDomain;
			unit<uint32> DistrictPointsDomain;
			unit<uint32> DistrictDomain;
			unit<uint32> vbo;
			unit<uint32> pand;

			container source;
			// begin case parameters

			container point
			:	Using = "source"
			,	url   = "http://www.objectvision.hosting.it-rex.nl/geodms/operators-a-functions/point/point"
			{
				attribute<point_rd> att  (origin) := point(origin/y, origin/x, point_rd);
				attribute<bool>     test (origin) := point_isNearby(att, source/origin/location, Dif_all_float32);
				parameter<bool>     test_attr     := all(test);
			}
			container PointRow
			:	Using = "source"
			,	url   = "http://www.objectvision.hosting.it-rex.nl/geodms/operators-a-functions/point/pointrow"
			{
				attribute<float32> att  (origin) := pointRow(point/att);
				attribute<bool>    test (origin) := att = origin/y;
				parameter<bool>    test_attr     := all(test);
			}
			container PointCol
			:	Using = "source"
			,	url   = "http://www.objectvision.hosting.it-rex.nl/geodms/operators-a-functions/point/pointcol"
			{
				attribute<float32> att  (origin) := pointCol(point/att);
				attribute<bool>    test (origin) := att = source/origin/x;
				parameter<bool>    test_attr     := all(test);
			}
			container dist
			:	Using = "source"
			,	url   = "http://www.objectvision.hosting.it-rex.nl/geodms/operators-a-functions/point/dist"
			{
				attribute<m>        att  (origin) := value(dist(origin/location2, origin/location), m);
				attribute<bool>     test (origin) := float_isNearby(att, origin/distXY, Dif_all_float32);
				parameter<bool>     test_attr     := all(test);
			}
			container sqrdist
			:	Using = "source"
			,	url   = "http://www.objectvision.hosting.it-rex.nl/geodms/operators-a-functions/point/sqrdist"
			{
				attribute<m2>        att  (origin) := value(sqrdist(origin/location2, origin/location), m2);
				attribute<bool>      test (origin) := float_isNearby(att, origin/sqrdistXY, Dif_all_float32);
				parameter<bool>      test_attr     := all(test);
			}
			container point_in_polygon
			:	Using = "source"
			,	url   = "http://www.objectvision.hosting.it-rex.nl/geodms/operators-a-functions/point/point_in_polygon"
			{
				attribute<DistrictDomain> att  (origin) := point_in_polygon(origin/district_location, source/district/Border)
				{
					attribute<point_rd> locatie (origin) := origin/district_location, dialogtype = "feature";
				}
				attribute<bool>            test (origin) := eq_or_both_null(att, origin/districtPol);
				parameter<bool>            test_attr     := all(test);
			}
			container point_in_all_polygons
			:	Using = "source"
			,	url   = "http://www.objectvision.hosting.it-rex.nl/geodms/operators-a-functions/point/point_in_polygon"
			{
				unit<uint32> vbo_pand_rel := point_in_all_polygons(vbo/geometry, pand/geometry)
				{
				}
				attribute<bool>            test (vbo_pand_rel) := vbo_pand_rel/first_rel == union_data(vbo_pand_rel, pand/first_rel_OK)  && vbo_pand_rel/second_rel == union_data(vbo_pand_rel, pand/second_rel_OK);
				parameter<bool>            test_attr     := all(test);
			}
			container point_in_ranked_polygon
			:	Using = "source"
			,	url   = "http://www.objectvision.hosting.it-rex.nl/geodms/operators-a-functions/point/point_in_polygon"
			{
				attribute<pand> att  (vbo) := point_in_ranked_polygon(vbo/geometry, pand/geometry, pand/rank);
				attribute<bool> test (vbo) := eq_or_both_null(att, vbo/point_in_ranked_polygon_ok);
				parameter<bool> test_attr  := all(test);
				
				container rank_constant
				{
					attribute<bool> att  (vbo) := point_in_ranked_polygon(vbo/geometry, pand/geometry, const(0, pand)) == point_in_polygon(vbo/geometry, pand/geometry);
					parameter<bool> test_attr  := all(test);					
				}
			}
			container dyna_point:
				Using = "source",
				url = "http://www.objectvision.hosting.it-rex.nl/geodms/operators-a-functions/point/dyna_point"
			{
				attribute<float32> xp        (ADomain): [371391, 371384, 371378, 371369, 371364];
				attribute<float32> yp        (ADomain): [ 13732,  13738,  13746,  13758,  13764];
				attribute<float32> xn        (ADomain): [371384, 371378, 371369, 371364, 371360];
				attribute<float32> yn        (ADomain): [ 13738,  13746,  13758,  13764,  13768];
				attribute<fpoint>  point     (ADomain) := point(yp,xp,fpoint);
				attribute<fpoint>  nextpoint (ADomain) := point(yn,xn,fpoint);
				parameter<float32> CalcDist            := float32(5);
				unit<uint32> CalcPoint                 := dyna_point(point, nextpoint, CalcDist), DialogType = "Map", DialogData = "point"
				{
					attribute<int32>   x:   [371391,371387,371383,371380,371377,371374,371371,371368,371365,371361];
					attribute<int32>   y:   [ 13732,13735,13738,13742,13746,13750,13754,13758,13762,13766];
					attribute<ADomain>  seq: [0,0,1,1,2,2,2,3,3,4];
					attribute<uint32>  ord: [0,1,0,1,0,1,2,0,1,0];
					attribute<m_int16> z:   [10,30,20,15,20,0,20,60,15, null];
					attribute<bool>    test      := point(y,x,ipoint) = ipoint(point) && SequenceNr = seq && Ordinal = ord;
					parameter<bool>    test_attr := all(test);
				}
			}
			container dyna_point_with_ends:
				Using = "source",
				url = "http://www.objectvision.hosting.it-rex.nl/geodms/operators-a-functions/point/dyna_point"
			{
				attribute<float32> xp        (RoadDomain ): [371391, 371384, 371378];
				attribute<float32> yp        (RoadDomain ): [ 13732,  13738,  13746];
				attribute<float32> xn        (RoadDomain ): [371384, 371378, 371369];
				attribute<float32> yn        (RoadDomain ): [ 13738,  13746,  13758];
				attribute<fpoint>  point     (RoadDomain ) := point(yp,xp,fpoint);
				attribute<fpoint>  nextpoint (RoadDomain ) := point(yn,xn,fpoint);
				parameter<float32> CalcDist            := float32(5);
				unit<uint32> CalcPoint                 := dyna_point_with_ends(point, nextpoint, CalcDist), DialogType = "Map", DialogData = "point"
				{
					attribute<int32>   x:   [371391,371387,371384,371381,371378,371375,371372,371369];
					attribute<int32>   y:   [ 13732,13735,13738,13742,13746,13750,13754,13758];
					attribute<RoadDomain>  seq: [0,0,0,1,1,2,2,2];
					attribute<uint32>  ord: [0,1,2,0,1,0,1,2];
					attribute<m_int16> z:   [10,30,20,15,20,0,20,60];
					attribute<bool>    test      := point(y,x,ipoint) = ipoint(point) && SequenceNr = seq && Ordinal = ord;
					parameter<bool>    test_attr := all(test);
				}
			}
			container dyna_point_tiled:
				Using = "source",
				url = "http://www.objectvision.hosting.it-rex.nl/geodms/operators-a-functions/point/dyna_point"
			{
				attribute<float32> xp        (ATiledDomain) : [371391, 371384, 371378, 371369, 371364];
				attribute<float32> yp        (ATiledDomain) : [ 13732,  13738,  13746,  13758,  13764];
				attribute<float32> xn        (ATiledDomain) : [371384, 371378, 371369, 371364, 371360];
				attribute<float32> yn        (ATiledDomain) : [ 13738,  13746,  13758,  13764,  13768];
				attribute<fpoint>  point     (ATiledDomain) := point(yp,xp,fpoint);
				attribute<fpoint>  nextpoint (ATiledDomain) := point(yn,xn,fpoint);
				parameter<float32> CalcDist                 := float32(5);
				unit<uint32> CalcPoint                      := dyna_point(point, nextpoint, CalcDist)
				{
					attribute<int32>   x:   [371391,371387,371383,371380,371377,371374,371371,371368,371365,371361];
					attribute<int32>   y:   [ 13732,13735,13738,13742,13746,13750,13754,13758,13762,13766];
					attribute<ATiledDomain>  seq: [0,0,1,1,2,2,2,3,3,4];
					attribute<uint32>  ord: [0,1,0,1,0,1,2,0,1,0];
					attribute<m_int16> z:   [10,30,20,15,20,0,20,60,15, null];
					attribute<bool>    test      := point(y,x,ipoint) = ipoint(point) && SequenceNr = seq && Ordinal = ord;
					parameter<bool>    test_attr := all(test);
				}
			}
			container dyna_point_empty:
				Using = "source",
				url = "http://www.objectvision.hosting.it-rex.nl/geodms/operators-a-functions/point/dyna_point"
			{
				attribute<float32> xp        (EDomain) : [];
				attribute<float32> yp        (EDomain) : [];
				attribute<float32> xn        (EDomain) : [];
				attribute<float32> yn        (EDomain) : [];
				attribute<fpoint>  point     (EDomain) := point(yp,xp,fpoint);
				attribute<fpoint>  nextpoint (EDomain) := point(yn,xn,fpoint);
				parameter<float32> CalcDist            := float32(5);
				unit<uint32> CalcPoint                 := dyna_point(point, nextpoint, CalcDist)
				{
					attribute<int32>   x:   [];
					attribute<int32>   y:   [];
					attribute<EDomain>  seq: [];
					attribute<uint32>  ord: [];
					attribute<m_int16> z:   [];
					attribute<bool>    test      := point(y,x,ipoint) = ipoint(point) && SequenceNr = seq && Ordinal = ord;
					parameter<bool>    test_attr := all(test);
				}
			}
			container dyna_segment:
				Using = "source",
				url = "http://www.objectvision.hosting.it-rex.nl/geodms/operators-a-functions/point/dyna_point"
			{
				attribute<float32> xp        (ADomain): [371391, 371384, 371378, 371369, 371364];
				attribute<float32> yp        (ADomain): [ 13732,  13738,  13746,  13758,  13764];
				attribute<float32> xn        (ADomain): [371384, 371378, 371369, 371364, 371360];
				attribute<float32> yn        (ADomain): [ 13738,  13746,  13758,  13764,  13768];
				attribute<fpoint>  point     (ADomain) := point(yp,xp,fpoint);
				attribute<fpoint>  nextpoint (ADomain) := point(yn,xn,fpoint);
				parameter<float32> CalcDist            := float32(5);
				unit<uint32> CalcPoint                 := dyna_segment(point, nextpoint, CalcDist), DialogType = "Map", DialogData = "point"
				{
					attribute<int32>   x:   [371391,371387,371383,371380,371377,371374,371371,371368,371365,371361];
					attribute<int32>   y:   [ 13732,13735,13738,13742,13746,13750,13754,13758,13762,13766];
					attribute<origin>  seq: [0,0,1,1,2,2,2,3,3,4];
					attribute<uint32>  ord: [0,1,0,1,0,1,2,0,1,0];
					attribute<m_int16> z:   [10,30,20,15,20,0,20,60,15, null];
					attribute<bool>    test      := point(y,x,ipoint) = ipoint(point) && SequenceNr = seq && Ordinal = ord;
					parameter<bool>    test_attr := all(test);
				}
			}
			container RD2LatLongWgs84: url = "http://www.objectvision.hosting.it-rex.nl/geodms/operators-a-functions/point/rd2latlongwgs84"
			{
				parameter<dpoint> coordinate                     := point(437651.878, 81897.9383, dpoint);
				parameter<dpoint> param                          := RD2LatLongWgs84(coordinate, dpoint);
				parameter<bool>   test_param                     := point_isNearby(param, point(51.9225381, 4.32450214,  dpoint),Dif_pconv_float64);
				attribute<dpoint> attr (DistrictDomain, polygon) := RD2LatLongWgs84(Source/district/border, dpoint);
				unit<uint32> pointset := sequence2points(attr)
				{
					attribute<bool>   test := point_isnearby(point, att_ok,  Dif_all_float64);
					attribute<dpoint> att_ok_with_values:
					[
						 {51.6145901,4.79249609},{51.6103314,4.79112269},{51.6103806,4.79018364},{51.6092114,4.79005466},{51.609379,4.78768484}, {51.6096497,4.78438968},{51.6098425,4.78168743},{51.6104317,4.77916752},{51.6104857,4.77918123},{51.6105031,4.7790655}, {51.611113,4.77709386}, {51.6115485,4.77441708},{51.6115574,4.77440253},{51.6140229,4.77317084},{51.614059,4.77319922} ,{51.619143,4.77080556}, {51.6192377,4.77513622},{51.6181919,4.77799492},{51.6169862,4.78123104},{51.6158722,4.78657383},{51.6145901,4.79249609}
						,{51.5962592,4.78492844},{51.5953441,4.7852581}, {51.5953187,4.78382964},{51.5952864,4.78279096},{51.595549,4.7762352},  {51.595324,4.77274564}, {51.594622,4.76917601}, {51.5950453,4.769329},  {51.5976869,4.77082291},{51.5991784,4.77240476},{51.600733,4.77404359}, {51.6016641,4.7750414}, {51.6013325,4.77866884},{51.6012911,4.77936223},{51.5989135,4.78021679},{51.5969273,4.78373609},{51.5962592,4.78492844}
						,{51.5986213,4.8113099}, {51.5969092,4.81226976},{51.5962432,4.80302699},{51.5961112,4.80001231},{51.5957229,4.79254139},{51.5956518,4.79094034},{51.5953441,4.7852581}, {51.5962592,4.78492844},{51.5969273,4.78373609},{51.5989135,4.78021679},{51.6012911,4.77936223},{51.6009233,4.78296122},{51.6013006,4.78642038},{51.6017907,4.79084521},{51.6021672,4.7941746}, {51.601531,4.80171755}, {51.6007439,4.80972409},{51.600633,4.81093795}, {51.5986213,4.8113099}
						,{51.6069333,4.79105186},{51.6060516,4.79089023},{51.6060515,4.79087579},{51.6030469,4.79041008},{51.6028764,4.79047007},{51.6017907,4.79084521},{51.6009233,4.78296122},{51.6012911,4.77936223},{51.6115485,4.77441708},{51.611113,4.77709386}, {51.6105031,4.7790655}, {51.6104941,4.77906562},{51.6104857,4.77918123},{51.6104317,4.77916752},{51.6098425,4.78168743},{51.6096497,4.78438968},{51.609379,4.78768484}, {51.6093611,4.78768508},{51.6092114,4.79005466},{51.6091933,4.79002603},{51.6090914,4.79121117},{51.6079,4.79200638},   {51.6069333,4.79105186}
						,{51.6012225,4.80473825},{51.601531,4.80171755}, {51.6021672,4.7941746}, {51.6017907,4.79084521},{51.6028764,4.79047007},{51.6030469,4.79041008},{51.6060605,4.79087567},{51.6060516,4.79089023},{51.6060515,4.79087579},{51.6060605,4.79087567},{51.6069333,4.79105186},{51.6079,4.79200638},   {51.6078236,4.79288799},{51.6077474,4.79382734},{51.6072038,4.80009966},{51.6071621,4.80073539},{51.6074239,4.80096298},{51.6071979,4.80251055},{51.6061977,4.80201819},{51.6058759,4.80418768},{51.6053262,4.80390604},{51.6052568,4.80439773},{51.6036621,4.80366761},{51.6035511,4.80483826},{51.6033277,4.80510095},{51.6032651,4.80697827},{51.601355,4.80607892}, {51.6015702,4.8095981}, {51.6007439,4.80972409},{51.6012225,4.80473825}
						,{51.6122348,4.80315304},{51.6090547,4.8017359}, {51.6082708,4.80135625},{51.607144,4.80072118}, {51.6077474,4.79382734},{51.6079,4.79200638},   {51.6090914,4.79121117},{51.6092114,4.79005466},{51.6103806,4.79018364},{51.6103314,4.79112269},{51.6145901,4.79249609},{51.6132281,4.79867894},{51.6122348,4.80315304}
						,{51.6348581,4.7886478}, {51.634858,4.78863336}, {51.6339664,4.78829846},{51.632289,4.78897061}, {51.6316117,4.78486308},{51.6302894,4.78467845},{51.6293185,4.78291486},{51.6293117,4.7815862}, {51.6284723,4.78093305},{51.626475,4.78231732}, {51.6259882,4.78030194},{51.6255937,4.78049497},{51.624667,4.77860109}, {51.6238518,4.77913192},{51.622716,4.77507481}, {51.6211848,4.77277058},{51.6213772,4.77174269},{51.619143,4.77080556}, {51.614059,4.77319922}, {51.6140229,4.77317084},{51.6115574,4.77440253},{51.6115485,4.77441708},{51.6012911,4.77936223},{51.6013325,4.77866884},{51.6016641,4.7750414}, {51.600733,4.77404359}, {51.5991784,4.77240476},{51.5976869,4.77082291},{51.5957575,4.7697234}, {51.5968099,4.76477309}, {51.5983344,4.762414},{51.6005189,4.76245608},{51.6020954,4.76142396},{51.6063948,4.75857853},{51.6086313,4.7582588},{51.612929,4.76013385},{51.6175595,4.76373739},{51.6205266,4.76558825},{51.6217264,4.76639492},{51.6226276,4.76683024},{51.6233118,4.76702306},{51.624634,4.76717826},{51.6256577,4.76699096},{51.6282059,4.76611841},{51.6290487,4.7657169},{51.6291848,4.76596056},{51.6288923,4.76674449},{51.6287979,4.76758347},{51.6323775,4.77651871},{51.6367664,4.78740918},{51.6364004,4.78790516},{51.6360564,4.78919533},{51.6355009,4.78954934},{51.6348581,4.7886478}
					];
					attribute<dpoint> att_ok_without_values:
					[
					];
					attribute<dpoint> att_ok := = #DistrictDomain == 0 ? 'att_ok_without_values' : 'att_ok_with_values';
				}
				parameter<bool> test_attr := all(pointset/test);
			}
			container LatLongWgs842RD: url = "http://www.objectvision.hosting.it-rex.nl/geodms/operators-a-functions/point/latlongwgs842rd"
			{
				parameter<dpoint> coordinate                      := point(51.9225381, 4.32450214, dpoint);
				parameter<dpoint> param                           := LatLongWgs842RD(coordinate, dpoint);
				parameter<bool>   test_param                      := point_isNearby(param, point(437651.878, 81897.9383, dpoint),Dif_pconv_float64);
				attribute<dpoint> attr (DistrictDomain, polygon) := LatLongWgs842RD(RD2LatLongWgs84/attr, dpoint);
				unit<uint32> pointset := sequence2points(attr)
				{
					attribute<bool>   test := point_isnearby(point, att_ok,  Dif_all_float64);
					attribute<dpoint> att_ok_with_values:
					[
						 {403025,113810},{402552,113711},{402558,113646},{402428,113636},{402448,113472},{402480,113244},{402503,113057},{402570,112883},{402576,112884},{402578,112876},{402647,112740},{402697,112555},{402698,112554},{402973,112471},{402977,112473},{403544,112312},{403552,112612},{403434,112809},{403298,113032},{403171,113401},{403025,113810}
						,{400990,113269},{400888,113291},{400886,113192},{400883,113120},{400916,112666},{400893,112424},{400817,112176},{400864,112187},{401157,112293},{401322,112404},{401494,112519},{401597,112589},{401558,112840},{401553,112888},{401288,112945},{401065,113187},{400990,113269}
						,{401238,115099},{401047,115164},{400978,114523},{400965,114314},{400926,113796},{400919,113685},{400888,113291},{400990,113269},{401065,113187},{401288,112945},{401553,112888},{401510,113137},{401550,113377},{401602,113684},{401642,113915},{401567,114437},{401475,114991},{401462,115075},{401238,115099}
						,{402174,113703},{402076,113691},{402076,113690},{401742,113655},{401723,113659},{401602,113684},{401510,113137},{401553,112888},{402697,112555},{402647,112740},{402578,112876},{402577,112876},{402576,112884},{402570,112883},{402503,113057},{402480,113244},{402448,113472},{402446,113472},{402428,113636},{402426,113634},{402414,113716},{402281,113770},{402174,113703}
						,{401531,114646},{401567,114437},{401642,113915},{401602,113684},{401723,113659},{401742,113655},{402077,113690},{402076,113691},{402076,113690},{402077,113690},{402174,113703},{402281,113770},{402272,113831},{402263,113896},{402199,114330},{402194,114374},{402223,114390},{402197,114497},{402086,114462},{402049,114612},{401988,114592},{401980,114626},{401803,114574},{401790,114655},{401765,114673},{401757,114803},{401545,114739},{401567,114983},{401475,114991},{401531,114646}
						,{402757,114546},{402404,114445},{402317,114418},{402192,114373},{402263,113896},{402281,113770},{402414,113716},{402428,113636},{402558,113646},{402552,113711},{403025,113810},{402870,114237},{402757,114546}
						,{405282,113562},{405282,113561},{405183,113537},{404996,113582},{404923,113297},{404776,113283},{404669,113160},{404669,113068},{404576,113022},{404353,113116},{404300,112976},{404256,112989},{404154,112857},{404063,112893},{403939,112611},{403770,112450},{403792,112379},{403544,112312},{402977,112473},{402973,112471},{402698,112554},{402697,112555},{401553,112888},{401558,112840},{401597,112589},{401494,112519},{401322,112404},{401157,112293},{400943,112215},{401063,111873},{401234,111711},{401477,111716},{401653,111646},{402133,111453},{402382,111433},{402859,111567},{403372,111821},{403701,111952},{403834,112009},{403934,112040},{404010,112054},{404157,112066},{404271,112054},{404555,111996},{404649,111969},{404664,111986},{404631,112040},{404620,112098},{405013,112720},{405495,113478},{405454,113512},{405415,113601},{405353,113625},{405282,113562}
					];
					attribute<dpoint> att_ok_without_values:
					[
					];
					attribute<dpoint> att_ok := = #DistrictDomain == 0 ? 'att_ok_without_values' : 'att_ok_with_values';

				}
				parameter<bool> test_attr := all(pointset/test);
			}
			container RD2LatLongGE: url = "http://www.objectvision.hosting.it-rex.nl/geodms/operators-a-functions/point/rd2latlongge"
			{
				parameter<dpoint> coordinate := point(437651.878, 81897.9383,  dpoint);
				parameter<dpoint> param      := RD2LatLongGE(coordinate, dpoint);
				parameter<bool>   test_param := point_isNearby(param, point(51.9225625, 4.3245894,  dpoint),Dif_pconv_float64);
				attribute<dpoint> attr (DistrictDomain, polygon) := RD2LatLongGE(Source/district/border, dpoint);
				unit<uint32> pointset := sequence2points(attr)
				{
					attribute<bool>   test := point_isnearby(point, att_ok,  Dif_all_float64);
					attribute<dpoint> att_ok_with_values:
					[
						 {51.6146385,4.79255458},{51.6103801,4.79118136},{51.6104293,4.79024237},{51.6092602,4.79011343},{51.6094278,4.78774378},{51.6096985,4.78444886},{51.6098913,4.7817468} ,{51.6104805,4.77922707},{51.6105345,4.77924078},{51.6105518,4.77912506},{51.6111617,4.77715355},{51.6115972,4.77447696},{51.6116061,4.77446241},{51.6140713,4.77323076},{51.6141074,4.77325914},{51.6191911,4.77086556},{51.6192857,4.7751959} ,{51.61824,4.77805441}  ,{51.6170344,4.78129031},{51.6159205,4.78663273},{51.6146385,4.79255458}
						,{51.5963092,4.78498783},{51.5953941,4.78531749},{51.5953688,4.78388914},{51.5953364,4.78285053},{51.595599 ,4.77629525},{51.595374 ,4.77280595},{51.5946721,4.7692366} ,{51.5950954,4.76938956},{51.5977367,4.77088332},{51.5992281,4.77246502},{51.6007826,4.7741037} ,{51.6017136,4.77510142},{51.601382,4.7787286}  ,{51.6013407,4.77942194},{51.5989633,4.78027648},{51.5969771,4.78379556},{51.5963092,4.78498783}
						,{51.598671 ,4.81136731},{51.596959 ,4.81232713},{51.596293 ,4.80308505},{51.5961611,4.8000706} ,{51.5957729,4.79260024},{51.5957018,4.79099931},{51.5953941,4.78531749},{51.5963092,4.78498783},{51.5969771,4.78379556},{51.5989633,4.78027648},{51.6013407,4.77942194},{51.6009728,4.78302067},{51.6013501,4.78647957},{51.6018401,4.79090406},{51.6022166,4.7942332} ,{51.6015804,4.80177561},{51.6007933,4.80978158},{51.6006824,4.81099535},{51.598671,4.81136731}
						,{51.6069823,4.7911106} ,{51.6061007,4.790949}  ,{51.6061006,4.79093456},{51.6030962,4.79046895},{51.6029258,4.79052893},{51.6018401,4.79090406},{51.6009728,4.78302067},{51.6013407,4.77942194},{51.6115972,4.77447696},{51.6111617,4.77715355},{51.6105518,4.77912506},{51.6105428,4.77912518},{51.6105345,4.77924078},{51.6104805,4.77922707},{51.6098913,4.7817468} ,{51.6096985,4.78444886},{51.6094278,4.78774378},{51.6094099,4.78774402},{51.6092602,4.79011343},{51.6092421,4.7900848} ,{51.6091403,4.79126986},{51.6079489,4.79206503},{51.6069823,4.7911106}
						,{51.6012719,4.80479609},{51.6015804,4.80177561},{51.6022166,4.7942332} ,{51.6018401,4.79090406},{51.6029258,4.79052893},{51.6030962,4.79046895},{51.6061096,4.79093444},{51.6061007,4.790949}  ,{51.6061006,4.79093456},{51.6061096,4.79093444},{51.6069823,4.7911106} ,{51.6079489,4.79206503},{51.6078725,4.79294658},{51.6077964,4.79388586},{51.6072527,4.80015773},{51.607211,4.80079341} ,{51.6074728,4.80102098},{51.6072468,4.80256844},{51.6062467,4.80207614},{51.605925,4.80424547} ,{51.6053753,4.80396386},{51.6053058,4.80445552},{51.6037113,4.80372548},{51.6036003,4.80489605},{51.6033769,4.80515873},{51.6033143,4.8070359},{51.6014044,4.80613666},{51.6016196,4.80965558},{51.6007933,4.80978158},{51.6012719,4.80479609}
						,{51.6122833,4.80321079},{51.6091035,4.80179382},{51.6083196,4.8014142} ,{51.6071929,4.80077921},{51.6077964,4.79388586},{51.6079489,4.79206503},{51.6091403,4.79126986},{51.6092602,4.79011343},{51.6104293,4.79024237},{51.6103801,4.79118136},{51.6146385,4.79255458},{51.6132766,4.79873699},{51.6122833,4.80321079}
						,{51.6349048,4.78870618},{51.6349047,4.78869174},{51.6340132,4.78835689},{51.6323358,4.78902902},{51.6316587,4.7849218} ,{51.6303365,4.78473721},{51.6293657,4.78297378},{51.6293588,4.78164521},{51.6285196,4.78099212},{51.6265224,4.78237633},{51.6260356,4.78036111},{51.6256411,4.78055413},{51.6247145,4.77866041},{51.6238994,4.77919122},{51.6227637,4.77513443},{51.6212327,4.77283039},{51.621425,4.77180258} ,{51.6191911,4.77086556},{51.6141074,4.77325914},{51.6140713,4.77323076},{51.6116061,4.77446241},{51.6115972,4.77447696},{51.6013407,4.77942194},{51.601382,4.7787286}  ,{51.6017136,4.77510142},{51.6007826,4.7741037},{51.5992281,4.77246502},{51.5977367,4.77088332},{51.5958075,4.76978393},{51.5968599,4.76483396},{51.5983842,4.76247501},{51.6005686,4.76251705},{51.6021449,4.76148497},{51.606444,4.75863967},{51.6086803,4.75831992},{51.6129776,4.76019476},{51.6176077,4.76379794},{51.6205746,4.76564861},{51.6217743,4.76645519},{51.6226754,4.76689047},{51.6233595,4.76708325},{51.6246816,4.76723843},{51.6257052,4.76705111},{51.6282532,4.76617858},{51.6290959,4.76577708},{51.629232,4.76602073},{51.6289396,4.7668046},{51.6288452,4.76764352},{51.6324244,4.77657803},{51.6368129,4.78746761},{51.6364469,4.78796357},{51.636103,4.78925365},{51.6355475,4.78960765},{51.6349048,4.78870618}
					];
					attribute<dpoint> att_ok_without_values:
					[
					];
					attribute<dpoint> att_ok := = #DistrictDomain == 0 ? 'att_ok_without_values' : 'att_ok_with_values';

				}
				parameter<bool> test_attr := all(pointset/test);
			}
			container RD2LatLongEd50: url = "http://www.objectvision.hosting.it-rex.nl/geodms/operators-a-functions/point/rd2latlonged50"
			{
				parameter<dpoint> coordinate := point(437651.878, 81897.9383,  dpoint);
				parameter<dpoint> param      := RD2LatLongEd50(coordinate, dpoint);
				parameter<bool>   test_param := point_isNearby(param, point(51.923335, 4.325787,  dpoint),Dif_pconv_float64);
	
				attribute<dpoint> attr (DistrictDomain, polygon) := RD2LatLongEd50(Source/district/border, dpoint);
				unit<uint32> pointset := sequence2points(attr)
				{
					attribute<bool>   test := point_isnearby(point, att_ok,  Dif_all_float64);
					attribute<dpoint> att_ok_with_values:
					[
						 {51.6153922,4.79375852},{51.6111336,4.792385}  ,{51.6111828,4.79144598},{51.6100136,4.79131697},{51.6101813,4.78894721},{51.610452 ,4.78565214},{51.6106448,4.78294997},{51.611234 ,4.78043014},{51.611288 ,4.78044385},{51.6113054,4.78032813},{51.6119154,4.77835655},{51.6123508,4.77567986},{51.6123597,4.7756653} ,{51.6148251,4.77443373},{51.6148612,4.77446212},{51.6199451,4.77206868},{51.6200397,4.77639924},{51.618994 ,4.77925783},{51.6177883,4.78249383},{51.6166743,4.78783645},{51.6153922,4.79375852}
						,{51.5970619,4.78619043},{51.5961468,4.78652005},{51.5961215,4.78509164},{51.5960891,4.78405297},{51.5963518,4.77749739},{51.5961268,4.77400791},{51.5954249,4.77043835},{51.5958481,4.77059134},{51.5984896,4.77208531},{51.5999811,4.77366716},{51.6015357,4.77530601},{51.6024667,4.77630382},{51.6021351,4.77993116},{51.6020937,4.78062453},{51.5997162,4.78147899},{51.5977299,4.78499814},{51.5970619,4.78619043}
						,{51.5994237,4.81257132},{51.5977116,4.81353109},{51.5970457,4.80428853},{51.5969138,4.80127392},{51.5965255,4.79380318},{51.5964545,4.79220217},{51.5961468,4.78652005},{51.5970619,4.78619043},{51.5977299,4.78499814},{51.5997162,4.78147899},{51.6020937,4.78062453},{51.6017258,4.78422343},{51.6021031,4.78768251},{51.6025932,4.79210724},{51.6029696,4.79543656},{51.6023334,4.8029793} ,{51.6015462,4.81098562},{51.6014353,4.81219944},{51.5994237,4.81257132}
						,{51.6077356,4.79231407},{51.6068539,4.7921524} ,{51.6068539,4.79213797},{51.6038493,4.79167217},{51.6036789,4.79173215},{51.6025932,4.79210724},{51.6017258,4.78422343},{51.6020937,4.78062453},{51.6123508,4.77567986},{51.6119154,4.77835655},{51.6113054,4.78032813},{51.6112964,4.78032825},{51.611288 ,4.78044385},{51.611234 ,4.78043014},{51.6106448,4.78294997},{51.610452 ,4.78565214},{51.6101813,4.78894721},{51.6101633,4.78894745},{51.6100136,4.79131697},{51.6099955,4.79128833},{51.6098937,4.79247344},{51.6087023,4.79326859},{51.6077356,4.79231407}
						,{51.6020249,4.80599992},{51.6023334,4.8029793} ,{51.6029696,4.79543656},{51.6025932,4.79210724},{51.6036789,4.79173215},{51.6038493,4.79167217},{51.6068628,4.79213785},{51.6068539,4.7921524} ,{51.6068539,4.79213797},{51.6068628,4.79213785},{51.6077356,4.79231407},{51.6087023,4.79326859},{51.6086258,4.79415018},{51.6085497,4.7950895} ,{51.608006 ,4.80136165},{51.6079643,4.80199735},{51.6082261,4.80222495},{51.6080001,4.80377247},{51.6069999,4.8032801} ,{51.6066782,4.80544951},{51.6061285,4.80516786},{51.606059,4.80565954} ,{51.6044644,4.80492939},{51.6043534,4.8061}    ,{51.60413,4.80636268}  ,{51.6040674,4.80823995},{51.6021574,4.80734056},{51.6023725,4.81085966},{51.6015462,4.81098562},{51.6020249,4.80599992}
						,{51.6130369,4.80441512},{51.6098569,4.80299791},{51.609073 ,4.80261823},{51.6079462,4.80198315},{51.6085497,4.7950895} ,{51.6087023,4.79326859},{51.6098937,4.79247344},{51.6100136,4.79131697},{51.6111828,4.79144598},{51.6111336,4.792385}  ,{51.6153922,4.79375852},{51.6140302,4.79994116},{51.6130369,4.80441512}
						,{51.6356596,4.78991101},{51.6356595,4.78989656},{51.634768 ,4.78956165},{51.6330905,4.79023373},{51.6324134,4.78612627},{51.6310911,4.7859416} ,{51.6301203,4.78417803},{51.6301134,4.78284939},{51.6292741,4.78219623},{51.6272768,4.78358041},{51.62679  ,4.78156506},{51.6263955,4.78175807},{51.6254689,4.7798642} ,{51.6246537,4.780395}  ,{51.623518 ,4.77633795},{51.6219869,4.77403372},{51.6221792,4.77300587},{51.6199451,4.77206868},{51.6148612,4.77446212},{51.6148251,4.77443373},{51.6123597,4.7756653} ,{51.6123508,4.77567986},{51.6020937,4.78062453},{51.6021351,4.77993116},{51.6024667,4.77630382},{51.6015357,4.77530601},{51.5999811,4.77366716},{51.5984896,4.77208531},{51.5965603,4.77098576},{51.5976127,4.76603561},{51.5991372,4.76367663},{51.6013217,4.76371878},{51.6028981,4.76268674},{51.6071974,4.75984153},{51.6094338,4.75952188},{51.6137314,4.76139703},{51.6183617,4.76500064},{51.6213288,4.76685156},{51.6225285,4.76765824},{51.6234297,4.76809359},{51.6241138,4.76828642},{51.625436,4.76844167},{51.6264596,4.7682544},{51.6290078,4.76738196},{51.6298506,4.76698049},{51.6299867,4.76722415},{51.6296942,4.76800805},{51.6295998,4.768847},{51.6331791,4.77778214},{51.6375678,4.78867248},{51.6372018,4.78916844},{51.6368579,4.79045857},{51.6363024,4.79081255},{51.6356596,4.78991101}
					];
					attribute<dpoint> att_ok_without_values:
					[
					];
					attribute<dpoint> att_ok := = #DistrictDomain == 0 ? 'att_ok_without_values' : 'att_ok_with_values';

				}
				parameter<bool> test_attr := all(pointset/test);
			}
			container RD2LatLong: url = "http://www.objectvision.hosting.it-rex.nl/geodms/operators-a-functions/point/rd2latlong"
			{
				parameter<dpoint> coordinate := point(437651.878, 81897.9383,  dpoint);
				parameter<dpoint> param      := RD2LatLong(coordinate, dpoint);
				parameter<bool>   test_param := point_isNearby(param, point(51.923496, 4.324782,  dpoint),Dif_pconv_float64);
				attribute<dpoint> attr (DistrictDomain, polygon) :=RD2LatLong(Source/district/border, dpoint);
				unit<uint32> pointset := sequence2points(attr)
				{
					attribute<bool>   test := point_isnearby(point, att_ok,  Dif_all_float64);
					attribute<dpoint> att_ok_with_values:
					[
						 {51.6155134,4.79284599},{51.6112543,4.7914724} ,{51.6113034,4.79053321},{51.6101341,4.79040422},{51.6103017,4.78803405},{51.6105725,4.78473841},{51.6107653,4.78203576},{51.6113545,4.77951548},{51.6114085,4.7795292} ,{51.6114259,4.77941345},{51.6120359,4.77744151},{51.6124714,4.77476434},{51.6124803,4.77474978},{51.6149461,4.77351791},{51.6149822,4.7735463} ,{51.6200668,4.77115226},{51.6201615,4.77548356},{51.6191156,4.77834268},{51.6179098,4.78157928},{51.6167957,4.78692286},{51.6155134,4.79284599}
						,{51.5971804,4.78527729},{51.5962651,4.785607}  ,{51.5962398,4.78417834},{51.5962075,4.7831395} ,{51.59647  ,4.77658278},{51.596245 ,4.7730927} ,{51.5955429,4.76952256},{51.5959663,4.76967556},{51.5986082,4.77116969},{51.6000998,4.77275176},{51.6016547,4.77439083},{51.6025859,4.77538878},{51.6022542,4.77901675},{51.6022129,4.77971025},{51.599835,4.78056494} ,{51.5978485,4.78408476},{51.5971804,4.78527729}
						,{51.5995428,4.81166262},{51.5978305,4.81262262},{51.5971644,4.8033785} ,{51.5970324,4.80036337},{51.596644 ,4.79289137},{51.5965729,4.79129008},{51.5962651,4.785607}  ,{51.5971804,4.78527729},{51.5978485,4.78408476},{51.599835 ,4.78056494},{51.6022129,4.77971025},{51.601845,4.78330977} ,{51.6022224,4.78676943},{51.6027125,4.79119491},{51.603089,4.79452479} ,{51.6024528,4.80206885},{51.6016656,4.81007657},{51.6015547,4.8112906} ,{51.5995428,4.81166262}
						,{51.6078557,4.79140158},{51.6069739,4.79123992},{51.6069738,4.79122548},{51.6039689,4.79075972},{51.6037984,4.79081971},{51.6027125,4.79119491},{51.601845 ,4.78330977},{51.6022129,4.77971025},{51.6124714,4.77476434},{51.6120359,4.77744151},{51.6114259,4.77941345},{51.6114169,4.77941357},{51.6114085,4.7795292} ,{51.6113545,4.77951548},{51.6107653,4.78203576},{51.6105725,4.78473841},{51.6103017,4.78803405},{51.6102838,4.78803429},{51.6101341,4.79040422},{51.6101159,4.79037558},{51.6100141,4.7915609} ,{51.6088225,4.79235623},{51.6078557,4.79140158}
						,{51.6021443,4.80508999},{51.6024528,4.80206885},{51.603089, 4.79452479},{51.6027125,4.79119491},{51.6037984,4.79081971},{51.6039689,4.79075972},{51.6069828,4.79122537},{51.6069739,4.79123992},{51.6069738,4.79122548},{51.6069828,4.79122537},{51.6078557,4.79140158},{51.6088225,4.79235623},{51.6087461,4.79323797},{51.60867,4.79417746}  ,{51.6081263,4.8004507} ,{51.6080845,4.80108652},{51.6083464,4.80131414},{51.6081204,4.80286194},{51.60712  ,4.80236952},{51.6067983,4.80453932},{51.6062485,4.80425764},{51.606179 ,4.80474941},{51.6045842,4.80401919},{51.6044731,4.80519001},{51.6042497,4.80545274},{51.6041871,4.80733033},{51.6022768,4.80643086},{51.602492 ,4.80995055},{51.6016656,4.81007657},{51.6021443,4.80508999}
						,{51.6131579,4.80350451},{51.6099774,4.80208718},{51.6091934,4.80170747},{51.6080665,4.80107232},{51.60867  ,4.79417746},{51.6088225,4.79235623},{51.6100141,4.7915609} ,{51.6101341,4.79040422},{51.6113034,4.79053321},{51.6112543,4.7914724} ,{51.6155134,4.79284599},{51.6141513,4.79902975},{51.6131579,4.80350451}
						,{51.6357838,4.78899707},{51.6357837,4.78898262},{51.634892, 4.78864769},{51.6332144,4.78931994},{51.632537 ,4.78521181},{51.6312146,4.78502715},{51.6302436,4.78326331},{51.6302367,4.78193445},{51.6293973,4.78128121},{51.6273997,4.78266569},{51.6269128,4.78065002},{51.6265183,4.78084308},{51.6255915,4.77894892},{51.6247761,4.77947983},{51.6236402,4.77542213},{51.6221089,4.77311756},{51.6223013,4.77208953},{51.6200668,4.77115226},{51.6149822,4.7735463} ,{51.6149461,4.77351791},{51.6124803,4.77474978},{51.6124714,4.77476434},{51.6022129,4.77971025},{51.6022542,4.77901675},{51.6025859,4.77538878},{51.6016547,4.77439083},{51.6000998,4.77275176},{51.5986082,4.77116969},{51.5966786,4.77007003},{51.5977311,4.76511899},{51.5992558,4.76275954},{51.6014405,4.76280162},{51.6030172,4.76176934},{51.6073171,4.75892348},{51.6095538,4.7586037},{51.6138521,4.76047901},{51.6184831,4.76408306},{51.6214506,4.76593419},{51.6226506,4.76674097},{51.6235519,4.76717635},{51.6242361,4.76736919},{51.6255584,4.76752442},{51.6265823,4.76733708},{51.6291308,4.7664644},{51.6299737,4.76606283},{51.6301098,4.76630653},{51.6298173,4.76709057},{51.6297229,4.76792967},{51.6333029,4.77686621},{51.6376923,4.78775826},{51.6373263,4.78825432},{51.6369823,4.78954468},{51.6364267,4.78989874},{51.6357838,4.78899707}
					];
					attribute<dpoint> att_ok_without_values:
					[
					];
					attribute<dpoint> att_ok := = #DistrictDomain == 0 ? 'att_ok_without_values' : 'att_ok_with_values';

				}
				parameter<bool> test_attr := all(pointset/test);
			}

			container bg_buffer_point // TO BE ADDED
			{
				attribute<point_rd> att (poly, origin) := bg_buffer_point(source/origin/location, 50.0, 8b);
				
				unit<uint32> pointset := Sequence2points(att)
				{
					attribute<point_rd> ok:
					[
					 {401331, 115185},{401296, 115170},{401281, 115135},{401296, 115100},{401331, 115085},{401366, 115100},{401381, 115135},{401366, 115170},{401331, 115185},{399476, 111853},
					 {399441, 111838},{399426, 111803},{399441, 111768},{399476, 111753},{399511, 111768},{399526, 111803},{399511, 111838},{399476, 111853},{399289, 114953},{399254, 114938},
					 {399239, 114903},{399254, 114868},{399289, 114853},{399324, 114868},{399339, 114903},{399324, 114938},{399289, 114953},{401729, 111403},{401694, 111388},{401679, 111353},
					 {401694, 111318},{401729, 111303},{401764, 111318},{401779, 111353},{401764, 111388},{401729, 111403},{398696, 111791},{398661, 111776},{398646, 111741},{398661, 111706},
					 {398696, 111691},{398731, 111706},{398746, 111741},{398731, 111776},{398696, 111791}
					];
					attribute<point_rd> ok_empty: [];
					attribute<bool> test  := = #pointset == 0 ? 'point_isNearby(point, ok_empty, Dif_all_float32)' : 'point_isNearby(point, ok, Dif_all_float32)';
				}
				parameter<bool> test_attr   := all(pointset/test);
			}

			container results
			{
				parameter<bool> tests :=
					   point/test_attr 
					&& PointRow/test_attr 
					&& PointCol/test_attr 
					&& dist/test_attr 
					&& sqrdist/test_attr 
					&& point_in_polygon/test_attr 
					&& point_in_all_polygons/test_attr 
					&& point_in_ranked_polygon/test_attr 
					&& point_in_ranked_polygon/rank_constant/test_attr					
					&& dyna_point/CalcPoint/test_attr 
					&& dyna_point_tiled/CalcPoint/test_attr 
					&& dyna_point_empty/CalcPoint/test_attr 
					&& RD2LatLongWgs84/test_param
					&& RD2LatLongWgs84/test_attr
					&& LatLongWgs842RD/test_param
					&& LatLongWgs842RD/test_attr
					&& RD2LatLongGE/test_param
					&& RD2LatLongGE/test_attr
					&& RD2LatLongEd50/test_param
					&& RD2LatLongEd50/test_attr
					&& RD2LatLong/test_param
					&& RD2LatLong/test_attr
					&& bg_buffer_point/test_attr;
			}
		}
	}
	container Sequence
	{
		container srcDomain         := source(DistrictPointsDomain, RDomain, RoadDomain, HDomain, BuildingDomain);
		container srcTemplateDomain := source(DistrictPointsTiledDomain, RTiledDomain, RoadTiledDomain, HDomain, BuildingDomain);

		container srcEDomain        := Esource(EDomain, EDomain, EDomain, EDomain, EDomain);
		container srcETiledDomain   := Esource(ETiledDomain, ETiledDomain, ETiledDomain, EDomain,EDomain);

		template source
		{
			// begin case parameters
			unit<uint32> DistrictPointsDomain;
			unit<uint32> RDomain;
			unit<uint32> RoadDomain;
			unit<uint32> HDomain;
			unit<uint32> BuildingDomain;
			// end case parameters

			unit<uint32> pointset := DistrictPointsDomain
			,	DialogData = "point"
			,	DialogType = "map"
			{
				attribute<point_rd> point:
				[
					 {403025,113810},{402552,113711},{402558,113646},{402428,113636},{402448,113472},{402480,113244},{402503,113057},{402570,112883},{402576,112884},{402578,112876},{402647,112740},{402697,112555},{402698,112554},{402973,112471},{402977,112473},{403544,112312},{403552,112612},{403434,112809},{403298,113032},{403171,113401},{403025,113810}
					,{400990,113269},{400888,113291},{400886,113192},{400883,113120},{400916,112666},{400893,112424},{400817,112176},{400864,112187},{401157,112293},{401322,112404},{401494,112519},{401597,112589},{401558,112840},{401553,112888},{401288,112945},{401065,113187},{400990,113269}
					,{401238,115099},{401047,115164},{400978,114523},{400965,114314},{400926,113796},{400919,113685},{400888,113291},{400990,113269},{401065,113187},{401288,112945},{401553,112888},{401510,113137},{401550,113377},{401602,113684},{401642,113915},{401567,114437},{401475,114991},{401462,115075},{401238,115099}
					,{402174,113703},{402076,113691},{402076,113690},{401742,113655},{401723,113659},{401602,113684},{401510,113137},{401553,112888},{402697,112555},{402647,112740},{402578,112876},{402577,112876},{402576,112884},{402570,112883},{402503,113057},{402480,113244},{402448,113472},{402446,113472},{402428,113636},{402426,113634},{402414,113716},{402281,113770},{402174,113703}
					,{401531,114646},{401567,114437},{401642,113915},{401602,113684},{401723,113659},{401742,113655},{402077,113690},{402076,113691},{402076,113690},{402077,113690},{402174,113703},{402281,113770},{402272,113831},{402263,113896},{402199,114330},{402194,114374},{402223,114390},{402197,114497},{402086,114462},{402049,114612},{401988,114592},{401980,114626},{401803,114574},{401790,114655},{401765,114673},{401757,114803},{401545,114739},{401567,114983},{401475,114991},{401531,114646}
					,{402757,114546},{402404,114445},{402317,114418},{402192,114373},{402263,113896},{402281,113770},{402414,113716},{402428,113636},{402558,113646},{402552,113711},{403025,113810},{402870,114237},{402757,114546}
					,{405282,113562},{405282,113561},{405183,113537},{404996,113582},{404923,113297},{404776,113283},{404669,113160},{404669,113068},{404576,113022},{404353,113116},{404300,112976},{404256,112989},{404154,112857},{404063,112893},{403939,112611},{403770,112450},{403792,112379},{403544,112312},{402977,112473},{402973,112471},{402698,112554},{402697,112555},{401553,112888},{401558,112840},{401597,112589},{401494,112519},{401322,112404},{401157,112293},{400943,112215},{401063,111873},{401234,111711},{401477,111716},{401653,111646},{402133,111453},{402382,111433},{402859,111567},{403372,111821},{403701,111952},{403834,112009},{403934,112040},{404010,112054},{404157,112066},{404271,112054},{404555,111996},{404649,111969},{404664,111986},{404631,112040},{404620,112098},{405013,112720},{405495,113478},{405454,113512},{405415,113601},{405353,113625},{405282,113562}
				];
				attribute<district> districtnr:
				[
					0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
					1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
					2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
					3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,
					4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,
					5,5,5,5,5,5,5,5,5,5,5,5,5,
					6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6
				];
				attribute<uint32> ordinal:
				[
					0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,
					0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,
					0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,
					0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,
					0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,
					0,1,2,3,4,5,6,7,8,9,10,11,12,
					0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53
				];
			}
			unit<uint32> pointset_clean
			:	nrofrows   = 172
			,	DialogData = "point"
			,	DialogType = "map"
			{
				attribute<point_rd> point:
				[
//						 {403025,113810},{402552,113711},{402558,113646},{402428,113636},{402448,113472},{402480,113244},{402503,113057},{402570,112883},{402576,112884},{402578,112876},{402647,112740},{402697,112555},{402698,112554},{402973,112471},{402977,112473},{403544,112312},{403552,112612},{403434,112809},{403298,113032},{403171,113401},{403025,113810}
					 {403025,113810},{402552,113711},{402558,113646},{402428,113636},{402448,113472},{402480,113244},{402503,113057},{402570,112883},{402576,112884},{402647,112740},{402697,112555},{402698,112554},{402973,112471},{402977,112473},{403544,112312},{403552,112612},{403434,112809},{403298,113032},{403171,113401},{403025,113810}
					,{400990,113269},{400888,113291},{400886,113192},{400883,113120},{400916,112666},{400893,112424},{400817,112176},{400864,112187},{401157,112293},{401322,112404},{401494,112519},{401597,112589},{401558,112840},{401553,112888},{401288,112945},{401065,113187},{400990,113269}
					,{401238,115099},{401047,115164},{400978,114523},{400965,114314},{400926,113796},{400919,113685},{400888,113291},{400990,113269},{401065,113187},{401288,112945},{401553,112888},{401510,113137},{401550,113377},{401602,113684},{401642,113915},{401567,114437},{401475,114991},{401462,115075},{401238,115099}
					,{402174,113703},{402076,113691},{402076,113690},{401742,113655},{401723,113659},{401602,113684},{401510,113137},{401553,112888},{402697,112555},{402647,112740},{402576,112884},{402570,112883},{402503,113057},{402480,113244},{402448,113472},{402428,113636},{402414,113716},{402281,113770},{402174,113703}
					,{401531,114646},{401567,114437},{401642,113915},{401602,113684},{401723,113659},{401742,113655},{402077,113690},{402076,113691},{402076,113690},{402077,113690},{402174,113703},{402281,113770},{402272,113831},{402263,113896},{402199,114330},{402194,114374},{402223,114390},{402197,114497},{402086,114462},{402049,114612},{401988,114592},{401980,114626},{401803,114574},{401790,114655},{401765,114673},{401757,114803},{401545,114739},{401567,114983},{401475,114991},{401531,114646}
					,{402757,114546},{402404,114445},{402317,114418},{402192,114373},{402263,113896},{402281,113770},{402414,113716},{402428,113636},{402558,113646},{402552,113711},{403025,113810},{402870,114237},{402757,114546}
					,{405282,113562},{405282,113561},{405183,113537},{404996,113582},{404923,113297},{404776,113283},{404669,113160},{404669,113068},{404576,113022},{404353,113116},{404300,112976},{404256,112989},{404154,112857},{404063,112893},{403939,112611},{403770,112450},{403792,112379},{403544,112312},{402977,112473},{402973,112471},{402698,112554},{402697,112555},{401553,112888},{401558,112840},{401597,112589},{401494,112519},{401322,112404},{401157,112293},{400943,112215},{401063,111873},{401234,111711},{401477,111716},{401653,111646},{402133,111453},{402382,111433},{402859,111567},{403372,111821},{403701,111952},{403834,112009},{403934,112040},{404010,112054},{404157,112066},{404271,112054},{404555,111996},{404649,111969},{404664,111986},{404631,112040},{404620,112098},{405013,112720},{405495,113478},{405454,113512},{405415,113601},{405353,113625},{405282,113562}
				];
				attribute<district> districtnr:
				[
					0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
					1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
					2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
					3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,
					4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,
					5,5,5,5,5,5,5,5,5,5,5,5,5,
					6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6
				];
				attribute<uint32> ordinal:
				[
					0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,
					0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,
					0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,
					0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,
					0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,
					0,1,2,3,4,5,6,7,8,9,10,11,12,
					0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53
				];
			}
			unit<uint32> district := RDomain
			,	DialogType = "map"
			,	DialogData = "border_clean"
			{
				attribute<string>   id_str                   := string(id(.))
				{
					parameter<float32> labelsize := 20f, DialogType = "LabelSize";
				}
				attribute<point_rd> border (.,polygon)       := points2sequence(pointset/point, pointset/districtnr, pointset/ordinal)
				{
					parameter<uint32> Brushcolor := rgb(0,255,0), DialogType = "BrushColor";
					parameter<uint32> Pencolor   := rgb(0,0,0)  , DialogType = "PenColor";
				}
				attribute<point_rd> border_clean (.,polygon) := points2sequence(pointset_clean/point, pointset_clean/districtnr, pointset_clean/ordinal)
				{
					parameter<color> pencolor: [rgb(0,0,0)], DialogType = "pencolor";
				}
			
				attribute<int16>   h                    := const(20, district, int16);
				attribute<m>       arc_length:          [4305.7099609375,3136.7900390625,5338.419921875,4064.23999023438,4140.56982421875,2887.59008789063,12093];
				attribute<m2>      area:                [1003100,474460,1246460,921490,620178,499970,3711010];
				attribute<float32> first_nodeX:         [113810,113269,115099,113703,114646,114546,113562];
				attribute<float32> first_nodeY:         [403025,400990,401238,402174,401531,402757,405282];
				attribute<float32> last_nodeX:          [113810,113269,115099,113703,114646,114546,113562];
				attribute<float32> last_nodeY:          [403025,400990,401238,402174,401531,402757,405282];
				attribute<uint32>  lb_X:                [112312,112176,112888,112555,113655,113636,111433];
				attribute<uint32>  lb_Y:                [402428,400817,400888,401510,401475,402192,400943];
				attribute<uint32>  ub_X:                [113810,113291,115164,113770,114991,114546,113625];
				attribute<uint32>  ub_Y:                [403552,401597,401642,402697,402281,403025,405495];
				attribute<uint32>  cb_X:                [113061,112733,114026,113162,114323,114091,112529];
				attribute<uint32>  cb_Y:                [402990,401207,401265,402103,401878,402608,403219];
				attribute<uint32>  cen_X:               [113049,112704,114016,113183,114185,114086,112309];
				attribute<uint32>  cen_Y:               [402954,401159,401268,402069,401879,402578,403083];
				attribute<uint32>  mid_X:               [113136,112700,114029,113212,114131,114104,112036];
				attribute<uint32>  mid_Y:               [402944,401128,401271,402083,401872,402574,402836];

				attribute<region>        region_rel:       [0,1,1,1,2,2,3];
				attribute<multipolygon>  multipolygon_rel: [0,0,1,2,0,1,3];
			}
			unit<uint32> region:= HDomain
			{
				attribute<uint32> BrushColor: [rgb(255,0,0),rgb(0,255,0),rgb(255,255,0),rgb(255,128,0)], DialogType = "BrushColor";
			}
			unit<uint32> multipolygon:= HDomain
			{
				attribute<uint32> BrushColor: [rgb(255,0,0),rgb(0,255,0),rgb(255,255,0),rgb(255,128,0)], DialogType = "BrushColor";
			}

			unit<uint32> RoadCoordinates := RDomain,
				DialogData  = "point",
				DialogType  = "Map"
			{
				attribute<float32>  x: [112631,111866,111866,111924,111524,114921,114823];
				attribute<float32>  y: [399246,398599,398599,399495,401801,401529,398584];

				attribute<float32>  x_cross: [112028,114311,111999,114325,114325, 113214,113362];
				attribute<float32>  y_cross: [401329,401325,399434,399456,399456, 400079,398754];
				
				attribute<point_rd> point       := point(y, x, /point_rd), Label = "RoadPoints";
				attribute<point_rd> point_cross := point(y_cross, x_cross, /point_rd), Label = "RoadPoints";

				attribute<road>     SequenceNr: [0,0,1,1,1,2,2];
				attribute<uint32>   Ordinal:    [0,1,0,1,2,0,1];
			}
			unit<uint32> road := RoadDomain,
				DialogData  = "line",
				DialogType  = "Map"
			{
				attribute<point_rd> line       (arc) := points2sequence(RoadCoordinates/Point, RoadCoordinates/SequenceNr, RoadCoordinates/Ordinal);
				attribute<point_rd> line_cross (arc) := points2sequence(RoadCoordinates/point_cross, RoadCoordinates/SequenceNr, RoadCoordinates/Ordinal);
				
				attribute<m>        arc_length: [1001.92, 3238.31, 2946.63];
				attribute<point_rd> node_first: [{399246, 112631}, {398599, 111866}, {401529, 114921}];
				attribute<point_rd> node_last:  [{398599, 111866}, {401801, 111524}, {398584, 114823}];
			}

			unit<uint32> building:= BuildingDomain,
				DialogData  = "boundary",
				DialogType  = "Map"
			{
				attribute<string>   label := string(id(.)), DialogType = "LabelText";
				attribute<point_rd> boundary (polygon) := points2sequence(pointset/point,pointset/sequence,pointset/ordinal)
				{
					parameter<color> brushcolor: [rgb(200,0,0)], DialogType = "BrushColor";
					parameter<color> pencolor:   [rgb(0,0,0)  ], DialogType = "pencolor";
				}

				unit<Uint32> pointset
				:	nrofrows   = 30
				,	DialogType = "Map"
				,	DialogData = "point"
				{
					attribute<point_rd> point:
					[
						{403391,113264},{403236,113351},{403211,113580},{403354,113586},{403391,113264},
						{402986,112949},{402979,113243},{402822,113243},{402842,112916},{402986,112949},
						{403460,112889},{403226,112906},{403233,113049},{403487,113032},{403460,112889},
						{403152,113727},{402959,113696},{402945,113859},{403135,113862},{403152,113727},
						{402362,112601},{402192,112581},{402192,112767},{402406,112764},{402362,112601},
						{402508,113567},{402477,113883},{402213,113856},{402230,113550},{402508,113567}
					]
					;
					attribute<building> sequence:
					[
						0,0,0,0,0,
						1,1,1,1,1,
						2,2,2,2,2,
						3,3,3,3,3,
						4,4,4,4,4,
						5,5,5,5,5
					];
					attribute<uint32> ordinal:
					[
						0,3,2,1,4,
						0,1,2,3,4,
						0,3,2,1,4,
						0,3,2,1,4,
						0,3,2,1,4,
						0,1,2,3,4
					];
				}
			}
			unit<uint32> square: nrofrows = 1
			{
				attribute<ipoint> boundary_dif   (poly) := points2sequence(pointset/point_dif   ,const(0,pointset,.), id(pointset));
				attribute<ipoint> boundary_mul   (poly) := points2sequence(pointset/point_mul   ,const(0,pointset,.), id(pointset));
				attribute<ipoint> boundary_plus1 (poly) := points2sequence(pointset/point_plus1 ,const(0,pointset,.), id(pointset));
				attribute<ipoint> boundary_plus2 (poly) := points2sequence(pointset/point_plus2 ,const(0,pointset,.), id(pointset));

				unit<uint32> pointset: nrofrows = 5
				{
					attribute<ipoint> point_dif   : [{400000,110000},{406000, 110000},{406000, 116000},{400000, 116000},{400000, 110000}];
					attribute<ipoint> point_mul   : [{400000,110000},{403000, 110000},{403000, 116000},{400000, 116000},{400000, 110000}];
					attribute<ipoint> point_plus1 : [{400000,110000},{406000, 110000},{406000, 116000},{400000, 116000},{400000, 110000}];
					attribute<ipoint> point_plus2 : [{410000,110000},{416000, 110000},{416000, 116000},{410000, 116000},{410000, 110000}];
				}
			}
			container bg_simplify
			{
				unit<Uint32> pointset_border
				:	nrofrows   = 56
				,	DialogType = "Map"
				,	DialogData = "point"
				{
					attribute<point_rd> point:
					[
					  {403025, 113810},{402428, 113636},{402503, 113057},{402698, 112554},{403544, 112312},{403552, 112612},{403025, 113810},{400990, 113269},{400888, 113291},{400817, 112176}
					 ,{401597, 112589},{401553, 112888},{401288, 112945},{400990, 113269},{401238, 115099},{401047, 115164},{400888, 113291},{401553, 112888},{401642, 113915},{401462, 115075}
					 ,{401238, 115099},{402174, 113703},{401602, 113684},{401553, 112888},{402697, 112555},{402414, 113716},{402174, 113703},{401531, 114646},{401602, 113684},{402281, 113770}
					 ,{402197, 114497},{401803, 114574},{401757, 114803},{401545, 114739},{401475, 114991},{401531, 114646},{402757, 114546},{402192, 114373},{402428, 113636},{403025, 113810}
					 ,{402757, 114546},{405282, 113562},{404996, 113582},{404669, 113068},{404353, 113116},{403792, 112379},{403544, 112312},{401553, 112888},{401597, 112589},{400943, 112215}
					 ,{401063, 111873},{402382, 111433},{403934, 112040},{404649, 111969},{405495, 113478},{405282, 113562}
					]
					;
					attribute<building> sequence:
					[
					  0,0,0,0,0,0,0,1,1,1,1,1,1,1,2,2,2,2,2,2,2,3,3,3,3,3,3,4,4,4,4,4,4,4,4,4,5,5,5,5,5,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6
					];

					attribute<uint32> ordinal:
					[
					  0,1,2,3,4,5,6,0,1,2,3,4,5,6,0,1,2,3,4,5,6,0,1,2,3,4,5,0,1,2,3,4,5,6,7,8,0,1,2,3,4,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14
					];
				}
				unit<Uint32> pointset_poly
				:	nrofrows   = 50
				,	DialogType = "Map"
				,	DialogData = "point"
				{
					attribute<point_rd> point:
					[
					  {403544, 112312},{403552, 112612},{403025, 113810},{402428, 113636},{402697, 112555},{403544, 112312},{400817, 112176},{401597, 112589},{401553, 112888},{400888, 113291}
					 ,{400817, 112176},{401553, 112888},{401642, 113915},{401462, 115075},{401047, 115164},{400888, 113291},{401553, 112888},{402697, 112555},{402414, 113716},{401602, 113684}
					 ,{401553, 112888},{402697, 112555},{402281, 113770},{402197, 114497},{401803, 114574},{401757, 114803},{401545, 114739},{401475, 114991},{401602, 113684},{402281, 113770}
					 ,{402428, 113636},{403025, 113810},{402757, 114546},{402192, 114373},{402428, 113636},{401063, 111873},{402382, 111433},{403934, 112040},{404649, 111969},{405495, 113478}
					 ,{405353, 113625},{404996, 113582},{404669, 113068},{404353, 113116},{403792, 112379},{403544, 112312},{401553, 112888},{401597, 112589},{400943, 112215},{401063, 111873}
					]
					;
					attribute<building> sequence:
					[
					  0,0,0,0,0,0,1,1,1,1,1,2,2,2,2,2,2,3,3,3,3,3,4,4,4,4,4,4,4,4,5,5,5,5,5,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6
					];

					attribute<uint32> ordinal:
					[
					  0,1,2,3,4,5,0,1,2,3,4,0,1,2,3,4,5,0,1,2,3,4,0,1,2,3,4,5,6,7,0,1,2,3,4,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14
					];
				}
			}
			container bg_buffer_multi_polygon
			{
				unit<uint32> poly := SDomain 
				{
					attribute<point_rd> geometry (poly):= points2Sequence(pointset_poly/point, pointset_poly/sequence, pointset_poly/ordinal);
				}
	
				unit<uint32> pointset_poly :	nrofrows   = 17
				{
					attribute<point_rd> point:
					[
					  {158100, 461100},{157950, 461100},{157950, 460900},{158100, 460900},{158100, 461100} 
					 ,{158500, 461500},{157500, 461500},{157500, 460500},{158500, 460500},{158500, 461500}
					 ,{158200, 461200},{158200, 460800},{157800, 460800},{157800, 461200},{158200, 461200}
					 ,{158500, 461500},{158100, 461100}
					];
					attribute<poly>   sequence := const(0[poly],.);
					attribute<uint32> ordinal  := id(.);
				}
			}
		}

		template Esource
		{
			// begin case parameters
			unit<uint32> DistrictPointsDomain;
			unit<uint32> RDomain;
			unit<uint32> RoadDomain;
			unit<uint32> HDomain;
			unit<uint32> BuildingDomain;
			// end case parameters

			unit<uint32> pointset := DistrictPointsDomain
			,	DialogData = "point"
			,	DialogType = "map"
			{
				attribute<point_rd> point:
				[
				];
				attribute<district> districtnr:
				[
				];
				attribute<uint32> ordinal:
				[
				];
			}
			unit<uint32> pointset_clean
			:	nrofrows   = 0
			,	DialogData = "point"
			,	DialogType = "map"
			{
				attribute<point_rd> point:
				[
				];
				attribute<district> districtnr:
				[
				];
				attribute<uint32> ordinal:
				[
				];
			}
			unit<uint32> district := RDomain
			,	DialogType = "map"
			,	DialogData = "border_clean"
			{
				attribute<string>   id_str                   := string(id(.))
				{
					parameter<float32> labelsize := 20f, DialogType = "LabelSize";
				}
				attribute<point_rd> border (.,polygon)       := points2sequence(pointset/point, pointset/districtnr, pointset/ordinal);
				attribute<point_rd> border_clean (.,polygon) := points2sequence(pointset_clean/point, pointset_clean/districtnr, pointset_clean/ordinal)
				{
					parameter<color> pencolor: [rgb(0,0,0)], DialogType = "pencolor";
				}
			
				attribute<int16>   h                    := const(20, district, int16);
				attribute<m>       arc_length:          [];
				attribute<m2>      area:                [];
				attribute<float32> first_nodeX:         [];
				attribute<float32> first_nodeY:         [];
				attribute<float32> last_nodeX:          [];
				attribute<float32> last_nodeY:          [];
				attribute<uint32>  lb_X:                [];
				attribute<uint32>  lb_Y:                [];
				attribute<uint32>  ub_X:                [];
				attribute<uint32>  ub_Y:                [];
				attribute<uint32>  cb_X:                [];
				attribute<uint32>  cb_Y:                [];
				attribute<uint32>  cen_X:               [];
				attribute<uint32>  cen_Y:               [];
				attribute<uint32>  mid_X:               [];
				attribute<uint32>  mid_Y:               [];

				attribute<region>        region_rel:       [];
				attribute<multipolygon>  multipolygon_rel: [];
			}
			unit<uint32> region:= HDomain
			{
				attribute<uint32> BrushColor: [], DialogType = "BrushColor";
			}
			unit<uint32> multipolygon:= HDomain
			{
				attribute<uint32> BrushColor: [], DialogType = "BrushColor";
			}

			unit<uint32> RoadCoordinates := RDomain,
				DialogData  = "point",
				DialogType  = "Map"
			{
				attribute<float32>  x: [];
				attribute<float32>  y: [];

				attribute<float32>  x_cross: [];
				attribute<float32>  y_cross: [];
				
				attribute<point_rd> point       := point(y, x, /point_rd), Label = "RoadPoints";
				attribute<point_rd> point_cross := point(y_cross, x_cross, /point_rd), Label = "RoadPoints";

				attribute<road>     SequenceNr: [];
				attribute<uint32>   Ordinal:    [];
			}
			unit<uint32> road := RoadDomain,
				DialogData  = "line",
				DialogType  = "Map"
			{
				attribute<point_rd> line       (arc) := points2sequence(RoadCoordinates/Point, RoadCoordinates/SequenceNr, RoadCoordinates/Ordinal);
				attribute<point_rd> line_cross (arc) := points2sequence(RoadCoordinates/point_cross, RoadCoordinates/SequenceNr, RoadCoordinates/Ordinal);
				
				attribute<m>        arc_length: [];
				attribute<point_rd> node_first: [];
				attribute<point_rd> node_last:  [];
			}
			unit<uint32> building:= BuildingDomain,
				DialogData  = "boundary",
				DialogType  = "Map"
			{
				attribute<string>   label := string(id(.)), DialogType = "LabelText";
				attribute<point_rd> boundary (polygon) := points2sequence(pointset/point,pointset/sequence,pointset/ordinal)
				{
					parameter<color> brushcolor: [rgb(200,0,0)], DialogType = "BrushColor";
					parameter<color> pencolor:   [rgb(0,0,0)  ], DialogType = "pencolor";
				}

				unit<Uint32> pointset
				:	nrofrows   = 30
				,	DialogType = "Map"
				,	DialogData = "point"
				{
					attribute<point_rd> point:
					[
					]
					;
					attribute<building> sequence:
					[
					];
					attribute<uint32> ordinal:
					[
					];
				}
			}
			unit<uint32> square: nrofrows = 0
			{
				attribute<ipoint> boundary_dif   (poly) := points2sequence(pointset/point_dif   ,const(0,pointset,.), id(pointset));
				attribute<ipoint> boundary_mul   (poly) := points2sequence(pointset/point_mul   ,const(0,pointset,.), id(pointset));
				attribute<ipoint> boundary_plus1 (poly) := points2sequence(pointset/point_plus1 ,const(0,pointset,.), id(pointset));
				attribute<ipoint> boundary_plus2 (poly) := points2sequence(pointset/point_plus2 ,const(0,pointset,.), id(pointset));

				unit<uint32> pointset: nrofrows = 0
				{
					attribute<ipoint> point_dif   : [];
					attribute<ipoint> point_mul   : [];
					attribute<ipoint> point_plus1 : [];
					attribute<ipoint> point_plus2 : [];
				}
			}
			container bg_simplify
			{
				unit<Uint32> pointset: nrofrows = 0
				{
					attribute<point_rd> point:
					[
					]
					;
					attribute<building> sequence:
					[
					];

					attribute<uint32> ordinal:
					[
					];
				}
			}
			container bg_buffer_multi_polygon
			{
				unit<uint32> poly := SDomain 
				{
					attribute<point_rd> geometry (poly):= points2Sequence(pointset_poly/point, pointset_poly/sequence, pointset_poly/ordinal);
				}
	
				unit<uint32> pointset_poly :	nrofrows   = 0
				{
					attribute<point_rd> point:
					[
					];
					attribute<poly>   sequence := const(0[poly],.);
					attribute<uint32> ordinal  := id(.);
				}
			}
		}
		container UnTiled := Template(DistrictPointsDomain, RDomain, RoadDomain, HDomain,BuildingDomain, SDomain, srcDomain)
		{
			container canyon: Using = "source"
			{
				unit<uint32> arcpoints: 
					nrofrows = 3,
					DialogType = "Map",
					Dialogdata = "point" 
				{
					attribute<float32>   x:   [371350, 371375, 371400];
					attribute<float32>   y:   [ 13770, 13750,   13725];
					attribute<fpoint>    point := point(y,x,fpoint);
					attribute<arcdomain> seq: [0,0,0];
					attribute<uint32>    ord: [0,1,2];
				}
				unit<uint32> arcdomain:
					nrofrows   = 1,
					DialogType = "Map",
					Dialogdata = "lijn" 
				{
					attribute<fpoint> lijn (arc) := points2sequence(arcpoints/point, arcpoints/seq, arcpoints/ord);
					attribute<int16>  h          := const(20, arcdomain, int16);
				}
				parameter<int16> minHeight       := value(5, int16);
				parameter<m>     maxCanyonDist   := value(1000, m);
	
				container dyna_point
				{
					attribute<float32> xp        (ADomain): [371391, 371384, 371378, 371369, 371364];
					attribute<float32> yp        (ADomain): [ 13732,  13738,  13746,  13758,  13764];
					attribute<float32> xn        (ADomain): [371384, 371378, 371369, 371364, 371360];
					attribute<float32> yn        (ADomain): [ 13738,  13746,  13758,  13764,  13768];
					attribute<fpoint>  point     (ADomain) := point(yp,xp,fpoint);
					attribute<fpoint>  nextpoint (ADomain) := point(yn,xn,fpoint);
					parameter<float32> CalcDist            := float32(5);
					unit<uint32> CalcPoint                 := dyna_point(point, nextpoint, CalcDist)
					{
						attribute<ADomain> seq: [0,0,1,1,2,2,2,3,3,4];
						attribute<int16>   z:   [10,30,20,15,20,0,20,60,15, null];
					}
				}
				container results := 
					canyon(
						dyna_point/CalcPoint/point, dyna_point/CalcPoint/z, dyna_point/CalcPoint/seq, dyna_point/point, dyna_point/nextpoint, 
						arcdomain/lijn, arcdomain/h, 
						minHeight, maxCanyonDist
					)
				{
					attribute<float32> rrc (dyna_point/CalcPoint): DialogType = "Map", DialogData = "RLoc";
					attribute<float32> lrc (dyna_point/CalcPoint): DialogType = "Map", DialogData = "RLoc";
				}
				parameter<bool> test_attr := 
					point_isNearby(results/Rloc[0], point(float32(13732.6), float32(371392), fpoint), Dif_all_float32) && 
					point_isNearby(results/Rloc[3], point(float32(13742.6), float32(371381), fpoint), Dif_all_float32) && 
					isNull(results/Rloc[5]) && 
					isNull(results/Lloc[0]) && 
					point_isNearby(results/Lloc[3], point(float32(13742.6), float32(371381), fpoint), Dif_all_float32) && 
					point_isNearby(results/Lloc[8], point(float32(13760), float32(371362), fpoint), Dif_all_float32) && 
					point_isNearby(results/Lloc[9], point(float32(13763), float32(371359), fpoint), Dif_all_float32);
			}
			container canyon_empty: Using = "source"
			{
				unit<uint32> arcpoints: 
					nrofrows = 0,
					DialogType = "Map",
					Dialogdata = "point" 
				{
					attribute<float32>   x:   [];
					attribute<float32>   y:   [];
					attribute<fpoint>    point := point(y,x,fpoint);
					attribute<arcdomain> seq: [];
					attribute<uint32>    ord: [];
				}
				unit<uint32> arcdomain:
					nrofrows   = 0,
					DialogType = "Map",
					Dialogdata = "lijn" 
				{
					attribute<fpoint> lijn (arc) := points2sequence(arcpoints/point, arcpoints/seq, arcpoints/ord);
					attribute<int16>  h          := const(20, arcdomain, int16);
				}
				parameter<int16> minHeight       := value(5, int16);
				parameter<m>     maxCanyonDist   := value(1000, m);
	
				container dyna_point
				{
					attribute<float32> xp        (EDomain): [];
					attribute<float32> yp        (EDomain): [];
					attribute<float32> xn        (EDomain): [];
					attribute<float32> yn        (EDomain): [];
					attribute<fpoint>  point     (EDomain) := point(yp,xp,fpoint);
					attribute<fpoint>  nextpoint (EDomain) := point(yn,xn,fpoint);
					parameter<float32> CalcDist            := float32(5);
					unit<uint32> CalcPoint                 := dyna_point(point, nextpoint, CalcDist)
					{
						attribute<EDomain> seq: [];
						attribute<int16>   z:   [];
					}
				}
				container results := 
					canyon(
						dyna_point/CalcPoint/point, dyna_point/CalcPoint/z, dyna_point/CalcPoint/seq, dyna_point/point, dyna_point/nextpoint, 
						arcdomain/lijn, arcdomain/h, 
						minHeight, maxCanyonDist
					)
				{
					attribute<float32> rrc (dyna_point/CalcPoint): DialogType = "Map", DialogData = "RLoc";
					attribute<float32> lrc (dyna_point/CalcPoint): DialogType = "Map", DialogData = "RLoc";

					attribute<float32> CRLoc (dyna_point/CalcPoint):= PointCol(RLoc);
					attribute<float32> RRLoc (dyna_point/CalcPoint):= PointRow(RLoc);

					attribute<float32> CLLoc (dyna_point/CalcPoint):= PointCol(LLoc);
					attribute<float32> RLLoc (dyna_point/CalcPoint):= PointRow(LLoc);

					attribute<float32> Ok (dyna_point/CalcPoint):[];

					attribute<bool> TestCRLoc (dyna_point/CalcPoint):= CRLoc == Ok;
					attribute<bool> TestRRLoc (dyna_point/CalcPoint):= RRLoc == Ok;

					attribute<bool> TestCLLoc (dyna_point/CalcPoint):= CLLoc == Ok;
					attribute<bool> TestRLLoc (dyna_point/CalcPoint):= RLLoc == Ok;
				}

				parameter<bool> test_attr := all(results/TestCRLoc) && all(results/TestRRLoc) && all(results/TestCLLoc) && all(results/TestRLLoc);
			}
		}

		container EUnTiled := Template(EDomain, EDomain, EDomain, EDomain,EDomain,EDomain, srcEDomain);

		container  Tiled := Template(DistrictPointsTiledDomain, RTiledDomain, RoadTiledDomain, HDomain, BuildingDomain, SDomain, srcTemplateDomain);
		container ETiled := Template(ETiledDomain, ETiledDomain, ETiledDomain, EDomain, EDomain, EDomain, srcETiledDomain);

		container ResultUnitTiled
		{
			container make_sequence 
			{
				attribute<point_rd> sequence (ATiledDomain, poly) := 
					points2sequence(Point/ResultUnitTiled/dyna_point_tiled/CalcPoint/Point, Point/ResultUnitTiled/dyna_point_tiled/CalcPoint/SequenceNr, Point/ResultUnitTiled/dyna_point_tiled/CalcPoint/Ordinal);
			}
			unit<uint32> sequence2points := sequence2points(make_sequence/sequence)
			{
				attribute<float32> x          := PointCol(point);
				attribute<float32> y          := PointRow(point);
				parameter<bool>    test_point := float_isNearby(mean(x), 371378.637f, Dif_all_float32) && float_isNearby(mean(y), 13745.7163f, Dif_all_float32);
				parameter<bool>    test_attr  := test_point && #. == 476867 && sum(SequenceNr) = 860582 && max(Ordinal) == 149999 && ordinal[270787] == 78591;
			}
			container make_large_polygonset
			{
				unit<uint32> orgdomain := point/ResultUnitTiled/dyna_point_tiled/CalcPoint;
				unit<uint32> pointset := union_unit(orgdomain, orgdomain, orgdomain, orgdomain)
				{
					attribute<fpoint> point := union_data(
						.
						, orgdomain/point
						, orgdomain/point + point(10f, 5f, fpoint)
						, orgdomain/point + point(0f, 10f, fpoint)
						,orgdomain/point
					);
					attribute<orgdomain> SequenceNr := union_data(., id(orgdomain), id(orgdomain), id(orgdomain), id(orgdomain));
					attribute<uint32>    Ordinal    := union_data(., const(0, orgdomain), const(1, orgdomain), const(2, orgdomain), const(3, orgdomain));
				}
				attribute<fpoint>  set  (polygon, orgdomain) := points2sequence(pointset/point, pointset/sequenceNr, pointset/Ordinal);
				
				attribute<float32> area (orgdomain) := area(set, float32);
				
				unit<uint32> subset := subset(id(orgdomain) <  75000)
				{
					attribute<ipoint>  set  (polygon) := ipolygon(make_large_polygonset/set[nr_OrgEntity]);
				}
			}
			unit<uint32>  overlay_polygon := overlay_polygon(make_large_polygonset/subset/set, make_large_polygonset/subset/set[0])
			{
				parameter<bool>    test_attr  := #. == 75000 && max(first_rel) == 74999;
			}
		}

		Template Template
		{
			// begin case parameters
			unit<uint32> DistrictPointsDomain;
			unit<uint32> District;
			unit<uint32> RoadDomain;
			unit<uint32> Region;
			unit<uint32> Building;
			unit<uint32> SingleDomain;
			container source;
			// end case parameters

			container conversions
			{
				attribute<dpoint> roadline_dpolygon   (RoadDomain,arc) := dpolygon(Source/road/line);
				attribute<upoint> roadline_upolygon   (RoadDomain,arc) := upolygon(Source/road/line);
				attribute<wpoint> roadline_wpolygon   (RoadDomain,arc) := wpolygon(Source/road/line);
				attribute<fpoint> roadline_fdpolygon  (RoadDomain,arc) := fpolygon(roadline_dpolygon);
				attribute<fpoint> roadline_fupolygon  (RoadDomain,arc) := fpolygon(roadline_upolygon);
				attribute<fpoint> roadline_fwpolygon  (RoadDomain,arc) := fpolygon(roadline_wpolygon);
				attribute<bool>   test_fdpolygon      (RoadDomain)     := point_isNearby(centroid(roadline_fdpolygon), centroid(Source/road/line), Dif_all_float32);
				attribute<bool>   test_fupolygon      (RoadDomain)     := point_isNearby(centroid(roadline_fupolygon), centroid(Source/road/line), Dif_all_float32);
				attribute<bool>   isnull_fwpolygon    (RoadDomain)     := isNull(roadline_fwpolygon);
				attribute<bool>   isdefined_fwpolygon (RoadDomain)     := isDefined(roadline_fwpolygon);
				
			}
			unit<uint32> sequence2points := sequence2points(Source/road/line),
				url  = "http://www.objectvision.hosting.it-rex.nl/geodms/operators-a-functions/sequence/sequence2points"
			{
				attribute<float32>    x:   [112631,111866,111866,111924,111524,114921,114823];
				attribute<float32>    y:   [399246,398599,398599,399495,401801,401529,398584];
				attribute<point_rd>   poi := point(y,x,point_rd);
				attribute<RoadDomain> seq:[0,0,1,1,1,2,2];
				attribute<uint32>     ord:[0,1,0,1,2,0,1];
				attribute<bool>       test      := point = poi && SequenceNr = seq && Ordinal = ord;
				parameter<bool>       test_attr := = #RoadDomain == 0 ? '#sequence2points == 0' : 'all(test)';
			}
			unit<uint32> sequence2points_param := Sequence2Points(Source/road/line[0]);

			container points2sequence:
				Using = "source",
				url   = "http://www.objectvision.hosting.it-rex.nl/geodms/operators-a-functions/sequence/points2sequence"
			{
				attribute<point_rd> att    (RoadDomain, arc) := points2sequence(sequence2points/point, sequence2points/SequenceNr, sequence2points/Ordinal);
				attribute<point_rd> att_ps (RoadDomain, arc) := points2sequence(sequence2points/point, sequence2points/SequenceNr);
				attribute<bool> test       (RoadDomain)      := arc_length(att, /m) == arc_length(Source/road/line, /m) && lower_bound(att) = lower_bound(Source/road/line);
				parameter<bool> test_attr              := all(test);
			}

			parameter<point_rd> points2sequence_param   (poly) := points2sequence(sequence2points_param/point);
			parameter<point_rd> points2sequence_param_p (poly) := points2sequence_p(sequence2points_param/point);
			parameter<point_rd> points2sequence_param_po(poly) := points2sequence_po(sequence2points_param/point, sequence2points_param/ordinal);

			container arc_length:
				Using = "source",
				url   = "http://www.objectvision.hosting.it-rex.nl/geodms/operators-a-functions/sequence/arc_length"
			{
				attribute<m>    att  (RoadDomain) := arc_length(road/line, /m);
				attribute<bool> test (RoadDomain) := float_isNearby(att,road/arc_length, Dif_all_float32);
				parameter<bool> test_attr   := all(test);
			}
			container area:
				Using = "source",
				url   = "http://www.objectvision.hosting.it-rex.nl/geodms/operators-a-functions/sequence/area"
			{
				attribute</m2>  att  (district) := area(district/border, /m2);
				attribute<bool> test (district) := float_isNearby(att, district/area, Dif_all_float32);
				parameter<bool> test_attr       := all(test);
			}

			container lower_bound:
				Using = "source",
				url = "http://www.objectvision.hosting.it-rex.nl/geodms/operators-a-functions/sequence/lower_bound",
				DialogType = "Map",
				DialogData = "att"
			{
				attribute<point_rd> att  (district) := lower_bound(district/border);
				attribute<bool>     test (district) := uint32(pointcol(att)) = district/lb_X && uint32(pointrow(att)) = district/lb_Y;
				parameter<bool>     test_attr       := all(test);
			}
			container upper_bound:
				Using = "source",
				url = "http://www.objectvision.hosting.it-rex.nl/geodms/operators-a-functions/sequence/upper_bound",
				DialogType = "Map",
				DialogData = "att"
			{
				attribute<point_rd> att  (district) := upper_bound(district/border);
				attribute<bool>     test (district) := uint32(pointcol(att)) = district/ub_X && uint32(pointrow(att)) = district/ub_Y;
				parameter<bool>     test_attr       := all(test);
			}
			container center_bound:
				Using = "source",
				url = "http://www.objectvision.hosting.it-rex.nl/geodms/operators-a-functions/sequence/center_bound",
				DialogType = "Map",
				DialogData = "att"
			{
				attribute<point_rd> att  (district) := center_bound(district/border);
				attribute<bool>     test (district) := uint32(pointcol(att)) = district/cb_X && uint32(pointrow(att)) = district/cb_Y;
				parameter<bool>     test_attr       := all(test);
			}
			container centroid:
				Using = "source",
				url   = "http://www.objectvision.hosting.it-rex.nl/geodms/operators-a-functions/sequence/centroid",
				DialogType = "Map",
				DialogData = "att"
			{
				attribute<point_rd> att  (district) := centroid(district/border);
				attribute<bool>     test (district) := uint32(pointcol(att)) = district/cen_X && uint32(pointrow(att)) = district/cen_Y;
				parameter<bool>     test_attr       := all(test);
			}
			container mid:
				Using = "source",
				url   = "http://www.objectvision.nl/dms/Operator/mid.htm",
				DialogType = "Map",
				DialogData = "att"
			{
				attribute<point_rd> att  (district) := mid(district/border);
				attribute<bool>     test (district) := uint32(pointcol(att)) = district/mid_X && uint32(pointrow(att)) = district/mid_Y;
				parameter<bool>     test_attr       := all(test);
			}
			container centroid_or_mid:
				Using = "source",
				url   = "http://www.objectvision.hosting.it-rex.nl/geodms/operators-a-functions/sequence/centroidormid",
				DialogType = "Map",
				DialogData = "att"
			{
				attribute<point_rd> att  (district) := centroid_or_mid(district/border);
				attribute<uint32>   row  (district) := uint32(pointrow(att));
				attribute<uint32>   col  (district) := uint32(pointcol(att));
				attribute<bool>     test (district) := uint32(pointcol(att)) = district/cen_X && uint32(pointrow(att)) = district/cen_Y;
				parameter<bool>     test_attr       := all(test);
			}
			unit<uint32> centroid_or_mid_complex
			:	StorageName     = "%projdir%/data/vreemde_centroids.shp"
			,	StorageType     = "gdal.vect"
			,	StorageReadOnly = "True"
			,	DialogType      = "Map"
			,	DialogData      = "geometry"
			{
				attribute<fpoint> geometry    (poly);
				
				attribute<fpoint> centroid_or_mid := centroid_or_mid(geometry);
				attribute<fpoint> centroid_or_mid_ok :
				[
					{570688, 213124},{545707, 266894},{593829, 195839},{579749, 181494},{557506, 234192},
					{492360, 226704},{531238, 179570},{504546, 201889},{504546, 201818},{435546, 151718},
					{423152, 192347},{463897, 224657},{479639, 129911},{513259, 108758},{504635, 127431},
					{523538, 144358},{437711, 97081.1},{428406, 83605.5},{452393, 94601.6},{392716, 154336},
					{420523, 167482},{505987, 167453},{445904, 159590},{444165, 235727},{549220, 249842},
					{343412, 185136}
				];

				attribute<bool> test      := point_isNearby(centroid_or_mid, centroid_or_mid_ok, Dif_all_float32);
				parameter<bool> test_attr := all(test);
			}
			container poly2grid
			{
				attribute<District> DistrictGrid (gridcel_1km) := poly2grid(Source/District/border, gridcel_1km);
				
				attribute<District> att_ok       (gridcel_1km):
				[
					null,null,null,null,null,6,null,null,6,0,null,null,6,3,4,null,null,1,2,2
				];
				attribute<bool> test      (gridcel_1km) :=  eq_or_both_null(DistrictGrid, att_ok);

				parameter<bool> test_attr := #District = 0 ? all(isNull(DistrictGrid)) : all(test);
			}

			container polygon_filtered
			{
				attribute<ipoint> att(District, polygon) := polygon_filtered(ipolygon(Source/District/border),100.0);
			}

			container union_polygon
			{
				parameter<ipoint> att(polygon) := union_polygon(ipolygon(Source/District/border_clean));
				unit<uint32> pointset := sequence2points(att)
				{
					attribute<ipoint> att_ok:
					[
					 {401047, 115164},{400978, 114523},{400965, 114314},{400926, 113796},{400919, 113685},{400888, 113291},{400886, 113192}
					,{400883, 113120},{400916, 112666},{400893, 112424},{400817, 112176},{400864, 112187},{400943, 112215},{401063, 111873}
					,{401234, 111711},{401477, 111716},{401653, 111646},{402133, 111453},{402382, 111433},{402859, 111567},{403372, 111821}
					,{403701, 111952},{403834, 112009},{403934, 112040},{404010, 112054},{404157, 112066},{404271, 112054},{404555, 111996}
					,{404649, 111969},{404664, 111986},{404631, 112040},{404620, 112098},{405013, 112720},{405495, 113478},{405454, 113512}
					,{405415, 113601},{405353, 113625},{405282, 113562},{405282, 113561},{405183, 113537},{404996, 113582},{404923, 113297}
					,{404776, 113283},{404669, 113160},{404669, 113068},{404576, 113022},{404353, 113116},{404300, 112976},{404256, 112989}
					,{404154, 112857},{404063, 112893},{403939, 112611},{403770, 112450},{403792, 112379},{403544, 112312},{403552, 112612}
					,{403434, 112809},{403298, 113032},{403171, 113401},{403025, 113810},{402870, 114237},{402757, 114546},{402404, 114445}
					,{402317, 114418},{402194, 114374},{402223, 114390},{402197, 114497},{402086, 114462},{402049, 114612},{401988, 114592}
					,{401980, 114626},{401803, 114574},{401790, 114655},{401765, 114673},{401757, 114803},{401545, 114739},{401567, 114983}
					,{401475, 114991},{401462, 115075},{401238, 115099},{401047, 115164}
					];
					attribute<bool> test := point == att_ok;
				}
				parameter<bool> test_attr := = #District = 0 ? '#pointset == 0' : 'all(pointset/test)';
			}
			container partitioned_union_polygon
			{
				attribute<ipoint> att(polygon, region) := partitioned_union_polygon(ipolygon(Source/District/border_clean), Source/district/region_rel);
				unit<uint32> pointset := sequence2points(att)
				{
					attribute<ipoint> att_ok:
					[
						{403025, 113810},{402552, 113711},{402558, 113646},{402428, 113636},{402448, 113472},{402480, 113244},{402503, 113057},{402570, 112883},
						{402576, 112884},{402647, 112740},{402697, 112555},{402698, 112554},{402973, 112471},{402977, 112473},{403544, 112312},{403552, 112612},
						{403434, 112809},{403298, 113032},{403171, 113401},{403025, 113810},{401047, 115164},{400978, 114523},{400965, 114314},{400926, 113796},
						{400919, 113685},{400888, 113291},{400886, 113192},{400883, 113120},{400916, 112666},{400893, 112424},{400817, 112176},{400864, 112187},
						{401157, 112293},{401322, 112404},{401494, 112519},{401597, 112589},{401558, 112840},{401553, 112888},{402697, 112555},{402647, 112740},
						{402576, 112884},{402570, 112883},{402503, 113057},{402480, 113244},{402448, 113472},{402428, 113636},{402414, 113716},{402281, 113770},
						{402174, 113703},{402076, 113691},{402076, 113690},{401742, 113655},{401723, 113659},{401602, 113684},{401642, 113915},{401567, 114437},
						{401475, 114991},{401462, 115075},{401238, 115099},{401047, 115164},{401475, 114991},{401531, 114646},{401567, 114437},{401642, 113915},
						{401602, 113684},{401723, 113659},{401742, 113655},{402077, 113690},{402174, 113703},{402281, 113770},{402414, 113716},{402428, 113636},
						{402558, 113646},{402552, 113711},{403025, 113810},{402870, 114237},{402757, 114546},{402404, 114445},{402317, 114418},{402194, 114374},
						{402223, 114390},{402197, 114497},{402086, 114462},{402049, 114612},{401988, 114592},{401980, 114626},{401803, 114574},{401790, 114655},
						{401765, 114673},{401757, 114803},{401545, 114739},{401567, 114983},{401475, 114991},{405353, 113625},{405282, 113562},{405282, 113561},
						{405183, 113537},{404996, 113582},{404923, 113297},{404776, 113283},{404669, 113160},{404669, 113068},{404576, 113022},{404353, 113116},
						{404300, 112976},{404256, 112989},{404154, 112857},{404063, 112893},{403939, 112611},{403770, 112450},{403792, 112379},{403544, 112312},
						{402977, 112473},{402973, 112471},{402698, 112554},{402697, 112555},{401553, 112888},{401558, 112840},{401597, 112589},{401494, 112519},
						{401322, 112404},{401157, 112293},{400943, 112215},{401063, 111873},{401234, 111711},{401477, 111716},{401653, 111646},{402133, 111453},
						{402382, 111433},{402859, 111567},{403372, 111821},{403701, 111952},{403834, 112009},{403934, 112040},{404010, 112054},{404157, 112066},
						{404271, 112054},{404555, 111996},{404649, 111969},{404664, 111986},{404631, 112040},{404620, 112098},{405013, 112720},{405495, 113478},
						{405454, 113512},{405415, 113601},{405353, 113625}
					];
					attribute<bool> test := point == att_ok;
				}
				parameter<bool> test_attr := = #District = 0 ? '#pointset == 0' : 'all(pointset/test)';
			}
			container overlay_polygon
			{
				attribute<ipoint> building_ipoint (polygon, building) := ipolygon(source/building/boundary);
				attribute<ipoint> district_ipoint (polygon, district) := ipolygon(source/district/border_clean);
				
				unit<uint32> intersect := overlay_polygon(building_ipoint, district_ipoint)
				,	DialogType = "Map"
				,	DialogData = "geo_rd"
				{
					attribute<point_rd> geo_rd (polygon) := geometry[point_rd]
					{
						parameter<color> brushcolor: [rgb(255,255,0)], DialogType = "BrushColor";
						parameter<color> pencolor:   [rgb(0,0,0)], DialogType = "pencolor";
					}
					attribute<string> sorted := sort_str(string(first_rel) + '_' + string(second_rel)); //  deze sortering is ivm manis issue 587
					
					attribute<string> testAtt:  ['1_0','2_0','3_0','3_5','4_3','4_6','5_0','5_3','5_4','5_5'];
					
					attribute<bool>   test_attr := sorted == testAtt; 
					parameter<bool>   test      := =(#building == 0 && #district == 0) ? '#intersect == 0' :  'all(test_attr)';
				}
			}
			container split
			{
				attribute<ipoint> district_ipoint (polygon, district) := ipolygon(source/district/border_clean);
				container multipolygon
				{
					attribute<ipoint> geometry (Region, polygon) := partitioned_union_polygon(ipolygon(Source/District/border_clean), Source/district/multipolygon_rel);
					parameter<ipoint> geometry_void (polygon) := geometry[0];
				}
				unit<uint32> single_polygons := split_polygon(multipolygon/geometry)
				{
					attribute<uint32> ok: [0,0,0,1,1,2,3];

					attribute<bool>   test_attr := nr_OrgEntity == ok;
					parameter<bool>   test      := = #district == 0 ? '#single_polygons == 0' : 'all(test_attr)';
				}
			}
			container inflate
			{
				attribute<ipoint> building_ipoint           (polygon, building) := ipolygon(source/building/boundary)
				{
					parameter<color> brushcolor: [rgb(200,0,0)], DialogType = "BrushColor";
					parameter<color> pencolor:   [rgb(0,0,0)], DialogType = "pencolor";
				}
				attribute<ipoint> building_inflated_100     (polygon, building) := polygon_inflated(building_ipoint, float64(100))
				{
					parameter<color> brushcolor: [rgb(255,255,0)], DialogType = "BrushColor";
					parameter<color> pencolor:   [rgb(0,0,0)], DialogType = "pencolor";
				}
				attribute<ipoint> building_inflated_i_4D100  (polygon, building) := polygon_inflated_i4D(building_ipoint, float64(75), float64(25))
				{
					parameter<color> brushcolor: [rgb(255,255,0)], DialogType = "BrushColor";
					parameter<color> pencolor:   [rgb(0,0,0)], DialogType = "pencolor";
				}

				attribute<ipoint> building_inflated_i_8D100  (polygon, building) := polygon_inflated_i8D(building_ipoint, float64(75), float64(25))
				{
					parameter<color> brushcolor: [rgb(255,255,0)], DialogType = "BrushColor";
					parameter<color> pencolor:   [rgb(0,0,0)], DialogType = "pencolor";
				}
				attribute<ipoint> building_inflated_i_16D100 (polygon, building) := polygon_inflated_i16D(building_ipoint, float64(75), float64(25))
				{
					parameter<color> brushcolor: [rgb(255,255,0)], DialogType = "BrushColor";
					parameter<color> pencolor:   [rgb(0,0,0)], DialogType = "pencolor";
				}

				attribute<ipoint> building_polygon_i4D75  (polygon, building) :=  polygon_i4D(building_ipoint, float64(75))
				{
					parameter<color> brushcolor: [rgb(255,255,0)], DialogType = "BrushColor";
					parameter<color> pencolor:   [rgb(0,0,0)], DialogType = "pencolor";
				}
				attribute<ipoint> building_polygon_i8D75  (polygon, building) :=  polygon_i8D(building_ipoint, float64(75))
				{
					parameter<color> brushcolor: [rgb(255,255,0)], DialogType = "BrushColor";
					parameter<color> pencolor:   [rgb(0,0,0)], DialogType = "pencolor";
				}
				attribute<ipoint> building_polygon_i16D75  (polygon, building) :=  polygon_i16D(building_ipoint, float64(75))
				{
					parameter<color> brushcolor: [rgb(255,255,0)], DialogType = "BrushColor";
					parameter<color> pencolor:   [rgb(0,0,0)], DialogType = "pencolor";
				}
				attribute<ipoint> building_polygon_i4HV75  (polygon, building) :=  polygon_i4HV(building_ipoint, float64(75))
				{
					parameter<color> brushcolor: [rgb(255,255,0)], DialogType = "BrushColor";
					parameter<color> pencolor:   [rgb(0,0,0)], DialogType = "pencolor";
				}

				parameter<bool> test_attr := 
					    pointset/test_attr       && pointset_i_4D100/test_attr && pointset_i_8D100/test_attr && pointset_i_16D100/test_attr
					&&  pointset_i4D75/test_attr && pointset_i8D75/test_attr   && pointset_i16D75/test_attr  && pointset_i4HV75/test_attr
				;

				unit<uint32> pointset := sequence2points(building_inflated_100)
				{
					attribute<ipoint> att_ok:
					[
						{403392, 113678},{403315, 113678},{403172, 113672},{403118, 113618},{403118, 113541},{403143, 113312},{403197, 113258},{403352, 113171},
						{403429, 113171},{403483, 113225},{403483, 113302},{403446, 113624},{403392, 113678},{403017, 113335},{402940, 113335},{402860, 113335},
						{402783, 113335},{402729, 113281},{402729, 113204},{402749, 112877},{402803, 112823},{402880, 112823},{403024, 112856},{403078, 112910},
						{403078, 112987},{403071, 113281},{403017, 113335},{403271, 113141},{403194, 113141},{403140, 113087},{403133, 112944},{403133, 112867},
						{403187, 112813},{403421, 112796},{403498, 112796},{403552, 112850},{403579, 112993},{403579, 113070},{403525, 113124},{403271, 113141},
						{403173, 113954},{403096, 113954},{402906, 113951},{402852, 113897},{402852, 113820},{402866, 113657},{402920, 113603},{402997, 113603},
						{403190, 113634},{403244, 113688},{403244, 113765},{403227, 113900},{403173, 113954},{402230, 112859},{402153, 112859},{402099, 112805},
						{402099, 112728},{402099, 112619},{402099, 112542},{402153, 112488},{402230, 112488},{402400, 112508},{402454, 112562},{402498, 112725},
						{402498, 112802},{402444, 112856},{402230, 112859},{402515, 113975},{402438, 113975},{402174, 113948},{402120, 113894},{402120, 113817},
						{402137, 113511},{402191, 113457},{402268, 113457},{402546, 113474},{402600, 113528},{402600, 113605},{402569, 113921},{402515, 113975}
					];
					attribute<bool> test      := point == att_ok;
					parameter<bool> test_attr := = #building == 0 ? '#pointset == 0' : 'all(test)';
				}
				unit<uint32> pointset_i_4D100 := sequence2points(building_inflated_i_4D100)
				{
					attribute<ipoint> att_ok:
					[
						{403382, 113680},{403325, 113680},{403182, 113674},{403157, 113649},{403141, 113633},{403116, 113608},{403116, 113551},{403141, 113322},
						{403166, 113297},{403182, 113281},{403207, 113256},{403362, 113169},{403419, 113169},{403444, 113194},{403460, 113210},{403485, 113235},
						{403485, 113292},{403448, 113614},{403423, 113639},{403407, 113655},{403382, 113680},{403007, 113337},{402950, 113337},{402850, 113337},
						{402793, 113337},{402768, 113312},{402752, 113296},{402727, 113271},{402727, 113214},{402747, 112887},{402772, 112862},{402788, 112846},
						{402813, 112821},{402870, 112821},{403014, 112854},{403039, 112879},{403055, 112895},{403080, 112920},{403080, 112977},{403073, 113271},
						{403048, 113296},{403032, 113312},{403007, 113337},{403261, 113143},{403204, 113143},{403179, 113118},{403163, 113102},{403138, 113077},
						{403131, 112934},{403131, 112877},{403156, 112852},{403172, 112836},{403197, 112811},{403431, 112794},{403488, 112794},{403513, 112819},
						{403529, 112835},{403554, 112860},{403581, 113003},{403581, 113060},{403556, 113085},{403540, 113101},{403515, 113126},{403261, 113143},
						{403163, 113956},{403106, 113956},{403105, 113955},{402973, 113953},{402916, 113953},{402891, 113928},{402875, 113912},{402850, 113887},
						{402850, 113830},{402864, 113667},{402889, 113642},{402905, 113626},{402930, 113601},{402987, 113601},{403180, 113632},{403205, 113657},
						{403221, 113673},{403246, 113698},{403246, 113755},{403229, 113890},{403204, 113915},{403188, 113931},{403163, 113956},{402220, 112861},
						{402163, 112861},{402138, 112836},{402122, 112820},{402097, 112795},{402097, 112738},{402097, 112609},{402097, 112552},{402122, 112527},
						{402138, 112511},{402163, 112486},{402220, 112486},{402390, 112506},{402415, 112531},{402431, 112547},{402456, 112572},{402500, 112735},
						{402500, 112792},{402475, 112817},{402459, 112833},{402434, 112858},{402377, 112858},{402221, 112859},{402220, 112860},{402220, 112861},
						{402505, 113977},{402448, 113977},{402184, 113950},{402159, 113925},{402143, 113909},{402118, 113884},{402118, 113827},{402135, 113521},
						{402160, 113496},{402176, 113480},{402201, 113455},{402258, 113455},{402536, 113472},{402561, 113497},{402577, 113513},{402602, 113538},
						{402602, 113595},{402571, 113911},{402546, 113936},{402530, 113952},{402505, 113977}
					];
					attribute<bool> test      := point == att_ok;
					parameter<bool> test_attr := = #building == 0 ? '#pointset_i_4D100 == 0' : 'all(test)';
				}
				unit<uint32> pointset_i_8D100 := sequence2points(building_inflated_i_8D100)
				{
					attribute<ipoint> att_ok:
					[
						{403382, 113680},{403325, 113680},{403182, 113674},{403165, 113666},{403124, 113625},{403116, 113608},{403116, 113551},{403141, 113322},
						{403149, 113305},{403190, 113264},{403345, 113177},{403362, 113169},{403419, 113169},{403436, 113177},{403477, 113218},{403485, 113235},
						{403485, 113292},{403448, 113614},{403440, 113631},{403399, 113672},{403382, 113680},{403007, 113337},{402950, 113337},{402850, 113337},
						{402793, 113337},{402776, 113329},{402735, 113288},{402727, 113271},{402727, 113214},{402747, 112887},{402755, 112870},{402796, 112829},
						{402813, 112821},{402870, 112821},{403014, 112854},{403031, 112862},{403072, 112903},{403080, 112920},{403080, 112977},{403073, 113271},
						{403065, 113288},{403024, 113329},{403007, 113337},{403261, 113143},{403204, 113143},{403187, 113135},{403146, 113094},{403138, 113077},
						{403131, 112934},{403131, 112877},{403139, 112860},{403180, 112819},{403197, 112811},{403431, 112794},{403488, 112794},{403505, 112802},
						{403546, 112843},{403554, 112860},{403581, 113003},{403581, 113060},{403573, 113077},{403532, 113118},{403515, 113126},{403261, 113143},
						{403163, 113956},{403106, 113956},{403105, 113955},{403103, 113954},{402973, 113953},{402916, 113953},{402899, 113945},{402858, 113904},
						{402850, 113887},{402850, 113830},{402864, 113667},{402872, 113650},{402913, 113609},{402930, 113601},{402987, 113601},{403180, 113632},
						{403197, 113640},{403238, 113681},{403246, 113698},{403246, 113755},{403229, 113890},{403221, 113907},{403180, 113948},{403163, 113956},
						{402220, 112861},{402163, 112861},{402146, 112853},{402105, 112812},{402097, 112795},{402097, 112738},{402097, 112609},{402097, 112552},
						{402105, 112535},{402146, 112494},{402163, 112486},{402220, 112486},{402390, 112506},{402407, 112514},{402448, 112555},{402456, 112572},
						{402500, 112735},{402500, 112792},{402492, 112809},{402451, 112850},{402434, 112858},{402377, 112858},{402222, 112859},{402220, 112860},
						{402220, 112861},{402505, 113977},{402448, 113977},{402184, 113950},{402167, 113942},{402126, 113901},{402118, 113884},{402118, 113827},
						{402135, 113521},{402143, 113504},{402184, 113463},{402201, 113455},{402258, 113455},{402536, 113472},{402553, 113480},{402594, 113521},
						{402602, 113538},{402602, 113595},{402571, 113911},{402563, 113928},{402522, 113969},{402505, 113977}
					];
					attribute<bool> test      := point == att_ok;
					parameter<bool> test_attr := = #building == 0 ? '#pointset_i_8D100 == 0' : 'all(test)';
				}
				unit<uint32> pointset_i_16D100 := sequence2points(building_inflated_i_16D100)
				{
					attribute<ipoint> att_ok:
					[
						{403382, 113680},{403325, 113680},{403182, 113674},{403173, 113672},{403165, 113666},{403124, 113625},{403118, 113617},{403116, 113608},
						{403116, 113551},{403141, 113322},{403143, 113313},{403149, 113305},{403190, 113264},{403194, 113261},{403198, 113258},{403353, 113171},
						{403362, 113169},{403419, 113169},{403428, 113171},{403436, 113177},{403477, 113218},{403483, 113226},{403485, 113235},{403485, 113292},
						{403483, 113301},{403448, 113614},{403446, 113623},{403440, 113631},{403399, 113672},{403397, 113672},{403391, 113678},{403382, 113680},
						{403007, 113337},{402950, 113337},{402850, 113337},{402793, 113337},{402784, 113335},{402776, 113329},{402735, 113288},{402729, 113280},
						{402727, 113271},{402727, 113214},{402747, 112887},{402749, 112878},{402755, 112870},{402796, 112829},{402804, 112823},{402813, 112821},
						{402870, 112821},{402879, 112823},{403014, 112854},{403023, 112856},{403031, 112862},{403072, 112903},{403078, 112911},{403080, 112920},
						{403080, 112977},{403073, 113271},{403071, 113280},{403065, 113288},{403024, 113329},{403022, 113329},{403016, 113335},{403007, 113337},
						{403261, 113143},{403204, 113143},{403195, 113141},{403187, 113135},{403146, 113094},{403140, 113086},{403138, 113077},{403131, 112934},
						{403131, 112877},{403133, 112868},{403139, 112860},{403180, 112819},{403188, 112813},{403197, 112811},{403431, 112794},{403488, 112794},
						{403497, 112796},{403505, 112802},{403546, 112843},{403552, 112851},{403553, 112859},{403554, 112860},{403579, 112994},{403581, 113003},
						{403581, 113060},{403579, 113069},{403573, 113075},{403573, 113077},{403532, 113118},{403524, 113124},{403515, 113126},{403261, 113143},
						{403163, 113956},{403106, 113956},{403105, 113955},{403101, 113954},{403100, 113954},{403097, 113954},{402973, 113953},{402916, 113953},
						{402907, 113951},{402899, 113945},{402858, 113904},{402852, 113896},{402850, 113887},{402850, 113830},{402864, 113667},{402866, 113658},
						{402872, 113650},{402913, 113609},{402921, 113603},{402930, 113601},{402987, 113601},{403180, 113632},{403189, 113634},{403197, 113640},
						{403238, 113681},{403244, 113689},{403246, 113698},{403246, 113755},{403244, 113764},{403229, 113890},{403228, 113890},{403227, 113899},
						{403221, 113907},{403180, 113948},{403178, 113948},{403172, 113954},{403163, 113956},{402220, 112861},{402163, 112861},{402154, 112859},
						{402146, 112853},{402105, 112812},{402099, 112804},{402097, 112795},{402097, 112738},{402097, 112609},{402097, 112552},{402099, 112543},
						{402105, 112535},{402146, 112494},{402154, 112488},{402163, 112486},{402220, 112486},{402390, 112506},{402399, 112508},{402407, 112514},
						{402448, 112555},{402454, 112563},{402456, 112572},{402497, 112725},{402498, 112726},{402498, 112727},{402500, 112735},{402500, 112792},
						{402498, 112801},{402492, 112807},{402492, 112809},{402451, 112850},{402449, 112850},{402443, 112856},{402434, 112858},{402377, 112858},
						{402229, 112859},{402224, 112859},{402220, 112860},{402220, 112861},{402505, 113977},{402448, 113977},{402184, 113950},{402175, 113948},
						{402167, 113942},{402126, 113901},{402120, 113893},{402118, 113884},{402118, 113827},{402135, 113521},{402137, 113512},{402143, 113504},
						{402184, 113463},{402192, 113457},{402201, 113455},{402258, 113455},{402536, 113472},{402545, 113474},{402553, 113480},{402594, 113521},
						{402600, 113529},{402602, 113538},{402602, 113595},{402571, 113911},{402569, 113920},{402563, 113928},{402522, 113969},{402520, 113969},
						{402514, 113975},{402505, 113977}
					];
					attribute<bool> test      := point == att_ok;
					parameter<bool> test_attr := = #building == 0 ? '#pointset_i_16D100 == 0' : 'all(test)';
				}
				unit<uint32> pointset_i4D75 := sequence2points(building_polygon_i4D75)
				{
					attribute<ipoint> att_ok:
					[
						{403354, 113661},{403211, 113655},{403136, 113580},{403161, 113351},{403236, 113276},{403391, 113189},{403466, 113264},{403429, 113586},{403354, 113661},{402979, 113318},
						{402822, 113318},{402747, 113243},{402767, 112916},{402842, 112841},{402986, 112874},{403061, 112949},{403054, 113243},{402979, 113318},{403233, 113124},{403158, 113049},
						{403151, 112906},{403226, 112831},{403460, 112814},{403535, 112889},{403562, 113032},{403487, 113107},{403233, 113124},{403135, 113937},{402945, 113934},{402870, 113859},
						{402884, 113696},{402959, 113621},{403152, 113652},{403227, 113727},{403210, 113862},{403135, 113937},{402192, 112842},{402117, 112767},{402117, 112581},{402192, 112506},
						{402362, 112526},{402437, 112601},{402481, 112764},{402406, 112839},{402192, 112842},{402477, 113958},{402213, 113931},{402138, 113856},{402155, 113550},{402230, 113475},
						{402508, 113492},{402583, 113567},{402552, 113883},{402477, 113958}
					];
					attribute<bool> test      := point == att_ok;
					parameter<bool> test_attr := = #building == 0 ? '#pointset_i4D75 == 0' : 'all(test)';
				}
				unit<uint32> pointset_i8D75 := sequence2points(building_polygon_i8D75)
				{
					attribute<ipoint> att_ok:
					[
						{403354, 113661},{403211, 113655},{403158, 113633},{403136, 113580},{403161, 113351},{403183, 113298},{403338, 113211},{403391, 113189},{403444, 113211},{403466, 113264},
						{403429, 113586},{403407, 113639},{403354, 113661},{402979, 113318},{402822, 113318},{402769, 113296},{402747, 113243},{402767, 112916},{402789, 112863},{402842, 112841},
						{402986, 112874},{403039, 112896},{403061, 112949},{403054, 113243},{403032, 113296},{402979, 113318},{403233, 113124},{403180, 113102},{403158, 113049},{403151, 112906},
						{403173, 112853},{403226, 112831},{403460, 112814},{403513, 112836},{403535, 112889},{403562, 113032},{403540, 113085},{403487, 113107},{403233, 113124},{403135, 113937},
						{402945, 113934},{402892, 113912},{402870, 113859},{402884, 113696},{402906, 113643},{402959, 113621},{403152, 113652},{403205, 113674},{403227, 113727},{403210, 113862},
						{403188, 113915},{403135, 113937},{402192, 112842},{402139, 112820},{402117, 112767},{402117, 112581},{402139, 112528},{402192, 112506},{402362, 112526},{402415, 112548},
						{402437, 112601},{402481, 112764},{402459, 112817},{402406, 112839},{402192, 112842},{402477, 113958},{402213, 113931},{402160, 113909},{402138, 113856},{402155, 113550},
						{402177, 113497},{402230, 113475},{402508, 113492},{402561, 113514},{402583, 113567},{402552, 113883},{402530, 113936},{402477, 113958}
					];
					attribute<bool> test      := point == att_ok;
					parameter<bool> test_attr := = #building == 0 ? '#pointset_i8D75 == 0' : 'all(test)';
				}
				unit<uint32> pointset_i16D75 := sequence2points(building_polygon_i16D75)
				{
					attribute<ipoint> att_ok:
					[
						{403354, 113661},{403211, 113655},{403183, 113649},{403158, 113633},{403142, 113608},{403136, 113580},{403161, 113351},{403167, 113323},{403183, 113298},{403208, 113282},{403363, 113195},
						{403391, 113189},{403419, 113195},{403444, 113211},{403460, 113236},{403466, 113264},{403429, 113586},{403423, 113614},{403407, 113639},{403382, 113655},{403354, 113661},{402979, 113318},
						{402822, 113318},{402794, 113312},{402769, 113296},{402753, 113271},{402747, 113243},{402767, 112916},{402773, 112888},{402789, 112863},{402814, 112847},{402842, 112841},{402870, 112847},
						{402871, 112847},{403014, 112880},{403039, 112896},{403055, 112921},{403061, 112949},{403054, 113243},{403048, 113271},{403032, 113296},{403007, 113312},{402979, 113318},{403233, 113124},
						{403205, 113118},{403180, 113102},{403164, 113077},{403158, 113049},{403151, 112906},{403157, 112878},{403173, 112853},{403198, 112837},{403226, 112831},{403460, 112814},{403488, 112820},
						{403513, 112836},{403529, 112861},{403535, 112889},{403556, 113004},{403562, 113032},{403556, 113060},{403540, 113085},{403515, 113101},{403487, 113107},{403233, 113124},{403135, 113937},
						{402945, 113934},{402917, 113928},{402892, 113912},{402876, 113887},{402870, 113859},{402884, 113696},{402890, 113668},{402906, 113643},{402931, 113627},{402959, 113621},{403152, 113652},
						{403180, 113658},{403205, 113674},{403221, 113699},{403227, 113727},{403210, 113862},{403204, 113890},{403188, 113915},{403163, 113931},{403135, 113937},{402192, 112842},{402164, 112836},
						{402139, 112820},{402123, 112795},{402117, 112767},{402117, 112581},{402123, 112553},{402139, 112528},{402164, 112512},{402192, 112506},{402362, 112526},{402390, 112532},{402415, 112548},
						{402431, 112573},{402475, 112736},{402481, 112764},{402475, 112792},{402459, 112817},{402434, 112833},{402406, 112839},{402192, 112842},{402477, 113958},{402213, 113931},{402185, 113925},
						{402160, 113909},{402144, 113884},{402138, 113856},{402155, 113550},{402161, 113522},{402177, 113497},{402202, 113481},{402230, 113475},{402508, 113492},{402536, 113498},{402561, 113514},
						{402577, 113539},{402583, 113567},{402552, 113883},{402546, 113911},{402530, 113936},{402505, 113952},{402477, 113958}
					];
					attribute<bool> test      := point == att_ok;
					parameter<bool> test_attr := = #building == 0 ? '#pointset_i16D75 == 0' : 'all(test)';
				}
				unit<uint32> pointset_i4HV75 := sequence2points(building_polygon_i4HV75)
				{
					attribute<ipoint> att_ok:
					[
						{403429, 113661},{403279, 113661},{403136, 113655},{403136, 113505},{403161, 113276},{403316, 113189},{403466, 113189},{403466, 113339},{403429, 113661},{403054, 113318},{402904, 113318},
						{402897, 113318},{402747, 113318},{402747, 113168},{402767, 112841},{402917, 112841},{403061, 112874},{403061, 113024},{403054, 113318},{403308, 113124},{403158, 113124},{403151, 112981},
						{403151, 112831},{403385, 112814},{403535, 112814},{403562, 112957},{403562, 113107},{403308, 113124},{403210, 113937},{403060, 113937},{402870, 113934},{402870, 113784},{402884, 113621},
						{403034, 113621},{403227, 113652},{403227, 113802},{403210, 113937},{402267, 112842},{402117, 112842},{402117, 112692},{402117, 112656},{402117, 112506},{402267, 112506},{402437, 112526},
						{402481, 112689},{402481, 112839},{402267, 112842},{402552, 113958},{402402, 113958},{402138, 113931},{402138, 113781},{402155, 113475},{402305, 113475},{402583, 113492},{402583, 113642},
						{402552, 113958}
					];
					attribute<bool> test      := point == att_ok;
					parameter<bool> test_attr := = #building == 0 ? '#pointset_i4HV75 == 0' : 'all(test)';
				}
			}
			container deflate
			{
				attribute<ipoint> building_ipoint           (polygon, building) := ipolygon(source/building/boundary)
				{
					parameter<color> brushcolor: [rgb(200,0,0)], DialogType = "BrushColor";
					parameter<color> pencolor:   [rgb(0,0,0)], DialogType = "pencolor";
				}
				attribute<ipoint> building_deflated_50     (polygon, building) := polygon_deflated(building_ipoint, float64(50))
				{
					parameter<color> brushcolor: [rgb(255,255,0)], DialogType = "BrushColor";
					parameter<color> pencolor:   [rgb(0,0,0)], DialogType = "pencolor";
				}
				attribute<ipoint> building_deflated_d_4D50  (polygon, building) := polygon_deflated_i4D(building_ipoint, float64(35), float64(15))
				{
					parameter<color> brushcolor: [rgb(255,255,0)], DialogType = "BrushColor";
					parameter<color> pencolor:   [rgb(0,0,0)], DialogType = "pencolor";
				}
				attribute<ipoint> building_deflated_d_8D50  (polygon, building) := polygon_deflated_i8D(building_ipoint, float64(35), float64(15))
				{
					parameter<color> brushcolor: [rgb(255,255,0)], DialogType = "BrushColor";
					parameter<color> pencolor:   [rgb(0,0,0)], DialogType = "pencolor";
				}
				attribute<ipoint> building_deflated_d_16D50 (polygon, building) := polygon_deflated_i16D(building_ipoint, float64(35), float64(15))
				{
					parameter<color> brushcolor: [rgb(255,255,0)], DialogType = "BrushColor";
					parameter<color> pencolor:   [rgb(0,0,0)], DialogType = "pencolor";
				}

				attribute<ipoint> building_polygon_d4D75  (polygon, building) :=  polygon_d4D(building_ipoint, float64(75))
				{
					parameter<color> brushcolor: [rgb(255,255,0)], DialogType = "BrushColor";
					parameter<color> pencolor:   [rgb(0,0,0)], DialogType = "pencolor";
				}
				attribute<ipoint> building_polygon_d8D75  (polygon, building) :=  polygon_d8D(building_ipoint, float64(75))
				{
					parameter<color> brushcolor: [rgb(255,255,0)], DialogType = "BrushColor";
					parameter<color> pencolor:   [rgb(0,0,0)], DialogType = "pencolor";
				}
				attribute<ipoint> building_polygon_d16D75  (polygon, building) :=  polygon_d16D(building_ipoint, float64(75))
				{
					parameter<color> brushcolor: [rgb(255,255,0)], DialogType = "BrushColor";
					parameter<color> pencolor:   [rgb(0,0,0)], DialogType = "pencolor";
				}
				attribute<ipoint> building_polygon_d4HV75  (polygon, building) :=  polygon_d4HV(building_ipoint, float64(75))
				{
					parameter<color> brushcolor: [rgb(255,255,0)], DialogType = "BrushColor";
					parameter<color> pencolor:   [rgb(0,0,0)], DialogType = "pencolor";
				}

				parameter<bool> test_attr := 
					   pointset/test_attr       && pointset_d_4D50/test_attr && pointset_d_8D50/test_attr && pointset_d_16D50/test_attr
					&& pointset_d4D75/test_attr && pointset_d8D75/test_attr  && pointset_d16D75/test_attr && pointset_d4HV75/test_attr;

				unit<uint32> pointset := sequence2points(building_deflated_50)
				{
					attribute<ipoint> att_ok:
					[
						{403310, 113536},{403264, 113534},{403280, 113382},{403331, 113354},{403310, 113536},{402932, 113196},{402872, 113196},{402885, 112976},
						{402937, 112988},{402932, 113196},{403277, 112997},{403275, 112949},{403418, 112939},{403428, 112987},{403277, 112997},{403091, 113814},
						{402996, 113812},{403001, 113752},{403097, 113767},{403091, 113814},{402238, 112719},{402238, 112634},{402321, 112644},{402341, 112717},
						{402238, 112719},{402433, 113829},{402262, 113812},{402274, 113599},{402454, 113610},{402433, 113829}
					];
					attribute<bool> test      := point == att_ok;
					parameter<bool> test_attr := = #building == 0 ? '#pointset == 0' : 'all(test)';
				}
				unit<uint32> pointset_d_4D50 := sequence2points(building_deflated_d_4D50)
				{
					attribute<ipoint> att_ok:
					[
						{403323, 113566},{403247, 113563},{403232, 113548},{403252, 113372},{403267, 113357},{403349, 113311},{403364, 113326},{403338, 113551},
						{403323, 113566},{402946, 113225},{402856, 113225},{402841, 113210},{402857, 112958},{402872, 112943},{402952, 112961},{402967, 112976},
						{402961, 113210},{402946, 113225},{403263, 113027},{403248, 113012},{403245, 112936},{403260, 112921},{403431, 112909},{403446, 112924},
						{403460, 113000},{403445, 113015},{403263, 113027},{403104, 113843},{402980, 113841},{402965, 113826},{402973, 113735},{402988, 113720},
						{403113, 113740},{403128, 113755},{403119, 113828},{403104, 113843},{402224, 112748},{402209, 112733},{402209, 112618},{402224, 112603},
						{402333, 112616},{402348, 112631},{402375, 112731},{402360, 112746},{402224, 112748},{402446, 113860},{402247, 113840},{402232, 113825},
						{402245, 113584},{402260, 113569},{402470, 113582},{402485, 113597},{402461, 113845},{402446, 113860}
					];
					attribute<bool> test      := point == att_ok;
					parameter<bool> test_attr := = #building == 0 ? '#pointset_d_4D50 == 0' : 'all(test)';
				}
				unit<uint32> pointset_d_8D50 := sequence2points(building_deflated_d_8D50)
				{
					attribute<ipoint> att_ok:
					[
						{403323, 113566},{403247, 113563},{403237, 113558},{403232, 113548},{403252, 113372},{403257, 113362},{403338, 113316},{403339, 113316},
						{403349, 113311},{403359, 113316},{403364, 113326},{403338, 113551},{403333, 113561},{403323, 113566},{402946, 113225},{402856, 113225},
						{402846, 113220},{402841, 113210},{402857, 112958},{402862, 112948},{402872, 112943},{402952, 112961},{402962, 112966},{402967, 112976},
						{402961, 113210},{402956, 113220},{402946, 113225},{403263, 113027},{403253, 113022},{403248, 113012},{403245, 112936},{403250, 112926},
						{403260, 112921},{403431, 112909},{403441, 112914},{403446, 112924},{403460, 113000},{403455, 113010},{403445, 113015},{403263, 113027},
						{403104, 113843},{402980, 113841},{402970, 113836},{402965, 113826},{402973, 113735},{402978, 113725},{402988, 113720},{403113, 113740},
						{403123, 113745},{403128, 113755},{403119, 113828},{403114, 113838},{403104, 113843},{402224, 112748},{402214, 112743},{402209, 112733},
						{402209, 112618},{402214, 112608},{402224, 112603},{402333, 112616},{402343, 112621},{402348, 112631},{402375, 112731},{402370, 112741},
						{402360, 112746},{402224, 112748},{402446, 113860},{402247, 113840},{402237, 113835},{402232, 113825},{402245, 113584},{402250, 113574},
						{402260, 113569},{402470, 113582},{402480, 113587},{402485, 113597},{402461, 113845},{402456, 113855},{402446, 113860}
					];
					attribute<bool> test      := point == att_ok;
					parameter<bool> test_attr := = #building == 0 ? '#pointset_d_8D50 == 0' : 'all(test)';
				}
				unit<uint32> pointset_d_16D50 := sequence2points(building_deflated_d_16D50)
				{
					attribute<ipoint> att_ok:
					[
						{403323, 113566},{403247, 113563},{403242, 113561},{403237, 113558},{403234, 113553},{403232, 113548},{403252, 113372},{403254, 113367},
						{403257, 113362},{403261, 113359},{403262, 113359},{403263, 113358},{403338, 113316},{403343, 113313},{403344, 113313},{403349, 113311},
						{403354, 113313},{403359, 113316},{403362, 113321},{403364, 113326},{403338, 113551},{403336, 113556},{403333, 113561},{403328, 113564},
						{403323, 113566},{402946, 113225},{402856, 113225},{402851, 113223},{402846, 113220},{402843, 113215},{402841, 113210},{402857, 112958},
						{402859, 112953},{402862, 112948},{402867, 112945},{402872, 112943},{402952, 112961},{402957, 112963},{402962, 112966},{402965, 112971},
						{402967, 112976},{402961, 113210},{402959, 113215},{402956, 113220},{402951, 113223},{402946, 113225},{403263, 113027},{403258, 113025},
						{403253, 113022},{403250, 113017},{403248, 113012},{403245, 112936},{403247, 112931},{403250, 112926},{403255, 112923},{403260, 112921},
						{403431, 112909},{403436, 112911},{403441, 112914},{403444, 112919},{403446, 112924},{403460, 113000},{403458, 113005},{403455, 113010},
						{403450, 113013},{403445, 113015},{403263, 113027},{403104, 113843},{402980, 113841},{402975, 113839},{402970, 113836},{402967, 113831},
						{402965, 113826},{402973, 113735},{402975, 113730},{402978, 113725},{402983, 113722},{402988, 113720},{403113, 113740},{403118, 113742},
						{403123, 113745},{403126, 113750},{403128, 113755},{403119, 113828},{403117, 113833},{403114, 113838},{403109, 113841},{403104, 113843},
						{402224, 112748},{402219, 112746},{402214, 112743},{402211, 112738},{402209, 112733},{402209, 112618},{402211, 112613},{402214, 112608},
						{402219, 112605},{402224, 112603},{402333, 112616},{402338, 112618},{402343, 112621},{402346, 112626},{402347, 112630},{402348, 112631},
						{402373, 112726},{402375, 112731},{402373, 112736},{402370, 112741},{402365, 112744},{402360, 112746},{402224, 112748},{402446, 113860},
						{402247, 113840},{402242, 113838},{402237, 113835},{402234, 113830},{402232, 113825},{402245, 113584},{402247, 113579},{402250, 113574},
						{402255, 113571},{402260, 113569},{402470, 113582},{402475, 113584},{402480, 113587},{402483, 113592},{402485, 113597},{402461, 113845},
						{402459, 113850},{402456, 113855},{402451, 113858},{402446, 113860}
					];
					attribute<bool> test      := point == att_ok;
					parameter<bool> test_attr := = #building == 0 ? '#pointset_d_16D50 == 0' : 'all(test)';
				}
				unit<uint32> pointset_d4D75 := sequence2points(building_polygon_d4D75)
				{
					attribute<ipoint> att_ok:
					[
						{402905, 113168},{402901, 113168},{402908, 113055},{402905, 113168},{403050, 113785},{403026, 113785},{403026, 113781},{403050, 113785},{402311, 112690},
						{402267, 112690},{402267, 112664},{402305, 112669},{402311, 112690},{402410, 113801},{402291, 113789},{402300, 113629},{402426, 113636},{402410, 113801}
					];
					attribute<bool> test      := point == att_ok;
					parameter<bool> test_attr := = #building == 0 ? '#pointset_d4D75 == 0' : 'all(test)';
				}
				unit<uint32> pointset_d8D75 := sequence2points(building_polygon_d8D75)
				{
					attribute<ipoint> att_ok:
					[
						{402905, 113168},{402901, 113168},{402908, 113055},{402905, 113168},{403050, 113785},{403026, 113785},{403026, 113781},{403050, 113785},{402311, 112690},
						{402267, 112690},{402267, 112664},{402305, 112669},{402311, 112690},{402410, 113801},{402291, 113789},{402300, 113629},{402426, 113636},{402410, 113801}
					];
					attribute<bool> test      := point == att_ok;
					parameter<bool> test_attr := = #building == 0 ? '#pointset_d8D75 == 0' : 'all(test)';
				}
				unit<uint32> pointset_d16D75 := sequence2points(building_polygon_d16D75)
				{
					attribute<ipoint> att_ok:
					[
						{402905, 113168},{402901, 113168},{402908, 113055},{402905, 113168},{403050, 113785},{403026, 113785},{403026, 113781},{403050, 113785},{402309, 112690},
						{402267, 112690},{402267, 112664},{402303, 112669},{402309, 112690},{402410, 113801},{402291, 113789},{402300, 113629},{402426, 113636},{402410, 113801}
					];
					attribute<bool> test      := point == att_ok;
					parameter<bool> test_attr := = #building == 0 ? '#pointset_d16D75 == 0' : 'all(test)';
				}
				unit<uint32> pointset_d4HV75 := sequence2points(building_polygon_d4HV75)
				{
					attribute<ipoint> att_ok:
					[
						{402290, 112689},{402267, 112689},{402267, 112673},{402287, 112676},{402290, 112689},
						{402403, 113792},{402296, 113781},{402304, 113634},{402418, 113641},{402403, 113792}
					];
					attribute<bool> test      := point == att_ok;
					parameter<bool> test_attr := = #building == 0 ? '#pointset_d4HV75 == 0' : 'all(test)';
				}
			}
			container connectivity
			{
				attribute<ipoint> iborder(District, poly) := ipolygon(Source/district/border);
				attribute<float32>  area  (District) := area(Source/district/border, float32);
				unit<uint32> polygon_connectvity := polygon_connectivity(iborder)
				{
					attribute<district> F1_ok:
					[
						0,0,0,
						1,1,1,
						2,2,2,
						3,3,3,
						4
					];
					attribute<district> F2_ok:
					[
						3,5,6,
						2,3,6,
						3,4,6,
						4,5,6,
						5
					];
					attribute<float64> area := area(dpolygon(iborder[F1] * iborder[F2]), Float64);
					attribute<bool> test      := F1 == F1_ok && F2 == F2_ok;
					parameter<bool> test_attr :== #District == 0 ? '#polygon_connectvity == 0' : ' all(test)';
				}
				
				
				unit<uint32> arc_connectvity     := polygon_connectivity(ipolygon(Source/road/line_cross));
			}
			container difference
			{
				parameter<ipoint> att (poly) := source/square/boundary_dif [0] - union_polygon/att;
				unit<uint32> pointset := sequence2points(att)
				{
					attribute<ipoint> att_ok:
					[
						{406000, 116000},{400000, 116000},{400000, 110000},{406000, 110000},{406000, 116000},{401047, 115164},{401238, 115099},{401462, 115075},
						{401475, 114991},{401567, 114983},{401545, 114739},{401757, 114803},{401765, 114673},{401790, 114655},{401803, 114574},{401980, 114626},
						{401988, 114592},{402049, 114612},{402086, 114462},{402197, 114497},{402223, 114390},{402194, 114374},{402317, 114418},{402404, 114445},
						{402757, 114546},{402870, 114237},{403025, 113810},{403171, 113401},{403298, 113032},{403434, 112809},{403552, 112612},{403544, 112312},
						{403792, 112379},{403770, 112450},{403939, 112611},{404063, 112893},{404154, 112857},{404256, 112989},{404300, 112976},{404353, 113116},
						{404576, 113022},{404669, 113068},{404669, 113160},{404776, 113283},{404923, 113297},{404996, 113582},{405183, 113537},{405282, 113561},
						{405282, 113562},{405353, 113625},{405415, 113601},{405454, 113512},{405495, 113478},{405013, 112720},{404620, 112098},{404631, 112040},
						{404664, 111986},{404649, 111969},{404555, 111996},{404271, 112054},{404157, 112066},{404010, 112054},{403934, 112040},{403834, 112009},
						{403701, 111952},{403372, 111821},{402859, 111567},{402382, 111433},{402133, 111453},{401653, 111646},{401477, 111716},{401234, 111711},
						{401063, 111873},{400943, 112215},{400864, 112187},{400817, 112176},{400893, 112424},{400916, 112666},{400883, 113120},{400886, 113192},
						{400888, 113291},{400919, 113685},{400926, 113796},{400965, 114314},{400978, 114523},{401047, 115164},{406000, 116000}
					];
					attribute<bool> test := point == att_ok;
				}
				parameter<bool> test_param := =#District = 0 ? '#pointset == 0'  : 'all(pointset/test)';
			}
			container multiply
			{
				parameter<ipoint> att (poly) := source/square/boundary_mul[0] * union_polygon/att;
				unit<uint32> pointset := sequence2points(att)
				{
					attribute<ipoint> att_ok:
					[
						{401047, 115164},{400978, 114523},{400965, 114314},{400926, 113796},{400919, 113685},{400888, 113291},{400886, 113192},{400883, 113120},
						{400916, 112666},{400893, 112424},{400817, 112176},{400864, 112187},{400943, 112215},{401063, 111873},{401234, 111711},{401477, 111716},
						{401653, 111646},{402133, 111453},{402382, 111433},{402859, 111567},{403000, 111636},{403000, 113878},{402870, 114237},{402757, 114546},
						{402404, 114445},{402317, 114418},{402194, 114374},{402223, 114390},{402197, 114497},{402086, 114462},{402049, 114612},{401988, 114592},
						{401980, 114626},{401803, 114574},{401790, 114655},{401765, 114673},{401757, 114803},{401545, 114739},{401567, 114983},{401475, 114991},
						{401462, 115075},{401238, 115099},{401047, 115164}
					];
					attribute<bool> test := point == att_ok;
				}
				parameter<bool> test_param := =#District = 0 ? '#pointset == 0'  : 'all(pointset/test)';
				
				parameter<ipoint> mul_arc (arc) := ipolygon(Source/road/line_cross[1]) * ipolygon(Source/road/line_cross[2]);

			}
			container plus
			{
				parameter<ipoint> att (poly):= source/square/boundary_plus1[0] + source/square/boundary_plus2[0];
				unit<uint32> pointset := sequence2points(att)
				{
					attribute<ipoint> att_ok:
					[
						 {406000, 116000},{400000, 116000},{400000, 110000},{406000, 110000},{406000, 116000},{416000, 116000}
						,{410000, 116000},{410000, 110000},{416000, 110000},{416000, 116000},{406000, 116000}
					];
					attribute<bool> test := point == att_ok;
				}
				parameter<bool> test_param := =#District = 0 ? '#pointset == 0'  : 'all(pointset/test)';
			}
			container StringToSequence
			{
				container source
				{
					parameter<string> param  := '{10: 41 9999 42 10 600 1 7 116 0 110}';
					unit<uint32> posListUnit := range(uint32, 0, 1);
					unit<uint32> pointSet    := range(uint32, 0, 10)
					{
						attribute<float64> float64: [41,9999,42,10,600,1,7,116,0,110];
					}
				}
				container tests
				{
					parameter<uint64>  param_uint64  (poly) := Uint64Seq(source/param)
					{
						unit<uint32>    elements                 := sequence2points(union_data(source/posListUnit, .));
						attribute<bool> att_ok (source/pointSet) := union_data(source/pointSet, elements/point) == uint64(source/pointSet/float64);
						parameter<bool> test                     := all(att_ok);
					}
					parameter<uint32>  param_uint32  (poly) := Uint32Seq(source/param)
					{
						unit<uint32>    elements                 := sequence2points(union_data(source/posListUnit, .));
						attribute<bool> att_ok (source/pointSet) := union_data(source/pointSet, elements/point) == uint32(source/pointSet/float64);
						parameter<bool> test                     := all(att_ok);
					}
					parameter<uint16>  param_uint16  (poly) := Uint16Seq(source/param)
					{
						unit<uint32>    elements                 := sequence2points(union_data(source/posListUnit, .));
						attribute<bool> att_ok (source/pointSet) := union_data(source/pointSet, elements/point) == uint16(source/pointSet/float64);
						parameter<bool> test                     := all(att_ok);
					}
					parameter<uint8>   param_uint8   (poly) := Uint8Seq(source/param)
					{
						unit<uint32>    elements                 := sequence2points(union_data(source/posListUnit, .));
						attribute<bool> att_ok (source/pointSet) := eq_or_both_null(union_data(source/pointSet, elements/point), uint8(source/pointSet/float64));
						parameter<bool> test                     := all(att_ok);
					}
					parameter<int64>   param_int64   (poly) := Int64Seq(source/param)
					{
						unit<uint32>    elements                 := sequence2points(union_data(source/posListUnit, .));
						attribute<bool> att_ok (source/pointSet) := union_data(source/pointSet, elements/point) == int64(source/pointSet/float64);
						parameter<bool> test                     := all(att_ok);
					}
					parameter<int32>   param_int32   (poly) := Int32Seq(source/param)
					{
						unit<uint32>    elements                 := sequence2points(union_data(source/posListUnit, .));
						attribute<bool> att_ok (source/pointSet) := union_data(source/pointSet, elements/point) == int32(source/pointSet/float64);
						parameter<bool> test                     := all(att_ok);
					}
					parameter<int16>   param_int16   (poly) := Int16Seq(source/param)
					{
						unit<uint32>    elements                 := sequence2points(union_data(source/posListUnit, .));
						attribute<bool> att_ok (source/pointSet) := union_data(source/pointSet, elements/point) == int16(source/pointSet/float64);
						parameter<bool> test                     := all(att_ok);
					}
					parameter<int8>    param_int8    (poly) := Int8Seq(source/param)
					{
						unit<uint32>    elements                 := sequence2points(union_data(source/posListUnit, .));
						attribute<bool> att_ok (source/pointSet) := eq_or_both_null(union_data(source/pointSet, elements/point),int8(source/pointSet/float64));
						parameter<bool> test                     := all(att_ok);
					}
					parameter<float64> param_float64 (poly) := Float64Seq(source/param)
					{
						unit<uint32>    elements                 := sequence2points(union_data(source/posListUnit, .));
						attribute<bool> att_ok (source/pointSet) := union_data(source/pointSet, elements/point) == source/pointSet/float64;
						parameter<bool> test                     := all(att_ok);
					}
					parameter<float32> param_float32 (poly) := Float32Seq(source/param)	
					{
						unit<uint32>    elements                 := sequence2points(union_data(source/posListUnit, .));
						attribute<bool> att_ok (source/pointSet) := union_data(source/pointSet, elements/point) == float32(source/pointSet/float64);
						parameter<bool> test                     := all(att_ok);
					}
				}
			}
			container bg_simplify: Using = "source"
			{
				container Circle
				{
					unit<uint32> template: nrofrows = 65
					{
						attribute<float64> angle := float64(id(.)) * 2d * float64(pi()) / 64d;
						attribute<float64> x     := cos(angle);
						attribute<float64> y     := sin(angle);
					}

					unit<uint32> shape: nrofrows = 1
					{
						attribute<point_rd> centre_point := const(point(156000f, 461000f, point_rd),.);
					}

					parameter<m> radius   := 500[m];
					unit<uint32> pointset := combine(shape, template)
					{
						attribute<point_rd> point :=
							point(
								 pointcol(shape/centre_point[nr_1]) + radius * float32(circle/template/x[nr_2])
								,pointrow(shape/centre_point[nr_1]) + radius * float32(circle/template/y[nr_2])
								,point_rd
							);
						attribute<uint32> ordinal := #pointset - nr_2 - 1;
					}
					attribute<point_rd> geometry     (poly, shape) := points2sequence(pointset/point, pointset/nr_1, pointset/ordinal);
					attribute<point_rd> geometry_arc (arc, shape)  := points2sequence(pointset/point, pointset/nr_1, pointset/ordinal)
					{
						parameter<int16>  PenWidth      := 2s          , DialogType = "PenWidth";
					}
				}
				attribute<point_rd> circle_border (Circle/shape, arc)  := bg_simplify_linestring(Circle/geometry, 50.0)
				{
					parameter<int16>  PenWidth      := 2s          , DialogType = "PenWidth";
				}
				attribute<point_rd> circle_poly   (Circle/shape, poly) := bg_simplify_polygon(Circle/geometry, 50.0);
				
				
				attribute<point_rd> border  (district, arc) := bg_simplify_linestring(district/border, 100.0)
				{
					parameter<uint32> Brushcolor := rgb(0,255,0), DialogType = "BrushColor";
					parameter<uint32> Pencolor   := rgb(0,0,200), DialogType = "PenColor";
				}

				attribute<point_rd> poly  (district, poly) := bg_simplify_polygon(district/border, 100.0)
				{
					parameter<uint32> Brushcolor := rgb(0,255,0), DialogType = "BrushColor";
					parameter<uint32> Pencolor   := rgb(0,0,200), DialogType = "PenColor";
				}

				unit<uint32> pointset_border := sequence2points(border);
				unit<uint32> pointset_poly := sequence2points(poly);

				parameter<bool> isEmpty := #pointset_border == 0;

				container tests
				{
					container circle
					{
						unit<uint32> pointset_border := sequence2points(circle_border)
						{
							attribute<point_rd> ok   : [{461500, 156000},{461354, 155646},{461000, 155500},{460646, 155646},{460500, 156000},{460646, 156354},{461000, 156500},{461354, 156354},{461500, 156000}];
							attribute<bool>     test := point_isNearby(point, ok, Dif_all_float32);
						}
						unit<uint32> pointset_line   := sequence2points(circle_poly)
						{
							attribute<point_rd> ok   : [{460500, 156000},{460646, 156354},{461000, 156500},{461354, 156354},{461500, 156000},{461354, 155646},{461000, 155500},{460646, 155646},{460500, 156000}];
							attribute<bool>     test := point_isNearby(point, ok, Dif_all_float32);
						}
						parameter<bool> test_attr := all(pointset_border/test) && all(pointset_line/test);
					}
					container border
					{
						attribute<bool> geometry   (pointset_border):= = isEmpty
							? 'union_data(pointset_border, source/pointset/Point) == pointset_border/point' 
							: 'union_data(pointset_border, source/bg_simplify/pointset_border/Point) == pointset_border/point';
						attribute<bool> sequenceNr (pointset_border):= =isEmpty 
							? 'union_data(pointset_border, source/pointset/districtnr ) == pointset_border/SequenceNr ' 
							: 'union_data(pointset_border, source/bg_simplify/pointset_border/Point) == pointset_border/point';
						attribute<bool> ordinal    (pointset_border):= =isEmpty 
							? 'union_data(pointset_border, source/pointset/ordinal) == pointset_border/ordinal' 
							: 'union_data(pointset_border, source/bg_simplify/pointset_border/Point) == pointset_border/point';

						parameter<bool> test_attr := all(geometry) && all(sequenceNr) && all(ordinal);
					}
					container poly
					{
						attribute<bool> geometry   (pointset_poly):= = isEmpty
							? 'union_data(pointset_poly, source/pointset/Point) == pointset_poly/point' 
							: 'union_data(pointset_poly, source/bg_simplify/pointset_poly/Point) == pointset_poly/point';
						attribute<bool> sequenceNr (pointset_poly):= =isEmpty 
							? 'union_data(pointset_poly, source/pointset/districtnr ) == pointset_poly/SequenceNr ' 
							: 'union_data(pointset_poly, source/bg_simplify/pointset_poly/Point) == pointset_poly/point';
						attribute<bool> ordinal    (pointset_poly):= =isEmpty 
							? 'union_data(pointset_poly, source/pointset/ordinal) == pointset_poly/ordinal' 
							: 'union_data(pointset_poly, source/bg_simplify/pointset_poly/Point) == pointset_poly/point';

						parameter<bool> test_attr := all(geometry) && all(sequenceNr) && all(ordinal);
					}
				}
				parameter<bool> test_attr := tests/border/test_attr &&  tests/poly/test_attr;
			}
			container bg_buffer_multi_point: Using = "source"
			{
				unit<uint32> road_sel := Subset(id(RoadDomain) < 1)
				{
					attribute<point_rd> geometry (arc) := road/line[nr_OrgEntity];
					unit<uint32> pointset := Sequence2points(geometry);
				}
				attribute<point_rd>    att  (poly, road_sel) := bg_buffer_multi_point(road_sel/Geometry, 100d, 16b);
				unit<uint32> pointset := Sequence2points(att)
				{
					attribute<point_rd> ok:
					[
					 	 {399246, 112731},{399208, 112723},{399175, 112702},{399154, 112669},{399146, 112631},{399154, 112593},{399175, 112560},{399208, 112539},{399246, 112531}
						,{399284, 112539},{399317, 112560},{399338, 112593},{399346, 112631},{399338, 112669},{399317, 112702},{399284, 112723},{399246, 112731},{398599, 111966}
						,{398561, 111958},{398528, 111937},{398507, 111904},{398499, 111866},{398507, 111828},{398528, 111795},{398561, 111774},{398599, 111766},{398637, 111774}
						,{398670, 111795},{398691, 111828},{398699, 111866},{398691, 111904},{398670, 111937},{398637, 111958},{398599, 111966},{399246, 112731}
					];
					attribute<point_rd> ok_empty: [];
					attribute<bool> test  := = #pointset == 0 ? 'point_isNearby(point, ok_empty, Dif_all_float32)' : 'point_isNearby(point, ok, Dif_all_float32)';
				}
				parameter<bool> test_attr   := all(pointset/test);
			}
			container bg_buffer_linestring: Using = "source"
			{
				attribute<point_rd>    att  (poly, RoadDomain) := bg_buffer_linestring(road/line, 100d, 16b);
				unit<uint32> pointset := Sequence2points(att)
				{
					attribute<point_rd> ok:
					[{399170, 112696},{398523, 111931},{398504, 111896},{398499, 111858},{398510, 111820},{398534, 111790},{398569, 111771},{398607, 111766},{398645, 111777},{398675, 111801},
					 {399322, 112566},{399341, 112601},{399346, 112639},{399335, 112677},{399311, 112707},{399276, 112726},{399238, 112731},{399200, 112720},{399170, 112696},{399490, 111823},
					 {401784, 111425},{401823, 111426},{401859, 111442},{401886, 111471},{401900, 111507},{401899, 111546},{401883, 111582},{401854, 111608},{401818, 111623},{399512, 112023},
					 {399489, 112024},{398593, 111966},{398555, 111956},{398524, 111932},{398504, 111898},{398499, 111860},{398509, 111822},{398533, 111791},{398567, 111771},{398605, 111766},
					 {399490, 111823},{401526, 115021},{398581, 114923},{398543, 114914},{398511, 114891},{398490, 114858},{398484, 114820},{398493, 114782},{398516, 114750},{398549, 114729},
					 {398587, 114723},{401532, 114821},{401570, 114830},{401602, 114853},{401623, 114886},{401629, 114924},{401620, 114962},{401597, 114994},{401564, 115015},{401526, 115021}
					];
					attribute<point_rd> ok_empty: [];
					attribute<bool> test  := = #pointset == 0 ? 'point_isNearby(point, ok_empty, Dif_all_float32)' : 'point_isNearby(point, ok, Dif_all_float32)';
				}
				parameter<bool> test_attr   := all(pointset/test);
			}
			container bg_buffer_multi_polygon
			{
				attribute<point_rd>    src  (poly, SDomain) := Source/bg_buffer_multi_polygon/poly/geometry;
			
				attribute<point_rd>    att  (poly, SDomain) := bg_buffer_multi_polygon(src, 10d, 16b);
				unit<uint32> pointset := Sequence2points(att)
				{
					attribute<point_rd> ok:
					[
						{158100, 461110},{157950, 461110},{157946, 461109},{157943, 461107},{157941, 461104},{157940, 461100},{157940, 460900},
						{157941, 460896},{157943, 460893},{157946, 460891},{157950, 460890},{158100, 460890},{158104, 460891},{158107, 460893}, 
						{158109, 460896},{158110, 460900},{158110, 461100},{158109, 461104},{158107, 461107},{158104, 461109},{158100, 461110}, 
						{158500, 461510},{157500, 461510},{157496, 461509},{157493, 461507},{157491, 461504},{157490, 461500},{157490, 460500}, 
						{157491, 460496},{157493, 460493},{157496, 460491},{157500, 460490},{158500, 460490},{158504, 460491},{158507, 460493}, 
						{158509, 460496},{158510, 460500},{158510, 461500},{158509, 461504},{158507, 461507},{158504, 461509},{158500, 461510}, 
						{158190, 460810},{157810, 460810},{157810, 461190},{158190, 461190},{158190, 460810},{158500, 461510},{158100, 461110}
					];
					attribute<point_rd> ok_empty: [];
					attribute<bool> test  := = #pointset == 0 ? 'point_isNearby(point, ok_empty, Dif_all_float32)' : 'point_isNearby(point, ok, Dif_all_float32)';
				}
				parameter<bool> test_attr   := all(pointset/test);
			}


			container results
			{
				parameter<bool> tests := 
					   sequence2points/test_attr
					&& points2sequence/test_attr
					&& arc_length/test_attr 
					&& area/test_attr 
					&& lower_bound/test_attr
					&& upper_bound/test_attr
					&& center_bound/test_attr
					&& centroid/test_attr
					&& mid/test_attr
					&& centroid_or_mid/test_attr
					&& centroid_or_mid_complex/test_attr
					&& poly2grid/test_attr
					&& union_polygon/test_attr
					&& partitioned_union_polygon/test_attr
					&& overlay_polygon/intersect/test
					&& split/single_polygons/test
					&& inflate/test_attr
					&& deflate/test_attr
					&& connectivity/polygon_connectvity/test_attr 
					&& difference/test_param
					&& multiply/test_param
					&& plus/test_param
					&& StringToSequence/tests/param_uint64/test
					&& StringToSequence/tests/param_uint32/test
					&& StringToSequence/tests/param_uint16/test
					&& StringToSequence/tests/param_uint8/test
					&& StringToSequence/tests/param_int64/test
					&& StringToSequence/tests/param_int32/test
					&& StringToSequence/tests/param_int16/test
					&& StringToSequence/tests/param_int8/test
					&& StringToSequence/tests/param_float64/test
					&& StringToSequence/tests/param_float32/test
					&& bg_simplify/test_attr
					&& bg_simplify/tests/Circle/test_attr 
					&& bg_buffer_multi_point/test_attr
					&& bg_buffer_linestring/test_attr
					&& bg_buffer_multi_polygon/test_attr;
			}
		}
	}
	container Network
	{
		container srcDomain      :=  Source(RDomain, RoadDomain, ADomain, HDomain ,LDomain);
		container srcEDomain     := ESource(EDomain, EDomain,    EDomain, EDomain ,EDomain);
		
		container srcTiledDomain  := Source(RTiledDomain, RoadTiledDomain, ATiledDomain, HTiledDomain ,LTiledDomain);
		container srcETiledDomain := ESource(ETiledDomain, ETiledDomain, ETiledDomain, ETiledDomain ,ETiledDomain);

		template Source
		{
			// begin case parameters
			unit<uint32> RDomain;
			unit<uint32> RoadDomain;
			unit<uint32> ODomain;
			unit<uint32> DDomain;
			unit<uint32> LDomain;
			// end case parameters

			unit<uint32> RoadCoordinates := RDomain,
				DialogData  = "point",
				DialogType  = "Map"
			{
				attribute<float32>  x: [112631,111866,111866,111924,111524,114921,114823];
				attribute<float32>  y: [399246,398599,398599,399495,401801,401529,398584];
				attribute<point_rd> point := point(y, x, /point_rd), Label = "RoadPoints";
				attribute<road>     SequenceNr: [0,0,1,1,1,2,2];
				attribute<uint32>   Ordinal:    [0,1,0,1,2,0,1];
			}
			unit<uint32> road := RoadDomain,
				DialogData  = "line",
				DialogType  = "Map"
			{
				attribute<point_rd> line (arc) := points2sequence(RoadCoordinates/Point, RoadCoordinates/SequenceNr, RoadCoordinates/Ordinal);
				attribute<point_rd> node_first : [{399246, 112631}, {398599, 111866}, {401529, 114921}];
				attribute<point_rd> node_last  : [{398599, 111866}, {401801, 111524}, {398584, 114823}];
				
				attribute<uint32> streetcode: [null,0,1];
			}
			unit<uint32> origin := ODomain
			,	DialogData  = "location"
			,	DialogType  = "Map"
			{
				attribute<float32>  x: [115135,111803,114903,111353,111741];
				attribute<float32>  y: [401331,399476,399289,401729,398696];
				attribute<point_rd> location := point(y, x, point_rd), Label = "Origins"
				{
					parameter<color>    SymbolColor:     DialogType = "SymbolColor",      = rgb(0,0,0);
					parameter<fontsize> SymbolSize:      DialogType = "SymbolSize",       = value(20, fontsize);
					parameter<m>        SymbolWorldSize: DialogType = "SymbolWorldSize",  = value(20, m);
				}
				attribute<destination> service_area:        [0,1,2,3,1];
				attribute<uint32>      connect_points:      [0,1,2,3,1];
				//attribute<origin>      connect_neighbour: [2,4,2,3,4];
				attribute<origin>      connect_neighbour:   [2,4,0,1,1];
				attribute<uint32>      SpatialIndex:        [0,1,10,63,86];
				attribute<uint32>      capacitated_connect: [2,1,2,1,1];
			}
			unit<uint32> destination := DDomain
			,	DialogData  = "location"
			,	DialogType  = "Map"
			{
				attribute<float32>  x: [115135,112601,114903,112156];
				attribute<float32>  y: [401331,399138,398600,401729];

				attribute<point_rd> location := point(y, x, point_rd), Label = "Destinations"
				{
					parameter<color>    SymbolColor:     DialogType = "SymbolColor",      = rgb(255,0,0),        DisableStorage = "True";
					parameter<fontsize> SymbolSize:      DialogType = "SymbolSize",       = value(30, fontsize), DisableStorage = "True";
					parameter<m>        SymbolWorldSize: DialogType = "SymbolWorldSize",  = value(25, m),        DisableStorage = "True";
				}
				attribute<string>   destinationnr_str := string(id(destination)), DialogType = "LabelText"
				{
					parameter<float32> LabelSize: DialogType = "LabelSize", = float32(14);
				}
			}
			unit<uint32> location := LDomain
			,	DialogData = "location"
			,	DialogType = "Map"
			{
				attribute<float32>  x: [115135,111803,114903,111353,111741,112601,114903,112156];
				attribute<float32>  y: [401331,399476,399289,401729,398696,399138,398600,401729];
				attribute<point_rd> location                       := point(y, x, point_rd);
				attribute<point_rd> location_with_undefined_values := id(.) == 1 || id(.) == 4 ? point(0f / 0f, 0f / 0f, point_rd) : location;

				attribute<UInt32>   streetcode : [0,0,0,0,0,0,null,0];
				
				attribute<float64>  ci_dis : [220.466762,119.519942,56.5086196,180.789468,131.004833,63.0891738,79.4236098,610.39593];
				attribute<uint32>   ci_arc : [2,1,2,1,1,0,2,1];
				attribute<float32>  ci_x   : [114915,111922,114847,111531,111872,112560,114824,111555];
				attribute<float32>  ci_y   : [401338,399468,399291,401760,398688,399186,398603,401625];
				attribute<bool>     ci_inA : [True,True,True,True,True,True,True,True];
				attribute<bool>     ci_inS : [True,True,True,True,True,True,True,True];
				attribute<uint32>   ci_seg : [0,0,0,1,0,0,0,1];
				
				attribute<float64>  ce_dis : [3477.54413,119.519942,2986.08514,180.789468,131.004833,698.647152,79.4236098,610.39593];
				attribute<uint32>   ce_arc : [1,1,1,1,1,1,2,1];
				attribute<float32>  ce_x   : [111709,111922,111923,111531,111872,111904,114824,111555];
				attribute<float32>  ce_y   : [400737,399468,399482,401760,398688,399183,398603,401625];
				attribute<bool>     ce_inA : [True,True,True,True,True,True,True,True];
				attribute<bool>     ce_inS : [True,True,True,True,True,True,True,True];
				attribute<uint32>   ce_seg : [1,0,0,1,0,0,0,1];

				attribute<float64>  cn_dis : [220.466762,710.305647,56.5086196,2792.59252,158.221364,63.0891738,79.4236098,2528.02571];
				attribute<uint32>   cn_arc : [2,0,2,0,0,0,2,0];
				attribute<float32>  cn_x   : [114915,111922,114847,112631,111872,112560,114824,111555];
				attribute<float32>  cn_y   : [401338,399468,399291,399426,398688,399186,398603,401625];
				attribute<bool>     cn_inA : [True,True,True,False,False,True,True,False];
				attribute<bool>     cn_inS : [True,True,True,False,False,True,True,False];
				attribute<uint32>   cn_seg : [0,0,0,0,0,0,0,0];

			}
			container shapefiles
			{
				unit<uint32> roads
				:	StorageName = "%projDir%/data/roads.shp"
				,	StorageType = "gdal.vect"
				,	DialogData  = "lijn"
				,	DialogType  = "Map"
				,	SyncMode   =  "none"
				{
					attribute<fpoint> lijn(arc);
					attribute<uint32> straatcode;
				}
				unit<uint32> locations
				:	StorageName = "%projDir%/data/loc_not_con.shp"
				,	StorageType = "gdal.vect"
				,	DialogData  = "location"
				,	DialogType  = "Map"
				,	SyncMode   =  "none"
				{
					attribute<fpoint> location;
					attribute<uint32> straatcode;
					attribute<bool>   straatcode_komt_voor_in_roads := isDefined(rlookup(straatcode, roads/straatcode)), DisableStorage = "True";
				}
			}
		}

		template ESource
		{
			// begin case parameters
			unit<uint32> RDomain;
			unit<uint32> RoadDomain;
			unit<uint32> ODomain;
			unit<uint32> DDomain;
			unit<uint32> LDomain;
			// end case parameters

			unit<uint32> RoadCoordinates := RDomain,
				DialogData  = "point",
				DialogType  = "Map"
			{
				attribute<float32>  x: [];
				attribute<float32>  y: [];
				attribute<point_rd> point := point(y, x, /point_rd), Label = "RoadPoints";
				attribute<road>     SequenceNr: [];
				attribute<uint32>   Ordinal:    [];
			}
			unit<uint32> road := RoadDomain,
				DialogData  = "line",
				DialogType  = "Map"
			{
				attribute<point_rd> line (arc) := points2sequence(RoadCoordinates/Point, RoadCoordinates/SequenceNr, RoadCoordinates/Ordinal);
				attribute<point_rd> node_first : [];
				attribute<point_rd> node_last  : [];
				
				attribute<uint32> streetcode: [];
			}
			unit<uint32> origin := ODomain
			,	DialogData  = "location"
			,	DialogType  = "Map"
			{
				attribute<float32>  x: [];
				attribute<float32>  y: [];
				attribute<point_rd> location := point(y, x, point_rd), Label = "Origins"
				{
					parameter<color>    SymbolColor:     DialogType = "SymbolColor",      = rgb(0,0,0);
					parameter<fontsize> SymbolSize:      DialogType = "SymbolSize",       = value(20, fontsize);
					parameter<m>        SymbolWorldSize: DialogType = "SymbolWorldSize",  = value(20, m);
				}
				attribute<destination> service_area:        [];
				attribute<uint32>      connect_points:      [];
				attribute<origin>      connect_neighbour:   [];
				attribute<uint32>      SpatialIndex:        [];
				attribute<uint32>      capacitated_connect: [];
			}
			unit<uint32> destination := DDomain
			,	DialogData  = "location"
			,	DialogType  = "Map"
			{
				attribute<float32>  x: [];
				attribute<float32>  y: [];

				attribute<point_rd> location := point(y, x, point_rd), Label = "Destinations"
				{
					parameter<color>    SymbolColor:     DialogType = "SymbolColor",      = rgb(255,0,0),        DisableStorage = "True";
					parameter<fontsize> SymbolSize:      DialogType = "SymbolSize",       = value(30, fontsize), DisableStorage = "True";
					parameter<m>        SymbolWorldSize: DialogType = "SymbolWorldSize",  = value(25, m),        DisableStorage = "True";
				}
				attribute<string>   destinationnr_str := string(id(destination)), DialogType = "LabelText"
				{
					parameter<float32> LabelSize: DialogType = "LabelSize", = float32(14);
				}
			}
			unit<uint32> location := LDomain
			,	DialogData = "location"
			,	DialogType = "Map"
			{
				attribute<float32>  x: [];
				attribute<float32>  y: [];
				attribute<point_rd> location                       := point(y, x, point_rd);
				attribute<point_rd> location_with_undefined_values := id(.) == 1 || id(.) == 4 ? point(0f / 0f, 0f / 0f, point_rd) : location;

				attribute<UInt32>   streetcode : [];
				
				attribute<float64>  ci_dis : [];
				attribute<uint32>   ci_arc : [];
				attribute<float32>  ci_x   : [];
				attribute<float32>  ci_y   : [];
				attribute<bool>     ci_inA : [];
				attribute<bool>     ci_inS : [];
				attribute<uint32>   ci_seg : [];

				attribute<float64>  ce_dis : [];
				attribute<uint32>   ce_arc : [];
				attribute<float32>  ce_x   : [];
				attribute<float32>  ce_y   : [];
				attribute<bool>     ce_inA : [];
				attribute<bool>     ce_inS : [];
				attribute<uint32>   ce_seg : [];

				attribute<float64>  cn_dis : [];
				attribute<uint32>   cn_arc : [];
				attribute<float32>  cn_x   : [];
				attribute<float32>  cn_y   : [];
				attribute<bool>     cn_inA : [];
				attribute<bool>     cn_inS : [];
				attribute<uint32>   cn_seg : [];
			}
			container shapefiles
			{
				unit<uint32> roads: nrOfRows = 0
				{
					attribute<fpoint> lijn(arc)  := points2sequence(locations/location, id(locations)[roads], id(locations));
					attribute<uint32> straatcode : [];
				}
				unit<uint32> locations: nrOfRows = 0
				{
					attribute<float32> X:[];
					attribute<float32> Y:[];

					attribute<fpoint> location   := point(X,Y, fpoint);
					attribute<uint32> straatcode : [];
					attribute<bool>   straatcode_komt_voor_in_roads := isDefined(rlookup(straatcode, roads/straatcode)), DisableStorage = "True";
				}
			}
		}

		container UnTiled  := Template(RDomain,      RoadDomain,      ADomain,      HDomain      ,LDomain     , srcDomain);
		container Tiled    := Template(RTiledDomain, RoadTiledDomain, ATiledDomain, HTiledDomain ,LTiledDomain, srcTiledDomain);
		container EUnTiled := Template(EDomain,      EDomain,         EDomain,      EDomain      ,EDomain     , srcEDomain);
		container ETiled   := Template(ETiledDomain, ETiledDomain,    ETiledDomain, ETiledDomain ,ETiledDomain, srcETiledDomain);

		container ResultUnitTiled
		{
			unit<uint32> connect := connect(Network/srcDomain/Road/line , point/ResultUnitTiled/dyna_point_tiled/CalcPoint/point)
			{
				parameter<bool> test_attr := sum(nr_orgEntity) == 3 && #. == 476870 && nr_orgEntity[2] == 2;
			}
			container connect_info := connect_info(Network/srcDomain/Road/line , point/ResultUnitTiled/dyna_point_tiled/CalcPoint/point)
			{
				parameter<bool> test_attr := float_isNearby(mean(float32(dist)), 462516.269f, dif_all_float32) && count(ArcId) == 476867 && all(ArcID == 2);
			}
		}

		Template Template
		{
			// begin case parameters
			unit<uint32> RDomain;
			unit<uint32> RoadDomain;
			unit<uint32> ODomain;
			unit<uint32> DDomain;
			unit<uint32> LDomain;

			container Source;
			// end case parameters

			container first_node: url = "http://www.objectvision.nl/geodms/operators-a-functions/network/first_node"
			{
				attribute<fpoint> att  (RoadDomain) := first_node(source/road/line);
				attribute<bool>   test (RoadDomain) := point_isNearby(att, source/road/node_first, Dif_all_float32);
				parameter<bool>   test_attr          := all(test);
			}
			container last_node: url = "http://www.objectvision.nl/geodms/operators-a-functions/network/last_node"
			{
				attribute<fpoint> att  (RoadDomain) := last_node(source/road/line);
				attribute<bool>   test (RoadDomain) := point_isNearby(att, source/road/node_last, Dif_all_float32);
				parameter<bool>   test_attr          := all(test);
			}
			container arc2segm: url = "http://www.objectvision.nl/geodms/operators-a-functions/network/arc2segm"
			{
				unit<uint32>    roadsegments := arc2segm(source/road/line);
				parameter<bool> test_attr    := #source/road == 0 ? (nrofrows(roadsegments) == 0 && sum(roadsegments/SequenceNr) == 0) : (nrofrows(roadsegments) == 4 && sum(roadsegments/SequenceNr) == 4);
			}
			unit<uint32> connect := connect(source/road/line, source/location/location)
			,	url  = "http://www.objectvision.nl/dms/Operator/connect.htm"
			{
				attribute<point_rd> UnionData(arc);
				attribute<m>        length                := arc_length(UnionData,m);
				attribute<m>        att_ok_with_values    : [92.6592,88.7168,190.762,220.466,119.523,56.5077,180.794,131.008,63.0789,79.4272,610.393,2048.6,2188.26,688.6,41.7082,782.384,909.256,18.6665,137.238];
				attribute<m>        att_ok_without_values : [];
				attribute<m>        att_ok                :==  #source/road == 0 ? 'att_ok_without_values' : 'att_ok_with_values';
				
				attribute<bool>     test      := float_isNearby(length, att_ok, Dif_all_float32);
				parameter<bool>     test_attr := all(test);
			}
			unit<uint32> connect_null_values := connect(source/road/line, source/location/location_with_undefined_values)
			,	url  = "http://www.objectvision.nl/dms/Operator/connect.htm"
			{
				attribute<point_rd> UnionData(arc);
				attribute<m>        length                := arc_length(UnionData,m);
				attribute<m>        att_ok_with_values    : [92.6592,3059.36,190.762,220.466,56.5077,180.794,63.0789,79.4272,610.393,2048.6,688.6,41.7082,909.256,18.6665,137.238];
				attribute<m>        att_ok_without_values : [];
				attribute<m>        att_ok                :==  #source/road == 0 ? 'att_ok_without_values' : 'att_ok_with_values';
				attribute<bool>     test                  := float_isNearby(length, att_ok, Dif_all_float32);
				parameter<bool>     test_attr             := all(test);
			}
			container connect_arc_length_zero
			{
				unit<uint32> arc : StorageName = "%projdir%/data/weg_connect_issue.shp"
				,	StorageType = "gdal.vect"
				,	DialogType = "Map"
				,	DialogData = "geometry"
				,	StorageReadOnly = "true"
				{
					attribute<fpoint> geometry (arc);
				}
				unit<uint32> point: nrofrows = 1
				{
					attribute<fpoint> geometry := const(point(100001f, 400001f, fpoint),.);
				}
				unit<uint32> connected :=  connect( arc/geometry , point/geometry )
				{
					attribute<fpoint> UnionData (arc);
					attribute<m>      length      := arc_length(UnionData, m);
					parameter<m>      length_tot  := sum(length);
					parameter<bool>   test        := round(length_tot)[m] == 293161[m];
				}
			}
			unit<uint32> connect_eq := connect_eq(source/road/line, source/road/streetcode, source/location/location, source/location/streetcode)
			,	url  = "http://www.objectvision.nl/dms/Operator/connect.htm"
			{
				attribute<point_rd> UnionData(arc);
				attribute<m>        length    := arc_length(UnionData,m);
				attribute<m>        att_ok_with_values    : [1001.92,88.7168,2927.96,3477.54,119.523,2986.08,180.794,131.008,698.646,79.4272,610.393,901.292,13.309,1273.66,41.7082,496.631,285.753,18.6665,137.238];
				attribute<m>        att_ok_without_values : [];
				attribute<m>        att_ok                :==  #source/road == 0 ? 'att_ok_without_values' : 'att_ok_with_values';
				attribute<bool>     test      := float_isNearby(length, att_ok, Dif_all_float32);
				parameter<bool>     test_attr := all(test);
			}
			unit<uint32> connect_ne := connect_ne(source/road/line, source/road/streetcode, source/location/location, source/location/streetcode)
			,	url  = "http://www.objectvision.nl/dms/Operator/connect.htm"
			{
				attribute<point_rd> UnionData(arc);
				attribute<m>        length    := arc_length(UnionData,m);
				attribute<m>        att_ok_with_values    : [92.6592,3238.31,190.762,220.466,710.303,56.5077,2792.59,158.221,63.0789,79.4272,2528.03,2048.6,518.231,688.6,391.025,18.6665];
				attribute<m>        att_ok_without_values : [];
				attribute<m>        att_ok                :==  #source/road == 0 ? 'att_ok_without_values' : 'att_ok_with_values';
				attribute<bool>     test      := float_isNearby(length, att_ok, Dif_all_float32);
				parameter<bool>     test_attr := all(test);
			}
			container connected_info := connect_info(source/Road/Line, source/location/location)
			,	Using = "source"
			,	url   = "http://www.objectvision.nl/geodms/operators-a-functions/network/connect_info"
			{
				attribute<point_rd> cpo(LDomain) := point(source/location/ci_y, source/location/ci_x, point_rd);
				attribute<bool>     test(LDomain):=    
					   float_isNearby(dist, source/location/ci_dis, Dif_all_float64) && arcID == source/location/ci_arc 
					&& point_isNearby(CutPoint, cpo,Dif_all_float32) && source/location/ci_inA == inArc 
					&& inSegm == source/location/ci_inS && SegmID == source/location/ci_seg;
				parameter<bool> test_attr := all(test);
			}
			container connected_info_eq := connect_info_eq(source/road/line, source/road/streetcode, source/location/location, source/location/streetcode), Using = "source"
			{
				attribute<point_rd> cpo(LDomain) := point(source/location/ce_y,source/location/ce_x,point_rd);
				attribute<bool>     test(LDomain):= 
					   float_isNearby(dist, source/location/ce_dis, Dif_all_float64)    && arcID == source/location/ce_arc 
					&& point_isNearby(CutPoint, cpo,Dif_all_float32) && source/location/ce_inA == inArc 
					&& inSegm == source/location/ce_inS && SegmID == source/location/ce_seg;
				parameter<bool> test_attr := all(test);
			}
			container connected_info_eq_shapefile := 
				connect_info_eq(source/shapefiles/roads/lijn, source/shapefiles/roads/straatcode, source/shapefiles/locations/location, source/shapefiles/locations/straatcode);

			container connected_info_ne := connect_info_ne(source/road/line, source/road/streetcode, source/location/location, source/location/streetcode),Using = "source"
			{
				attribute<point_rd> cpo  (LDomain) := point(source/location/cn_y,source/location/cn_x,point_rd);
				attribute<bool>     test (LDomain):= 
					   float_isNearby(dist, source/location/cn_dis, Dif_all_float64)    && arcID = source/location/cn_arc 
					&& point_isNearby(CutPoint, cpo,Dif_all_float32) && source/location/cn_inA = inArc 
					&& inSegm = source/location/cn_inS && SegmID = source/location/cn_seg;
				parameter<bool> test_attr := all(test);
			}
			container connect_points
			:	Using = "source"
			,	url   = "http://www.objectvision.nl/geodms/operators-a-functions/network/connect"
			{
				attribute<DDomain> att  (ODomain) := connect(destination/location, origin/location);
				attribute<bool>    test (ODomain) := att == origin/connect_points;
				parameter<bool>    test_attr      := all(test);
				
				attribute<Grid/units/GridDomain3000> att_pointdomain  (Grid/units/GridDomain) := connect(Grid/units/GridDomain3000/P, Grid/units/GridDomain/P);
				attribute<bool>                      test_pointdomain (Grid/units/GridDomain) := att_pointdomain == Grid/units/GridDomain/GridDomain3000nr;
				parameter<bool>                      test_pointdomain_attr                    := all(test_pointdomain);
			}
			container connect_neighbour
			{
				unit<uint32>       origin        := source/origin;
				attribute<ODomain> att  (ODomain) := connect_neighbour(origin/location);
				attribute<bool>    test (ODomain) := att == origin/connect_neighbour;
				parameter<bool>    test_attr     := all(test);
			}
			container capacitated_connect: Using = "source"
			{
				attribute<float64> cap_with_values     (DDomain) :[40,90,60,40];
				attribute<float64> cap_without_values  (DDomain) :[];
				attribute<float64> cap  (DDomain) := = #DDomain == 0 ? 'cap_without_values' : 'cap_with_values';
				
				attribute<DDomain> att  (ODomain) := capacitated_connect(destination/location, cap, origin/location, const(60D,origin));
				attribute<bool>    test (ODomain) := att == origin/capacitated_connect;
				parameter<bool>    test_attr     := all(test);
			}

			container connected
			{
				unit <uint32> LinkSet_org := arc2segm(connect/UnionData)
				,	DialogData = "segments"
				,	DialogType = "Map"
				{
					attribute<bool> isConnectionToLocation := 
						   IsDefined(
							  rlookup(
								  point
								, source/location/location
							  )
						)
						|| IsDefined(
							  rlookup(
								  nextpoint
								, source/location/location
							  )
						);

					attribute<point_rd> point;
					attribute<point_rd> nextpoint;
				}
				unit <uint32> LinkSet_extra // bedoeld om de verbindingen die door de connect zijn gemaakt naar de locations dubbel op te nemen voor de dijkstra_directed
				:= subset(LinkSet_org/isConnectionToLocation)
				,	DialogData = "segments"
				,	DialogType = "Map"
				{
					attribute<point_rd> point     := LinkSet_org/nextpoint[nr_OrgEntity];
					attribute<point_rd> nextpoint := LinkSet_org/point[nr_OrgEntity];
				}
				
				unit <uint32> LinkSet := Union_Unit(LinkSet_org,LinkSet_extra)
				,	DialogData = "segments"
				,	DialogType = "Map"
				{
					attribute<point_rd> point     := Union_Data(.,LinkSet_org/point    ,LinkSet_extra/point);
					attribute<point_rd> nextpoint := Union_Data(.,LinkSet_org/nextpoint,LinkSet_extra/nextpoint);
		
					unit<uint32> pointset := Union(point, nextpoint)
					{
						attribute<point_rd> UnionData;
						attribute<LinkSet>  ArcID  := value(ID(pointset) % nrofrows(LinkSet), LinkSet);
						attribute<uint32>   VolgNr := ID(pointset) / nrofrows(LinkSet);
					}
					attribute<point_rd> segments(arc) := points2sequence(pointset/UnionData, pointset/ArcID, pointset/VolgNr);
					attribute<m>        dist          := value(dist(point, nextpoint), /m);
				}
				unit<uint32> NodeSet := unique(SubItem(union(LinkSet/point, LinkSet/nextpoint), 'UnionData')),
					DialogData = "Values",
					DialogType = "Map"
				{
					attribute<point_rd> Values;
				}
		
				attribute<NodeSet> F1(LinkSet) := rlookup(LinkSet/point,     NodeSet/Values),IsHidden = "True";
				attribute<NodeSet> F2(LinkSet) := rlookup(LinkSet/nextpoint, NodeSet/Values),IsHidden = "True";
		
				attribute<NodeSet> nr_OriginNode      (ODomain) := rlookup(source/origin/location, NodeSet/Values);
				attribute<NodeSet> nr_DestinationNode (DDomain) := rlookup(source/destination/location, NodeSet/Values);

				unit<uint32> parts := connected_parts(F1, F2)
				,	Using = "source"
				,	url   = "http://www.objectvision.nl/geodms/operators-a-functions/network/connected_parts"
				{
					attribute<uint32> par_with_values    (nodeset) : [0,1,0,0,1,1,1,1,1,0,0,1,1,1,0,0,0,1,1,1,1,1];
					attribute<uint32> par_without_values (nodeset) : [];
					attribute<uint32> par                (nodeset) := =#nodeset == 0 ? 'par_without_values' : 'par_with_values';
					
					attribute<bool>   test(nodeset) := Partnr = par;
					parameter<bool>   test_attr     := all(test);
				}
			}
			container dijkstra
			:	url   = "http://www.objectvision.nl/geodms/operators-a-functions/network/dijkstra"
			,	Using = "connected"
			{
//				attribute<m> distance_nodeset (NodeSet) := dijkstra(LinkSet/dist, F1, F2, nr_DestinationNode)"
				attribute<m> distance_nodeset (NodeSet) := dijkstra_s('bidirectional;startPoint(Node_rel);node:TraceBack', LinkSet/dist, F1, F2, nr_DestinationNode)
				{
					attribute<LinkSet> TraceBack (NodeSet);
				}
				attribute<m>     att                   (ODomain) := lookup(nr_OriginNode, distance_nodeset);
				attribute<m>     att_ok_with_values    (ODomain) : [0,1962.96,824.535,928.425,1192.06];
				attribute<m>     att_ok_without_values (ODomain) : [];
				attribute<m>     att_ok                (ODomain) := = #ODomain == 0 ? 'att_ok_without_values' : 'att_ok_with_values';
				
				attribute <bool> test                  (ODomain) := float_isNearby(att, att_ok, Dif_all_float32);

				parameter <bool> test_attr := all(test);
			}
			container dijkstra_directed
			:	url   = "http://www.objectvision.nl/geodms/operators-a-functions/network/dijkstra"
			,	Using = "connected"
			{
//				attribute<m> distance_nodeset_directed (NodeSet) := dijkstra_directed(LinkSet/dist, F1, F2, nr_DestinationNode)"
				attribute<m> distance_nodeset_directed (NodeSet) := dijkstra_s('directed;startPoint(Node_rel);node:TraceBack',LinkSet/dist, F1, F2, nr_DestinationNode)
				{
					attribute<LinkSet> TraceBack (NodeSet);
				}
				attribute<m>     att                   (ODomain) := lookup(nr_OriginNode, distance_nodeset_directed);
				attribute<m>     att_ok_with_values    (ODomain) : [0,1962.96,2325.58,928.425,1192.06];
				attribute<m>     att_ok_without_values (ODomain) : [];
				attribute<m>     att_ok                (ODomain) := = #ODomain == 0 ? 'att_ok_without_values' : 'att_ok_with_values';

				attribute <bool> test                  (ODomain) := float_isNearby(att, att_ok, Dif_all_float32);

				parameter <bool> test_attr := all(test);
			}
			container dijkstra_maxdist
			:	url   = "http://www.objectvision.nl/geodms/operators-a-functions/network/dijkstra"
			,	Using = "connected"
			{
//				attribute<m> distance_nodeset (NodeSet) :=  dijkstra_maxdist(LinkSet/dist, F1, F2, nr_DestinationNode, 1000[m])
				attribute<m> distance_nodeset (NodeSet) :=  dijkstra_s('bidirectional;startPoint(Node_rel);cut(OrgZone_max_imp);node:TraceBack',LinkSet/dist, F1, F2, nr_DestinationNode, 1000[m])
				{
					attribute<LinkSet> TraceBack (NodeSet);
				}
				attribute<m>     att                   (ODomain) := lookup(nr_OriginNode, distance_nodeset);
				attribute<m>     att_ok_with_values    (ODomain) : [0,null,824.535,928.425,null];
				attribute<m>     att_ok_without_values (ODomain) : [];
				attribute<m>     att_ok                (ODomain) := = #ODomain == 0 ? 'att_ok_without_values' : 'att_ok_with_values';

				attribute <bool> test                  (ODomain) := float_isNearby(att, att_ok, Dif_all_float32);

				parameter <bool> test_attr := all(test);
			}

			unit<uint32> dijkstra_alt_impedance := dijkstra_m('bidirectional;startPoint(Node_rel);endPoint(Node_rel);alternative(link_imp):alt_imp;od:impedance,OrgZone_rel,DstZone_rel'
					, connected/LinkSet/dist
					, connected/F1
					, connected/F2
					, connected/nr_DestinationNode
					, connected/nr_DestinationNode
					, connected/LinkSet/dist
			);


			unit<uint64> dijkstra_interaction := 
				dijkstra_m64(
					'bidirectional;startPoint(Node_rel);endPoint(Node_rel);'
					'cut(OrgZone_max_imp);'
					'interaction(v_i,w_j,dist_decay):D_i,M_ix,C_j,M_xj,Link_flow;'
					'od:impedance,OrgZone_rel,DstZone_rel,LinkSet',
					connected/LinkSet/dist,       connected/F1                   , connected/F2,
					connected/nr_OriginNode,  connected/nr_DestinationNode,
					1000f, 
					1.0f, 1.0f, 0.0f
				)
			{
				parameter <bool> test_attr := float_isNearby(sum(M_ix), sum(M_xj), Dif_all_float32);
				
				attribute<float32> t_ij         := impedance < 1e+30f ? 1.0f : 0.0f;
				attribute<float32> M_ij         := t_ij*D_i[OrgZone_rel]^-1.0f;
				attribute<float32> M_i(ODomain) := sum(M_ij, OrgZone_rel);
				attribute<float32> M_j(DDomain) := sum(M_ij, DstZone_rel);
				
			}
			parameter<float32> distDecay    := 0.001f;
			parameter<float32> demand_alpha := 1.0f;
			parameter<float32> min_imp      := 0.0f;
			unit<uint64> dijkstra_all_interaction := 
				dijkstra_m64(
					'bidirectional;'
					'interaction(OrgZone_min,v_i,w_j,dist_decay,OrgZone_alpha):D_i,M_ix,C_j,M_xj,Link_flow;'
					'od:impedance,OrgZone_rel,DstZone_rel,LinkSet',
					connected/LinkSet/dist, connected/F1, connected/F2,
					min_imp, 1.0f, 1.0f, distDecay, demand_alpha
				)
			{
				attribute<float32> t_ij                   := impedance >= 1e+38f ? 0.0f : distDecay == 0.0f ? 1.0f : max_elem(impedance, min_imp)^-distDecay;
				attribute<float32> M_ij                   := D_i[OrgZone_rel] <= 0.0f ? 0.0f : t_ij*D_i[OrgZone_rel]^(demand_alpha-1.0f);
				attribute<float32> M_i(connected/NodeSet) := sum(M_ij, OrgZone_rel);
				attribute<float32> M_j(connected/NodeSet) := sum(M_ij, DstZone_rel);
				
			}
			unit<uint64> dijkstra_all_route_count := 
				dijkstra_m64(
					'bidirectional;'
					'interaction(v_i,w_j,dist_decay,OrgZone_alpha):D_i,M_ix,C_j,M_xj,Link_flow',
					connected/LinkSet/dist, connected/F1, connected/F2,
					1.0f, 1.0f, 0.0f, 1.0f
				);
			unit<uint64> dijkstra_all_length := 
				dijkstra_m64(
					'bidirectional;'
					'interaction(v_i,w_j,dist_decay,OrgZone_alpha):D_i,M_ix,C_j,M_xj,Link_flow;od:impedance',
					connected/LinkSet/dist, connected/F1, connected/F2,
					1.0f, 1.0f, -1.0f, 1.0f
				);
			unit<uint64> dijkstra_all_link_count:= 
				dijkstra_m64(
					'bidirectional;'
					'alternative(link_imp):alt_imp;'
					'interaction(v_i,w_j,dist_decay,OrgZone_alpha):D_i,M_ix,C_j,M_xj,Link_flow;od:impedance',
					connected/LinkSet/dist, connected/F1, connected/F2,
					1.0f,
					1.0f, 1.0f, -1.0f, 1.0f
				);
			container avg_length_all
			{
				attribute<float32> per_org (connected/NodeSet) := dijkstra_all_length/M_ix / dijkstra_all_route_count/M_ix;
				attribute<float32> per_dst (connected/NodeSet) := dijkstra_all_length/M_xj / dijkstra_all_route_count/M_xj;
				attribute<float32> per_link(connected/LinkSet) := dijkstra_all_length/Link_flow / dijkstra_all_route_count/Link_flow;
			}
			container avg_link_count_all
			{
				attribute<float32> per_org (connected/NodeSet) := dijkstra_all_link_count/M_ix / dijkstra_all_route_count/M_ix;
				attribute<float32> per_dst (connected/NodeSet) := dijkstra_all_link_count/M_xj / dijkstra_all_route_count/M_xj;
				attribute<float32> per_link(connected/LinkSet) := dijkstra_all_link_count/Link_flow / dijkstra_all_route_count/Link_flow;
				parameter<bool> test_attr := #connected/LinkSet == 0 ? True : float_isNearby(sum(per_link), 107.17314f, Dif_all_float32);
			}

			unit<uint64> dijkstra_cut_route_count := 
				dijkstra_m64(
					'bidirectional;'
					'cut(OrgZone_max_imp);'
					'interaction(v_i,w_j,dist_decay,OrgZone_alpha):D_i,M_ix,C_j,M_xj,Link_flow',
					connected/LinkSet/dist, connected/F1, connected/F2,
					2500f,
					1.0f, 1.0f, 0.0f, 1.0f
				);
			unit<uint64> dijkstra_cut_length := 
				dijkstra_m64(
					'bidirectional;'
					'cut(OrgZone_max_imp);'
					'interaction(v_i,w_j,dist_decay,OrgZone_alpha):D_i,M_ix,C_j,M_xj,Link_flow',
					connected/LinkSet/dist, connected/F1, connected/F2,
					2500f,
					1.0f, 1.0f, -1.0f, 1.0f
				);
			unit<uint64> dijkstra_cut_link_count:= 
				dijkstra_m64(
					'bidirectional;'
					'cut(OrgZone_max_imp);'
					'alternative(link_imp):alt_imp;'
					'interaction(v_i,w_j,dist_decay,OrgZone_alpha):D_i,M_ix,C_j,M_xj,Link_flow;'
					'od:impedance',
					connected/LinkSet/dist, connected/F1, connected/F2,
					2500f,
					1.0f,
					1.0f, 1.0f, -1.0f, 1.0f
				);
			container avg_length_cut
			{
				attribute<float32> per_org (connected/NodeSet) := dijkstra_cut_length/M_ix / dijkstra_cut_route_count/M_ix;
				attribute<float32> per_dst (connected/NodeSet) := dijkstra_cut_length/M_xj / dijkstra_cut_route_count/M_xj;
				attribute<float32> per_link(connected/LinkSet) := dijkstra_cut_length/Link_flow / dijkstra_cut_route_count/Link_flow;
			}
			container avg_link_count_cut
			{
				attribute<float32> per_org (connected/NodeSet) := dijkstra_cut_link_count/M_ix / dijkstra_cut_route_count/M_ix;
				attribute<float32> per_dst (connected/NodeSet) := dijkstra_cut_link_count/M_xj / dijkstra_cut_route_count/M_xj;
				attribute<float32> per_link(connected/LinkSet) := dijkstra_cut_link_count/Link_flow / dijkstra_cut_route_count/Link_flow;
			}
			
			unit<uint32> dijkstra_OD :=
			// 	dijkstra_od(
				dijkstra_m('bidirectional;startPoint(Node_rel,impedance,OrgZone_rel);endPoint(Node_rel,impedance,DstZone_rel);od:impedance',
					connected/LinkSet/dist,       connected/F1                   , connected/F2,
					connected/nr_OriginNode,      const(0, source/origin,      m), ID(source/origin),
					connected/nr_DestinationNode, const(0, source/destination, m), ID(source/destination)
				)
			,	url  = "http://www.objectvision.nl/geodms/operators-a-functions/network/dijkstra-od"
			{
				attribute<m> att_ok_with_values:
				[
					 0   ,null   ,3037.1,null
					,null,1962.96,null  ,2918.18     
					,2325.58     ,null  ,824.535     ,null
					,null,4349.73,null  ,928.425     
					,null,1192.06,null  ,3712.05
				];
				attribute<m>     att_ok_without_values : [];
				attribute<m>     att_ok                := = #ODomain == 0 ? 'att_ok_without_values' : 'att_ok_with_values';

				attribute <bool> test      := float_isNearby(Impedance, att_ok, Dif_all_float32);
				parameter <bool> test_attr := all(test);
			}
			unit<uint32> dijkstra_OD_directed
			:	url  = "http://www.objectvision.nl/geodms/operators-a-functions/network/dijkstra-od"
			,=
				//	dijkstra_od_directed(
					dijkstra_m('directed;startPoint(Node_rel,impedance,OrgZone_rel);endPoint(Node_rel,impedance,DstZone_rel);od:impedance',
						connected/LinkSet/dist,       connected/F1                   , connected/F2, 
						connected/nr_OriginNode,      const(0, source/origin,      m), ID(source/origin),
						connected/nr_DestinationNode, const(0, source/destination, m), ID(source/destination)
					)
			{
				attribute<m> att_with_values:
				[
					 0           ,null,3037.1      ,null,null,null,null
					,2918.18     ,null,null,824.535     ,null,null,null
					,null,null,null,null,null,3712.05
				];
				attribute<m> att_ok_without_values : [];
				
				// WARNING: this code triggers dijkstra execution when the calculation rule for att_ok is determined; in production code, better provide the att as template parameter
				attribute<m> att_ok := = #. = 0 ? 'att_ok_without_values' : 'att_with_values'; 
				
				attribute <bool> test      := float_isNearby(Impedance, att_ok, Dif_all_float32);
				parameter <bool> test_attr := all(test);
			}
			unit<uint32> dijkstra_OD_maxdist
			:	url  = "http://www.objectvision.nl/geodms/operators-a-functions/network/dijkstra-od"
			,=
//					dijkstra_OD_maxdist(
					dijkstra_m('bidirectional;startPoint(Node_rel,impedance,OrgZone_rel);endPoint(Node_rel,impedance,DstZone_rel);cut(OrgZone_max_imp);od:impedance,OrgZone_rel,DstZone_rel',
						connected/LinkSet/dist,       connected/F1                   , connected/F2, 
						connected/nr_OriginNode,      const(0, source/origin,      m), ID(source/origin),
						connected/nr_DestinationNode, const(0, source/destination, m), ID(source/destination),
						const(2500,source/origin,m)
					)
			{
				container with_values
				{
					attribute<m>        imp_ok  (..): [0,1962.96,824.535,2325.58,928.425,1192.06];
					attribute<ODomain>  src_ok  (..): [0,1,2,2,3,4];
					attribute<DDomain > dest_ok (..): [0,1,2,0,3,1];
				}

				container without_values
				{
					attribute<m>      ok        (..): [];
					attribute<uint32> ok_uint32 (..): [];
				}

				attribute<bool> test := = #. == 0
					   ? 'float_isNearby(Impedance, without_values/ok  ,  Dif_all_float32) && OrgZone_rel == without_values/ok_uint32  && DstZone_rel == without_values/ok_uint32'
					   : 'float_isNearby(Impedance, with_values/imp_ok ,  Dif_all_float32) && OrgZone_rel == with_values/src_ok && DstZone_rel == with_values/dest_ok'
					   ;

				parameter<bool> test_attr := all(test);
			}
			unit<uint32> dijkstra_OD_maxdist_directed
			:	url  = "http://www.objectvision.nl/geodms/operators-a-functions/network/dijkstra-od"
			,=
//					dijkstra_OD_maxdist_directed(
					dijkstra_m('directed;startPoint(Node_rel,impedance,OrgZone_rel);endPoint(Node_rel,impedance,DstZone_rel);cut(OrgZone_max_imp);od:impedance,OrgZone_rel,DstZone_rel',
						connected/LinkSet/dist,       connected/F1                   , connected/F2, 
						connected/nr_OriginNode,      const(0, source/origin,      m), ID(source/origin),
						connected/nr_DestinationNode, const(0, source/destination, m), ID(source/destination),
						const(5000,source/origin,m)
					)
			{
				container with_values
				{
					attribute<m>       imp_ok  (..): [0,3037.1,2918.18,824.535,3712.05];
					attribute<ODomain> src_ok  (..): [0,0,1,2,4];
					attribute<DDomain> dest_ok (..): [0,2,3,2,3];
				}

				container without_values
				{
					attribute<m>      ok        (..): [];
					attribute<uint32> ok_uint32 (..): [];
				}

				attribute<bool> test := = #. == 0
					   ? 'float_isNearby(Impedance, without_values/ok  ,  Dif_all_float32) && OrgZone_rel == without_values/ok_uint32  && DstZone_rel == without_values/ok_uint32'
					   : 'float_isNearby(Impedance, with_values/imp_ok ,  Dif_all_float32) && OrgZone_rel == with_values/src_ok && DstZone_rel == with_values/dest_ok'
					   ;
				parameter<bool> test_attr := all(test);
			}

			unit<uint32> dijkstra_OD_maxtime_alt_imp :=
				dijkstra_m('bidirectional;startPoint(Node_rel);endPoint(Node_rel);cut(OrgZone_max_imp);alternative(link_imp):alt_imp;od:impedance,OrgZone_rel,DstZone_rel'
					, connected/LinkSet/dist * 1[s / m]
					, connected/F1
					, connected/F2
					, connected/nr_OriginNode
					, connected/nr_DestinationNode
					, 1000[s]
					, connected/LinkSet/dist
				)
			{
//				attribute<float32> impedance; // issue 941
				attribute<int32>   impedance_min := round(impedance / 60f);
				attribute<float32> alt_imp_km    := float32(round(alt_imp / 100f)) / 10f;

				attribute<s>       imp_ok        : [0, 824.535, 928.425];
				attribute<m>       alt_imp_ok    : [0, 824.535, 928.425];

				attribute<s>       imp_no_values_ok  : [];
				attribute<m>       alt_imp_no_values_ok  : [];

				attribute<bool>    test          :=  = #. == 0
					? 'float_isNearby(impedance, imp_no_values_ok , Dif_all_float32) && float_isNearby(alt_imp  , alt_imp_no_values_ok,  Dif_all_float32)'
					: 'float_isNearby(impedance, imp_ok , Dif_all_float32) && float_isNearby(alt_imp  , alt_imp_ok,  Dif_all_float32)'
					;
				parameter<bool> test_attr := all(test);
			}

			container traceback
			:	url   = "http://www.objectvision.nl/geodms/operators-a-functions/network/trace_back"
			,	Using = "connected"
			{
				unit<uint32> nr_won;
				attribute<nr_won> att (LinkSet):
					cdf  = "classifications/nr_wonflow_6K/Classes",
					 = value(
						trace_back(
							 F1
							,F2
							,dijkstra/distance_nodeset/TraceBack
							,pcount(nr_OriginNode)
						)
					, nr_won);
				attribute<nr_won> att_ok_with_values    (Linkset) : [0,2,0,0,0,0,0,0,2,1,1,0,0,0,1,0,1,2,0,1,0,1,1,1,1,0,0,0];
				attribute<nr_won> att_ok_without_values (Linkset) : [];
				attribute<nr_won> att_ok                (Linkset) := = #(Linkset) == 0 ? 'att_ok_without_values' : 'att_ok_with_values';

				attribute<bool>   test   (Linkset) := att_ok == att;
				parameter<bool>   test_attr        := all(test);
			}
			container service_area
			:	url   = "http://www.objectvision.nl/geodms/operators-a-functions/network/service_area"
			,	Using = "connected"
			{
				attribute<DDomain> nodeset (connected/NodeSet) := 
					rlookup(
						service_area(
							F1, 
							F2, 
							dijkstra/distance_nodeset/TraceBack
						),
						nr_DestinationNode
					);
				attribute<DDomain> att                   (ODomain) := lookup(nr_OriginNode, nodeset);
				attribute<DDomain> att_ok_with_values    (ODomain) : [0,1,2,3,1];
				attribute<DDomain> att_ok_without_values (ODomain) : [];
				attribute<DDomain> att_ok                (ODomain) := = #(ODomain) == 0 ? 'att_ok_without_values' : 'att_ok_with_values';
				attribute<bool>    test                  (ODomain) := att_ok == att;
				parameter<bool>    test_attr              := all(test);
			}
			container results
			{
				parameter<bool> tests := 
					   first_node/test_attr 
					&& last_node/test_attr 
					&& arc2segm/test_attr
					&& connect/test_attr
					&& connect_null_values/test_attr
					&& connect_arc_length_zero/connected/test
					&& connect_eq/test_attr
					&& connect_ne/test_attr
					&& connected_info/test_attr
					&& connected_info_eq/test_attr
					&& connected_info_ne/test_attr
					&& connected/parts/test_attr
					&& connect_points/test_attr 
					&& capacitated_connect/test_attr 
					//&& connect_neighbour/test_attr 
					&& connect_points/test_pointdomain_attr 
					&& UnTiled/connect_neighbour/test_attr  // Dit moet nog aangepast worden, nu wordt alleen Untiled gecontroleerd
					&& dijkstra/test_attr
					&& dijkstra_interaction/test_attr
					&& dijkstra_directed/test_attr
					&& dijkstra_maxdist/test_attr
					&& dijkstra_od/test_attr
					&& dijkstra_od_directed/test_attr
					&& dijkstra_od_maxdist/test_attr
					&& dijkstra_od_maxdist_directed/test_attr
					&& dijkstra_od_maxtime_alt_imp/test_attr
					&& avg_link_count_all/test_attr
					&& traceback/test_attr
					&& service_area/test_attr;
			}
		}
	}
	container Grid
	{
		container units
		{
			unit<fpoint> Coords;
			unit<spoint> GridDomain := 
				range(
					gridset(
						  Coords
						, point(float32(-5000.0), float32(5000)  , Coords)
						, point(float32(24900.0), float32(-100.0), Coords)
						, SPoint
					)
					, point(int16(0), int16(0))
					, point(int16(5), int16(5))
				),
				DialogType = "Map"
			{
				attribute<Coords>   P          := value((fpoint(id(.)) + point(float32(0.5), float32(0.5))) * fpoint(GetProjectionFactor(.)) + fpoint(GetProjectionOffset(.)), Coords);
				attribute<PointSet> PointSetNr := rlookup(P, PointSet/P);

				unit<uint32> PointSet := Subset(isDefined(GridDomain/P))
				,	DialogType = "Map"
				,	DialogData = "P"
				{
					attribute<Coords>                  P                := GridDomain/P[nr_OrgEntity];
					attribute<GridDomain3000/Pointset> GridDomain3000nr := connect(GridDomain3000/Pointset/P,P);
				}
				attribute<GridDomain3000/PointSet> GridDomain3000PointSetnr := PointSet/GridDomain3000nr[GridDomain/PointSetNr];
				attribute<GridDomain3000>          GridDomain3000nr         := rlookup(GridDomain3000PointSetnr, GridDomain3000/PointSetNr);
			}

			unit<spoint> GridTiledDomain := TiledUnit(Point(Int16(2), Int16(2), GridDomain));

			unit<spoint> EGridDomain := 
				range(
					gridset(
						  Coords
						, point(float32(-5000.0), float32(5000)  , Coords)
						, point(float32(24900.0), float32(-100.0), Coords)
						, SPoint
					)
					, point(int16(0), int16(0))
					, point(int16(0), int16(0))
				),
				DialogType = "Map"
			{
				attribute<Coords>   P          := value((fpoint(id(.)) + point(float32(0.5), float32(0.5))) * fpoint(GetProjectionFactor(.)) + fpoint(GetProjectionOffset(.)), Coords);
				attribute<PointSet> PointSetNr := rlookup(P, PointSet/P);

				unit<uint32> PointSet := Subset(isDefined(GridDomain/P))
				,	DialogType = "Map"
				,	DialogData = "P"
				{
					attribute<Coords>                  P                := GridDomain/P[nr_OrgEntity];
					attribute<GridDomain3000/Pointset> GridDomain3000nr := connect(GridDomain3000/Pointset/P,P);
				}
				//attribute<GridDomain3000/PointSet> GridDomain3000PointSetnr := PointSet/GridDomain3000nr[GridDomain/PointSetNr];
				//attribute<GridDomain3000>          GridDomain3000nr         := rlookup(GridDomain3000PointSetnr, GridDomain3000/PointSetNr);
			}
			unit<spoint> EGridTiledDomain := TiledUnit(Point(Int16(0), Int16(0), EGridDomain));
	
			unit<spoint> GridDomain3000 := 
				range(
					gridset(
						  Coords
						, point(float32(-3000.0), float32(3000)  , Coords)
						, point(float32(24000.0), float32(-500.0), Coords)
						, SPoint
					)
					, point(int16(0), int16(0))
					, point(int16(8), int16(8))
				),
				DialogType = "Map"
			{
				attribute<Coords> P  := value((fpoint(id(.)) + point(float32(0.5), float32(0.5))) * fpoint(GetProjectionFactor(.)) + fpoint(GetProjectionOffset(.)), Coords);
				attribute<Coords> P0 := value(fpoint(id(.))  * fpoint(GetProjectionFactor(.)) + fpoint(GetProjectionOffset(.)), Coords);
				attribute<Coords> P2 := convert(id(.), coords);
				attribute<FPoint> P3 := FPoint(id(.));
				attribute<Coords> P4 := convert(P3, coords);
				attribute<SPoint> P5 := spoint(P3);
				attribute<PointSet> PointSetNr := rlookup(P, PointSet/P);

				unit<uint32> PointSet := Subset(isDefined(GridDomain3000/P))
				,	DialogType = "Map"
				,	DialogData = "P"
				{
					attribute<Coords> P := GridDomain3000/P[nr_OrgEntity];
				}
				attribute<bool> T1 := P0 == P2;
				attribute<bool> T4 := P0 == P4;
				attribute<bool> T5 := P5[GridDomain3000] == id(.);
			}
			unit<spoint> GridDomain15 := 
				range(
					gridset(
						  Coords
						, point(float32(-15.0), float32(15)  , Coords)
						, point(float32(24000.0), float32(-500.0), Coords)
						, SPoint
					)
					, point(int16(0), int16(0))
					, point(int16(1600), int16(1600))
				),
				DialogType = "Map"
			{
				attribute<uint32> test:= const(1,.);
			}

			unit<uint32>  Dist2Range;
			unit<float32> Potentiaal;
			unit<spoint>  pot3Range: Range = "[{-1, -1}, {2, 2}) "
			{
				attribute<Dist2Range> distMatr3 (pot3Range) := dist2(point(int16(0), int16(0), pot3Range), Dist2Range);
				attribute<Potentiaal> AbsWeight (pot3Range) := float32(1.0) / float32(distMatr3 + 2);
				attribute<Potentiaal> RelWeight (pot3Range) := scalesum(AbsWeight, float32( 1.0) );
			}
			unit<uint8> OverlayRegios: nrofrows = 2
			{
				attribute<string> namen: ['NoordZuid', 'OostWest'];
			}
			container Results
			{
				parameter<bool> Tests := all(GridDomain3000/T1) && all( GridDomain3000/T4) && all(GridDomain3000/T5);
			}
		}
		unit<uint8> raster_merge_codes;

		container srcDomain       :=  source(units/GridDomain);
		container srcTiledDomain  :=  source(units/GridTiledDomain);
		container srcEDomain      := Esource(units/EGridDomain);
		container srcETiledDomain := Esource(units/EGridTiledDomain);
		
		container UnTiled  := Template(false, units/GridDomain,       srcDomain);
		container Tiled    := Template(false, units/GridTiledDomain,  srcTiledDomain);
		container ETiled   := Template(true,  units/EGridDomain,      srcEDomain);
		container EUnTiled := Template(true,  units/EGridTiledDomain, srcETiledDomain);

		template source
		{
			// begin case parameters
			unit<spoint> GridDomain;
			// end case parameters
			
			attribute<uint8> src (GridDomain):
			[
				null,0,0,0,1,
				   0,0,2,1,1,
				   0,2,3,3,3,
				   1,1,1,3,0,
				   0,1,0,1,3
			];
			attribute<uint32> districtOk (GridDomain):
			[
				null,0,0,0, 1,
				   0,0,2,1, 1,
				   0,3,4,4, 4,
				   5,5,5,4, 6,
				   7,5,8,9,10
			];
			attribute<uint32> districtBoolOk (GridDomain):
			[
				0,0,0,0,1,
				0,0,0,1,1,
				0,0,0,0,0,
				2,2,2,0,0,
				3,2,4,5,0
			];
			attribute<uint32> district_8_Ok (GridDomain):
			[
				null,0,0,0,1,
				   0,0,2,1,1,
				   0,2,3,3,3,
				   4,4,4,3,5,
				   6,4,7,4,3
			];
			attribute<uint32> districtBool_8_Ok (GridDomain):
			[
				0,0,0,0,1,
				0,0,0,1,1,
				0,0,0,0,0,
				2,2,2,0,0,
				3,2,0,2,0
			];
			attribute<uint8> diversityOk (GridDomain):
			[
				1,2,4,4,3,
				3,4,4,4,4,
				4,4,4,4,3,
				3,4,4,3,3,
				2,3,3,3,3
			];
			attribute<float32> potentialOk (GridDomain):
			[
				0       ,0.176471,0.323529,0.5     ,0.382353,
				0.176471,0.735294,1.26471 ,1.5     ,1.02941,
				0.441176,1.17647 ,1.91176 ,2.05882 ,1.35294,
				0.558823,1.02941 ,1.61765 ,1.91176 ,1.41176,
				0.323529,0.470588,0.705882,0.970588,0.911765
			];
			attribute<float32> proximityOk (GridDomain):
			[
				0        ,0.176471,0.235294,0.176471,0.176471,
				0.176471,0.264706,0.352941,0.352941,0.352941,
				0.235294,0.352941,0.529412,0.529412,0.529412,
				0.176471,0.264706,0.352941,0.529412,0.352941,
				0.117647,0.176471,0.264706,0.352941,0.529412
			];
			attribute<float32> dist_paramOk (GridDomain):
			[
				2.41421,1.41421,1.20711 ,1       ,0,
				3.53553,2.20711,0.707107,0.707107,1,
				5.53553,3.53553,3.20711 ,1.20711 ,1.41421,
				9.03553,8.53553,4.03553 ,2.70711 ,2.91421,
				8.32843,6.32843,4.82843 ,4.20711 ,4.41421
			];
			attribute<float32> distOk (GridDomain):
			[
				1.70711,0.707107,0.5    ,0.5,0.707107,
				2.5    ,0       ,0      ,0  ,0.5,
				3.53553,2.82843 ,2.5    ,0.5,0.707107,
				4.94975,4       ,3.32843,2  ,1.5,
				2      ,0       ,1.5    ,1  ,0
			];
			attribute<raster_merge_codes> raster_mergeOk (GridDomain):
			[
				10,10,40,40,40,
				10,10,40,40,40,
				20,20,40,40,40,
				20,20,30,30,30,
				20,20,30,30,30
			];

			container OverlayGrids
			{
				attribute<uint8> NoordZuid (GridDomain):
				[
					0,0,0,0,0,
					0,0,0,0,0,
					1,1,1,1,1,
					1,1,1,1,1,
					1,1,1,1,1
				];
				attribute<uint8> OostWest (GridDomain):
				[
					0,0,0,1,1,
					0,0,0,1,1,
					0,0,0,1,1,
					0,0,0,1,1,
					0,0,0,1,1
				];
			}

			attribute<uint16> OverlayResult (GridDomain):
			[
				0,0,0,2,2,
				0,0,0,2,2,
				1,1,1,3,3,
				1,1,1,3,3,
				1,1,1,3,3
			];
		}
		template Esource
		{
			// begin case parameters
			unit<spoint> GridDomain;
			// end case parameters
			
			attribute<uint8> src (GridDomain):
			[
			];
			attribute<uint32> districtOk (GridDomain):
			[
			];
			attribute<uint32> districtBoolOk (GridDomain):
			[
			];
			attribute<uint32> district_8_Ok (GridDomain):
			[
			];
			attribute<uint32> districtBool_8_Ok (GridDomain):
			[
			];
			attribute<uint8> diversityOk (GridDomain):
			[
			];
			attribute<float32> potentialOk (GridDomain):
			[
			];
			attribute<float32> proximityOk (GridDomain):
			[
			];
			attribute<float32> dist_paramOk (GridDomain):
			[
			];
			attribute<float32> distOk (GridDomain):
			[
			];
			attribute<raster_merge_codes> raster_mergeOk (GridDomain):
			[
			];

			container OverlayGrids
			{
				attribute<uint8> NoordZuid (GridDomain):
				[

				];
				attribute<uint8> OostWest (GridDomain):
				[

				];
			}

			attribute<uint16> OverlayResult (GridDomain):
			[

			];
		}
		
		
		Template Template
		{
			// begin case parameters
			parameter<bool> isEmpty;
			unit<spoint> GridDomain;
			container source;
			// end case parameters

			container district: url  = "http://www.objectvision.nl/geodms/operators-a-functions/grid/district"
			{
				unit<uint32>    unit_district     := district(source/src);
				
				attribute<bool> test (GridDomain) := eq_or_both_null(unit_district/districts, source/districtOk);
				parameter<bool> test_gridUInt8    := all(test);
				
				unit<uint32>    unit_district1_Bool   := district(source/src == 1[uint8]); // district on boolean attribute implemented in revision 2920, GeoDMS version 6.060.
				attribute<bool> test_Bool(GridDomain) := unit_district1_Bool/districts == source/districtBoolOk;
				parameter<bool> test_gridBool         := all(test_Bool);
				parameter<bool> test_grid             := test_gridUInt8 && test_gridBool;
			}
			container district_8
			{
				unit<uint32>    unit_district_8   := district_8(source/src);
				
				attribute<bool> test (GridDomain) := eq_or_both_null(unit_district_8/districts, source/district_8_Ok);
				parameter<bool> test_gridUInt8    := all(test);
				
				unit<uint32>    unit_district1_Bool   := district_8(source/src == 1[uint8]); // district on boolean attribute implemented in revision 2920, GeoDMS version 6.060.
				attribute<bool> test_Bool(GridDomain) := unit_district1_Bool/districts == source/districtBool_8_Ok;
				parameter<bool> test_gridBool         := all(test_Bool);
				parameter<bool> test_grid             := test_gridUInt8 && test_gridBool;
			}
			container diversity: url = "http://www.objectvision.nl/geodms/operators-a-functions/grid/diversity"
			{
				attribute<uint8>  grid (GridDomain) := diversity(source/src, uint16(2), uint16(1));
				attribute<bool>   test (GridDomain) := grid = source/diversityOk;
				parameter<bool>   test_grid         := all(test);
			}
			container dist2: url = "http://www.objectvision.nl/geodms/operators-a-functions/grid/dist2"
			{
				attribute<grid/units/Dist2Range> dis  (grid/units/pot3Range) : [2,1,2,1,0,1,2,1,2];
				attribute<grid/units/Dist2Range> att  (grid/units/pot3Range) := dist2(point(int16(0), int16(0), grid/units/pot3Range), grid/units/Dist2Range);
				attribute<bool>                  test (grid/units/pot3Range) := dis = att;
				parameter<bool>                  test_grid                   := all(test);
			}
			container perimeter
			{
				attribute<uint32> att  (District/unit_district) := perimeter(District/unit_district/Districts);
			}
			container potential: url = "http://www.objectvision.nl/geodms/operators-a-functions/grid/potential"
			{
				attribute<float32> grid (GridDomain) := potential(float32(source/src), units/pot3Range/RelWeight);
				attribute<bool>    test (GridDomain) := float_isNearby(grid, source/potentialOk, Dif_all_float32) ;
				parameter<bool>    test_grid         := all(test);
			}
			container proximity: url = "http://www.objectvision.nl/geodms/operators-a-functions/grid/proximity"
			{
				attribute<float32> grid (GridDomain) := proximity(float32(source/src), units/pot3Range/RelWeight);
				attribute<bool>    test (GridDomain) := float_isNearby(grid, source/proximityOk, Dif_all_float32) ;
				parameter<bool>    test_grid         := all(test);
			}
			container griddist_param : url  = "http://www.objectvision.nl/geodms/operators-a-functions/grid/griddist"
			{
				attribute<float64> gridWithValues (GridDomain): [
					1, 1, 1, 1, 1,
					2, 3, 0, 0, 1,
					2, 4, 5, 1, 1,
					5, 6, 3, 2, 2,
					2, 2, 1, 1, 1
				];
				attribute<float64> gridEmpty (GridDomain): [];
				attribute<float64> grid      (GridDomain):= = isEmpty ? 'gridEmpty' : 'gridWithValues';

				parameter<GridDomain> pointset_gridid   := point(Int16(0), Int16(4), GridDomain);
				attribute<float64>    dist (GridDomain) := griddist(grid, pointset_gridid, 0.0);
				attribute<bool>       test (GridDomain) := float_isNearby(float32(dist), source/dist_paramOk, Dif_all_float32) ;
				parameter<bool>       test_grid         := all(test); // Referentie DMS 5.81
			}
			container griddist: url  = "http://www.objectvision.nl/geodms/operators-a-functions/grid/griddist"
			{
				attribute<float64> gridWithValues (GridDomain): 
				[
					1, 1, 1, 1, 1,
					2, 3, 0, 0, 1,
					2, 4, 5, 1, 1,
					5, 6, 3, 2, 2,
					2, 2, 1, 1, 1
				];
				attribute<float64> gridEmpty (GridDomain): [];
				attribute<float64> grid      (GridDomain):= = isEmpty ? 'gridEmpty' : 'gridWithValues';
				
				attribute<GridDomain> pointset_gridid   (point/UnTiled2UnTiled/source/destination): [{1,1},{1,3},{4,1},{4,4}];
	
				attribute<float64>    dist0      (GridDomain) := griddist(const(0.0, GridDomain), pointset_gridid, const(0.0, point/UnTiled2UnTiled/source/destination));
				attribute<float64>    dist       (GridDomain) := griddist(grid, pointset_gridid, const(0.0, point/UnTiled2UnTiled/source/destination));
				attribute<bool>       test0      (GridDomain) := dist0 == 0.0 ;
				attribute<bool>       test       (GridDomain) := float_isNearby(float32(dist), source/distOk, Dif_all_float32) ;
				parameter<bool>       test_grid               := all(test0 && test); // Referentie DMS 5.81
			}
			unit<uint16> overlay := overlay(units/OverlayRegios/namen, GridDomain, source/OverlayGrids),
				url       = "http://www.objectvision.nl/geodms/operators-a-functions/overlay",
				StoreData = "True"
			{
				attribute<bool>  test            (GridDomain) := eq_or_both_null(union_data_copy, source/OverlayResult);
				attribute<.>     union_data_copy (GridDomain) := UnionData;
				parameter<bool>  test_attr                    := all(test);
			}
			unit<uint32> overlay32 := overlay32(units/OverlayRegios/namen, GridDomain, source/OverlayGrids),
				url       = "http://www.objectvision.nl/geodms/operators-a-functions/overlay",
				StoreData = "True"
			{
				attribute<bool> test            (GridDomain) := eq_or_both_null(union_data_copy, uint32(source/OverlayResult));
				attribute<.>    union_data_copy (GridDomain) := UnionData;
				parameter<bool> test_attr                    := all(test);
			}
			container raster_merge
			{
				attribute<uint16> indexmap(GridDomain) := 
					convert(
						switch(
							  case(pointRow(id(GridDomain)) <  int16(2) && pointCol(id(GridDomain)) <  int16(2), 0) 
							, case(pointRow(id(GridDomain)) >= int16(2) && pointCol(id(GridDomain)) <  int16(2), 1) 
							, case(pointRow(id(GridDomain)) >= int16(3) && pointCol(id(GridDomain)) >= int16(2), 2) 
						, 3)
					, uint16);

				container SubGrids
				{
					unit<spoint> GridDomainA := range(GridDomain, point(int16(0),int16(0)),point(int16(2),int16(2)));
					unit<spoint> GridDomainB := range(GridDomain, point(int16(2),int16(0)),point(int16(5),int16(2)));
					unit<spoint> GridDomainC := range(GridDomain, point(int16(3),int16(2)),point(int16(5),int16(5)));
					unit<spoint> GridDomainD := range(GridDomain, point(int16(0),int16(2)),point(int16(3),int16(5)));
				}

				attribute<raster_merge_codes> ToBeMergedI   (SubGrids/GridDomainA) := const(10, SubGrids/GridDomainA, raster_merge_codes);
				attribute<raster_merge_codes> ToBeMergedII  (SubGrids/GridDomainB) := const(20, SubGrids/GridDomainB, raster_merge_codes);
				attribute<raster_merge_codes> ToBeMergedIII (SubGrids/GridDomainC) := const(30, SubGrids/GridDomainC, raster_merge_codes);
				attribute<raster_merge_codes> ToBeMergedIV  (SubGrids/GridDomainD) := const(40, SubGrids/GridDomainD, raster_merge_codes);

				attribute<raster_merge_codes> att (GridDomain) := 
					raster_merge(
						 indexmap
						,raster_merge_codes
						,ToBeMergedI
						,ToBeMergedII
						,ToBeMergedIII
						,ToBeMergedIV
					);
// 				attribute<codes> att_with_parameter_args (GridDomain) := 
// 					raster_merge(
// 						 indexmap
// 						,codes
// 						,10[codes]
// 						,20[codes]
// 						,30[codes]
// 						,40[codes]
// 					);
				attribute<raster_merge_codes> att_without_indexmap (GridDomain) := 
					raster_merge(
						 GridDomain
						,raster_merge_codes
						,ToBeMergedI
						,ToBeMergedII
						,ToBeMergedIII
						,ToBeMergedIV
					);
				attribute<bool>  test                  (GridDomain) := att == source/raster_mergeOk;
				attribute<bool>  test_without_indexmap (GridDomain) := att_without_indexmap == source/raster_mergeOk;

				parameter<bool>  test_grid := all(test) && all(test_without_indexmap);
			}

			

			container results
			{
				parameter<bool> tests := 
					   district/test_grid
					&& district_8/test_grid
					&& diversity/test_grid 
					&& dist2/test_grid
					&& potential/test_grid 
					&& proximity/test_grid 
					&& griddist_param/test_grid 
					&& griddist/test_grid 
					&& overlay/test_attr
					&& overlay32/test_attr
					&& raster_merge/test_grid;
			}
		}
		container potential_with_tiles: url = "http://www.objectvision.nl/geodms/operators-a-functions/grid/potential"
		{
			unit<float32> m;
			unit<float32> coord_rd := m;
			unit<fpoint>  point_rd_wms:
				Format     = "EPSG:28992";
			unit<fpoint>  point_rd    := range(point_rd_wms, point(0f,250000f), point(350000f,650000f)); 
		
			parameter<m> gridsize := 5[m];
		
			parameter<m> minX  :=  99454[m];
			parameter<m> maxX  := 107270[m];
			parameter<m> minY  := 391989[m];
			parameter<m> maxY  := 405650[m];
		
			parameter<point_rd> TopLeftCoord :=  point(maxY, minX, point_rd);
		
			parameter<int16> nrofrows := int16((maxY - minY) / gridsize);
			parameter<int16> nrofcols := int16((maxX - minX) / gridsize);

			unit<spoint> gridset_tmp := gridset(point_rd_wms, point(-gridsize, gridsize, point_rd), TopLeftCoord, spoint);			
			
			unit<spoint> m5grid_src := range(gridset_tmp, point(int16(0), int16(0)), point(nrofrows, nrofcols))
			{
				attribute<uint32> att := const(1,.);
			}
		
			unit<spoint> m5grid := TiledUnit(point(1024s, 1024s, m5grid_src))
			{
				attribute<uint32> att := const(1,.);
			}
		
			unit<spoint> isWeg_grid_NATIVE: StorageName = "%projDir%/data/weg.tif"
//			,	StorageType = "gdal.grid" 
			,	DialogData  = "point_rd" 
			{
				attribute<uint8> GridData;
				attribute<uint8> ReadData (m5grid);
			}
			unit<spoint> isWeg_grid: StorageName = "%projDir%/data/weg.tif"
			,	StorageType = "gdal.grid" 
			,	DialogData  = "point_rd" 
			{
				attribute<uint8> GridData;
				attribute<uint8> ReadData (m5grid);
			}
			
			unit<spoint> kernel_5_5_cells := range(spoint, point(-2s, -2s), point(3s, 3s))
			{
				attribute<uint32>  distMatr    := dist2(point(0s, 0s, .), uint32);
				attribute<float32> absWeight   := distMatr < 5 ? 1f : 0f;
				attribute<float32> relWeight   := absWeight / sum(absWeight);
			}
			attribute<float32> isWegpot (m5grid):= potential(float32(isWeg_grid/ReadData), kernel_5_5_cells/absWeight);

			unit<spoint> isWeg_grid_reference: StorageName = "%projDir%/data/isWegpot.tif"
			,	StorageType = "gdal.grid" 
			,	DialogData  = "point_rd" 
			{
				attribute<float32> GridData;
				attribute<float32> ReadData (m5grid);
			}

			attribute<bool>  test (m5grid) := isWegpot == isWeg_grid_reference/ReadData;
			parameter<bool>  test_attr     := all(test);
		}
	}
	container matrix
	{
		unit<fpoint> Coords;
		unit<spoint> GridDomain :=
			range(
				gridset(
					  Coords
					, point(float32(-5000.0), float32(5000)  , Coords)
					, point(float32(24900.0), float32(-100.0), Coords)
					, SPoint
				)
				, point(int16(0), int16(0))
				, point(int16(2), int16(2))
			),
			DialogType = "Map"
		{
			container source
			{
				attribute<float32> left (GridDomain):
				[
					1,2,
					3,4
				];
				attribute<float32> right (GridDomain):
				[
					100,200,
					300,400
				];
				attribute<float32> mul_OK (GridDomain):
				[
					 700,1000,
					1500,2200
				];
				attribute<float32> inv_OK (GridDomain):
				[
					 -2,1,
					1.5,-0.5
				];
				attribute<float32> var_OK (GridDomain):
				[
					10,14,
					14,20
				];
			}
		}
		unit<spoint> EGridDomain :=
			range(
				gridset(
					  Coords
					, point(float32(-5000.0), float32(5000)  , Coords)
					, point(float32(24900.0), float32(-100.0), Coords)
					, SPoint
				)
				, point(int16(0), int16(0))
				, point(int16(0), int16(0))
			),
			DialogType = "Map"
		{
			container source
			{
				attribute<float32> left (EGridDomain):
				[
				];
				attribute<float32> right (EGridDomain):
				[
				];
				attribute<float32> mul_OK (EGridDomain):
				[
				];
				attribute<float32> inv_OK (EGridDomain):
				[
				];
				attribute<float32> var_OK (EGridDomain):
				[
				];
			}
		}
		unit<spoint> GridTiledDomain  := TiledUnit(Point(Int16(1), Int16(1), GridDomain))
		{
			container source
			{
				attribute<float32> left (GridTiledDomain):
				[
					1,2,
					3,4
				];
				attribute<float32> right (GridTiledDomain):
				[
					100,200,
					300,400
				];
				attribute<float32> mul_OK (GridTiledDomain):
				[
					 700,1000,
					1500,2200
				];
				attribute<float32> inv_OK (GridTiledDomain):
				[
					 -2,1,
					1.5,-0.5
				];
				attribute<float32> var_OK (GridTiledDomain):
				[
					10,14,
					14,20
				];
			}
		}

		unit<spoint> EGridTiledDomain := TiledUnit(Point(Int16(1), Int16(1), EGridDomain))
		{
			container source
			{
				attribute<float32> left (EGridTiledDomain):
				[
				];
				attribute<float32> right (EGridTiledDomain):
				[
				];
				attribute<float32> mul_OK (EGridTiledDomain):
				[
				];
				attribute<float32> inv_OK (EGridTiledDomain):
				[
				];
				attribute<float32> var_OK (EGridTiledDomain):
				[
				];
			}
		}
	
		container UnTiled  := Template(GridDomain);
		container Tiled    := Template(GridTiledDomain);
		container ETiled   := Template(EGridDomain);
		container EUnTiled := Template(EGridTiledDomain);

		Template Template
		{
			// begin case parameters
			unit<spoint> GridDomain;
			// end case parameters
			container matr_mul
			{
				attribute<float32> att       (GridDomain) := matr_mul(GridDomain/Source/left, GridDomain/Source/right, GridDomain);
				attribute<bool>    test      (GridDomain) := eq_or_both_null(att, GridDomain/source/mul_OK);
				parameter<bool>    test_attr              := all(test);
			}
			container matr_inv
			{
				attribute<float32> att       (GridDomain) := matr_inv(GridDomain/Source/left);
				attribute<bool>    test      (GridDomain) := float_isNearby(att, GridDomain/source/inv_OK, Dif_all_float32);
				parameter<bool>    test_attr              := all(test);
			}
			container matr_var
			{
				attribute<float32> att       (GridDomain) := matr_var(GridDomain/Source/left, GridDomain);
				attribute<bool>    test      (GridDomain) := eq_or_both_null(att, GridDomain/source/var_OK);
				parameter<bool>    test_attr              := all(test);
			}
			container results
			{
				parameter<bool> tests :=
					   matr_mul/test_attr
					&& matr_inv/test_attr
					&& matr_var/test_attr;
			}
		}
	}
	container String
	{
		unit<uint32> Steden_nrd: nrofrows = 9;
		unit<uint32> Prov_nrd  : nrofrows = 3;
		unit<uint32> Regions   : nrofrows = 4;

		unit<uint32> ESteden_nrd: nrofrows = 0;
		unit<uint32> EProv_nrd  : nrofrows = 0;
		unit<uint32> ERegions   : nrofrows = 0;

		container srcDomain        := Source(ADomain       ,Steden_nrd, Prov_nrd, Regions);
		container srcTiledDomain   := Source(ATiledDomain  ,Steden_nrd, Prov_nrd, Regions);
		container srcEDomain       := ESource(EDomain      ,ESteden_nrd, EProv_nrd, ERegions);
		container srcETiledDomain  := ESource(ETiledDomain ,ESteden_nrd, EProv_nrd, ERegions);

		template Source
		{
			// begin case parameters
			unit<uint32> Domain;
			unit<uint32> Steden;
			unit<uint32> Prov;
			unit<uint32> Reg;
			// end case parameters

			parameter<float32> ValueTostring  := float32(7.5);
			parameter<string>  TestToQuote    := 'MetQuotes'; 
			parameter<string>  teststring     := 'In een string past ook een zin';
			parameter<string>  TestTrimstring := ' string   met   spaties  ';

			attribute<string>  A                (Domain): ['Test','88hallo99','+)','twee woorden',' test met spatie'];
			attribute<string>  B                (Domain): ['Test2',null,'-' ,'drie woorden string','''woord'''];
			attribute<string>  C                (Domain): ['Test','test','88hallo99','Test met Text','Text met Test'];
			
			attribute<string>  repA             (Domain): ['0','1','2','3','4'];
			attribute<uint32>  repNr            (Domain): [0,1,2,3,4];
			attribute<uint32>  strlenA          (Domain): [4,9,2,12,16];
			attribute<uint64>  strlen64A        (Domain): [4,9,2,12,16];
			attribute<string>  substrA          (Domain): ['est','8ha',')','wee','tes'];
			attribute<string>  substr2A         (Domain): ['est','8hallo99',')','wee woorden','test met spatie'];
			attribute<string>  leftA            (Domain): ['Tes','88h','+)','twe',' te'];
			attribute<string>  rightA           (Domain): ['est','o99','+)','den','tie'];

			attribute<string>  quoteA           (Domain): ['''Test''','''88hallo99''','''+)''','''twee woorden''',''' test met spatie'''];
			attribute<string>  dquoteA          (Domain): ['"Test"','"88hallo99"','"+)"','"twee woorden"','" test met spatie"'];
			attribute<string>  unquoteB         (Domain): ['Test2','lege string','lege string','drie woorden string','woord'];
			attribute<string>  undquoteA        (Domain): ['Test','88hallo99','+)','twee woorden',' test met spatie'];
			attribute<string>  uppercaseA       (Domain): ['TEST','88HALLO99','+)','TWEE WOORDEN',' TEST MET SPATIE'];
			attribute<string>  lowercaseA       (Domain): ['test','88hallo99','+)','twee woorden',' test met spatie'];
			attribute<uint32>  strPosA          (Domain): [3,null,null,0,1]; 
			attribute<uint32>  strrPosA         (Domain): [3,null,null,0,13]; 

			attribute<uint32>  strCountA        (Domain): [1,0,0,1,4];
			attribute<string>  replaceC         (Domain): ['Taart','test' ,'88hallo99','Taart met Text','Text met Taart'];
			attribute<string>  replaceCMultiple (Domain): ['Taart','test' ,'88hallo99','Taart zonder Text','Text zonder Taart'];
			attribute<string>  replace_valueC   (Domain): ['taart','taart','88hallo99','Test met Text' ,'Text met Test'];

			attribute<string>  RepeatA          (Domain): [null,'1','22','333','4444'];
			attribute<string>  ConAB            (Domain): ['TestTest2',null,'+)-','twee woordendrie woorden string',' test met spatie''woord'''];
			attribute<string>  trimA            (Domain): ['Test','88hallo99','+)','twee woorden','test met spatie'];
			attribute<string>  sumProv          (Domain): ['GroningenLeeuwardenAssenZwolle','DelfzijlDokkumEmmenEnschede','HoogezandSneekBijlenAlmelo','AppingedamHeerenveenHoogeveenKampen','HarenFranekerMeppelHengelo'];
			attribute<string>  sortA_asc        (Domain): [' test met spatie','+)','88hallo99','Test','twee woorden'];
			attribute<string>  sortA_desc       (Domain): ['twee woorden','Test','88hallo99','+)',' test met spatie'];
			attribute<string>  Groningen        (Domain): ['Groningen','Delfzijl','Hoogezand','Appingedam','Haren'];
			attribute<string>  Friesland        (Domain): ['Leeuwarden','Dokkum','Sneek','Heerenveen','Franeker'];
			attribute<string>  Drenthe          (Domain): ['Assen','Emmen','Bijlen','Hoogeveen','Meppel'];
			attribute<string>  Overijssel       (Domain): ['Zwolle','Enschede','Almelo','Kampen','Hengelo'];

			container special_characters
			{
				parameter<string> A  := '';
				parameter<string> a_ := '';
				parameter<string> C  := '';
				parameter<string> c_ := '';
				parameter<string> E  := ''; 
				parameter<string> e_ := '';
				parameter<string> I  := '';
				parameter<string> i_ := '';
				parameter<string> N  := '';
				parameter<string> n_ := '';
				parameter<string> O  := '';
				parameter<string> o_ := '';
				parameter<string> U  := '';
				parameter<string> u_ := '';
				parameter<string> Y  := '';
				parameter<string> y_ := '';
			}

			unit<uint32> Steden_nrd := Steden
			{
				attribute <Prov> Provincie: [0,0,0,1,1,1,2,2,2];
				attribute <string>   Stad: ['Groningen','Delfzijl','Winschoten','Leeuwarden','Dokkum','Bolsward','Emmen','Assen','Hoogeveen'];
			}
			unit<uint32> Prov_nrd := Prov
			{
				attribute <Prov> Prov_nr: [0,1,2];
				attribute <string>   src_asList: ['Groningen;Delfzijl;Winschoten','Leeuwarden;Dokkum;Bolsward','Emmen;Assen;Hoogeveen'];
				attribute <string>   src_asexprList: ['''Groningen'';''Delfzijl'';''Winschoten''','''Leeuwarden'';''Dokkum'';''Bolsward''','''Emmen'';''Assen'';''Hoogeveen'''];
				attribute <string>   src_asItemList: ['Groningen,Delfzijl,Winschoten','Leeuwarden,Dokkum,Bolsward','Emmen,Assen,Hoogeveen'];
			}
			unit<uint32> Regions := Reg
			{
				attribute <string> regionnames: ['Groningen','Friesland','Drenthe','Overijssel'];
			}
			container stringOperator
			{
				parameter <bool> test_param := string(ValueTostring) = '7.5';
			}
		}
		template ESource
		{
			// begin case parameters
			unit<uint32> Domain;
			unit<uint32> Steden;
			unit<uint32> Prov;
			unit<uint32> Reg;
			// end case parameters

			parameter<float32> ValueTostring  := float32(7.5);
			parameter<string>  TestToQuote    := 'MetQuotes'; 
			parameter<string>  teststring     := 'In een string past ook een zin';
			parameter<string>  TestTrimstring := ' string   met   spaties  ';

			attribute<string>  A                (Domain): [];
			attribute<string>  B                (Domain): [];
			attribute<string>  C                (Domain): [];
			
			attribute<string>  repA             (Domain): [];
			attribute<uint32>  repNr            (Domain): [];
			attribute<uint32>  strlenA          (Domain): [];
			attribute<uint64>  strlen64A        (Domain): [];
			attribute<string>  substrA          (Domain): [];
			attribute<string>  substr2A         (Domain): [];
			attribute<string>  leftA            (Domain): [];
			attribute<string>  rightA           (Domain): [];

			attribute<string>  quoteA           (Domain): [];
			attribute<string>  dquoteA          (Domain): [];
			attribute<string>  unquoteB         (Domain): [];
			attribute<string>  undquoteA        (Domain): [];
			attribute<string>  uppercaseA       (Domain): [];
			attribute<string>  lowercaseA       (Domain): [];
			attribute<uint32>  strPosA          (Domain): []; 
			attribute<uint32>  strrPosA         (Domain): []; 

			attribute<uint32>  strCountA        (Domain): [];
			attribute<string>  replaceC         (Domain): [];
			attribute<string>  replaceCMultiple (Domain): [];
			attribute<string>  replace_valueC   (Domain): [];

			attribute<string>  RepeatA          (Domain): [];
			attribute<string>  ConAB            (Domain): [];
			attribute<string>  trimA            (Domain): [];
			attribute<string>  sumProv          (Domain): [];
			attribute<string>  sortA_asc        (Domain): [];
			attribute<string>  sortA_desc       (Domain): [];
			attribute<string>  Groningen        (Domain): [];
			attribute<string>  Friesland        (Domain): [];
			attribute<string>  Drenthe          (Domain): [];
			attribute<string>  Overijssel       (Domain): [];

			container special_characters
			{
				parameter<string> A  := '';
				parameter<string> a_ := '';
				parameter<string> C  := '';
				parameter<string> c_ := '';
				parameter<string> E  := ''; 
				parameter<string> e_ := '';
				parameter<string> I  := '';
				parameter<string> i_ := '';
				parameter<string> N  := '';
				parameter<string> n_ := '';
				parameter<string> O  := '';
				parameter<string> o_ := '';
				parameter<string> U  := '';
				parameter<string> u_ := '';
				parameter<string> Y  := '';
				parameter<string> y_ := '';
			}

			unit<uint32> Steden_nrd := Steden
			{
				attribute <Prov>   Provincie: [];
				attribute <string> Stad: [];
			}
			unit<uint32> Prov_nrd := Prov
			{
				attribute <Prov>   Prov_nr: [];
				attribute <string> src_asList: [];
				attribute <string> src_asexprList: [];
				attribute <string> src_asItemList: [];
			}
			unit<uint32> Regions := Reg
			{
				attribute <string> regionnames: [];
			}
			container stringOperator
			{
				parameter <bool> test_param := string(ValueTostring) = '7.5';
			}
		}

		container UnTiled  := Template(ADomain       ,Prov_nrd, srcDomain );
		container Tiled    := Template(ATiledDomain  ,Prov_nrd, srcTiledDomain );
		container EUnTiled := Template(EDomain      ,EProv_nrd, srcEDomain );
		container ETiled   := Template(ETiledDomain ,EProv_nrd, srcETiledDomain );

		Template Template
		{
			// begin case parameters
			unit<uint32> domain;
			unit<uint32> prov;
			container source;
			// end case parameters

			container concatenation: url = "http://www.objectvision.nl/geodms/operators-a-functions/string/concatenation"
			{
				parameter<bool>   test_param    := source/teststring + source/teststring = 'In een string past ook een zinIn een string past ook een zin';
				attribute<string> att  (Domain) := source/A + source/B;
				attribute<bool>   test (Domain) := eq_or_both_null(att, source/conAB);
				parameter<bool>   test_attr     := all(test);
			}
			container strlen: url = "http://www.objectvision.nl/geodms/operators-a-functions/string/strlen"
			{
				parameter<uint32> param         := strlen(source/teststring);
				parameter<bool>   test_param    := param = 30;
				attribute<uint32> att  (Domain) := strlen(source/A);
				attribute<bool>   test (Domain) := att = source/strlenA;
				parameter<bool>   test_attr     := all(test);
			}
			container strlen64
			{
				parameter<uint64> param         := strlen64(source/teststring);
				parameter<bool>   test_param    := param = 30u64;
				attribute<uint64> att  (Domain) := strlen64(source/A);
				attribute<bool>   test (Domain) := att = source/strlen64A;
				parameter<bool>   test_attr     := all(test);
			}
			container substr: url = "http://www.objectvision.nl/geodms/operators-a-functions/string/substr"
			{
				parameter<string> param         := substr(source/teststring, 7, 6);
				parameter<bool>   test_param    := param = 'string';
				attribute<string> att  (Domain) := substr(source/A, 1, 3);
				attribute<bool>   test (Domain) := att = source/substrA;
				parameter<bool>   test_attr     := all(test);
			}
			container left
			{
				parameter<string> param         := left(source/teststring, 6);
				parameter<bool>   test_param    := param = 'In een';
				attribute<string> att  (Domain) := left(source/A, 3);
				attribute<bool>   test (Domain) := att = source/leftA;
				parameter<bool>   test_attr     := all(test);
			}
			container right
			{
				parameter<string> param         := right(source/teststring, 16);
				parameter<bool>   test_param    := param = 'past ook een zin';
				attribute<string> att  (Domain) := right(source/A, 3);
				attribute<bool>   test (Domain) := att = source/rightA;
				parameter<bool>   test_attr     := all(test);
			}
			container substr2: url = "http://www.objectvision.nl/geodms/operators-a-functions/string/substr"
			{
				parameter<string> param         := substr(source/teststring, 7);
				parameter<bool>   test_param    := param = 'string past ook een zin';
				attribute<string> att  (Domain) := substr(source/A, 1);
				attribute<bool>   test (Domain) := att = source/substr2A;
				parameter<bool>   test_attr     := all(test);
			}

			container quote: url = "http://www.objectvision.nl/geodms/operators-a-functions/string/quote"
			{
				parameter<string> param         := quote(source/TestToQuote);
				parameter<bool>   test_param    := iif(strlen(param) = 11, true, false);
				attribute<string> att  (Domain) := quote(source/A);
				attribute<bool>   test (Domain) := att = source/quoteA;
				parameter<bool>   test_attr     := all(test);
			}
			container unquote: url = "http://www.objectvision.nl/geodms/operators-a-functions/string/unquote"
			{
				parameter<string> param         := unquote(quote/param);
				parameter<bool>   test_param    := param = source/TestToQuote;
				attribute<string> att  (Domain) := unquote(quote/att);
				attribute<bool>   test (Domain) := att = MakeDefined(source/A, 'lege string');
				parameter<bool>   test_attr     := all(test);
			}
			container dquote: url = "http://www.objectvision.nl/geodms/operators-a-functions/string/dquote"
			{
				parameter<string> param         := dquote(source/TestToQuote);
				parameter<bool>   test_param    := iif(strlen(param) = 11, true, false);
				attribute<string> att  (Domain) := dquote(source/A);
				attribute<bool>   test (Domain) := att = source/dquoteA;
				parameter<bool>   test_attr     := all(test);
			}
			container undquote: url = "http://www.objectvision.nl/geodms/operators-a-functions/string/undquote"
			{
				parameter<string> param         := undquote(dquote/param);
				parameter<bool>   test_param    := param = source/TestToQuote;
				attribute<string> att  (Domain) := undquote(dquote/att);
				attribute<bool>   test (Domain) := att = MakeDefined(source/A, 'lege string');
				parameter<bool>   test_attr     := all(test);
			}
			container UpperCase: url = "http://www.objectvision.nl/geodms/operators-a-functions/string/uppercase"
			{
				attribute<string> att  (Domain) := uppercase(source/A);
				attribute<bool>   test (Domain) := att = source/uppercaseA;
				parameter<bool>   test_attr     := all(test);
			}
			container LowerCase: url = "http://www.objectvision.nl/geodms/operators-a-functions/string/lowercase"
			{
				attribute<string> att  (Domain) := lowercase(source/A);
				attribute<bool>   test (Domain) := uppercase(att) = uppercase(source/uppercaseA);
				parameter<bool>   test_attr     := all(test);
			}
			container strpos: url = "http://www.objectvision.nl/geodms/operators-a-functions/string/strpos"
			{
				parameter<uint32> param         := strpos(source/teststring, 'p');
				parameter<bool>   test_param    := param = 14;
				attribute<uint32> att  (Domain) := strpos(source/A, 't');
				attribute<bool>   test (Domain) := eq_or_both_null(att, source/strPosA);
				parameter<bool>   test_attr     := all(test);
			}
			container strrpos
			{
				parameter<uint32> param         := strrpos(source/teststring, 'e');
				parameter<bool>   test_param    := param = 24;
				attribute<uint32> att  (Domain) := strrpos(source/A, 't');
				attribute<bool>   test (Domain) := eq_or_both_null(att, source/strrPosA);
				parameter<bool>   test_attr     := all(test);
			}
			container strcount: url = "http://www.objectvision.nl/geodms/operators-a-functions/string/strcount"
			{
				parameter<uint32> param         := strcount(source/teststring, 'i');
				parameter<bool>   test_param    := param = 2;
				attribute<uint32> att  (Domain) := strcount(source/A, 't');
				attribute<bool>   test (Domain) := eq_or_both_null(att, source/strCountA);
				parameter<bool>   test_attr     := all(test);
			}
			container replace: url = "http://www.objectvision.nl/geodms/operators-a-functions/string/replace"
			{
				parameter<string> param             := replace(source/teststring, 'In', 'Bij');
				parameter<bool>   test_param        := param = 'Bij een string past ook een zin';
				parameter<string> paramMultiple     := replace(source/teststring, 'In', 'Bij','past','hoort','zin','quote');
				parameter<bool>   test_paramM       := paramMultiple = 'Bij een string hoort ook een quote' && test_paramMOrderA && test_paramMOrderB;
				parameter<bool>   test_paramMOrderA := replace(param, 'zin', 'woord','woord','functie') == 'Bij een string past ook een functie';
				parameter<bool>   test_paramMOrderB := replace(param, 'woord', 'functie','zin','woord') == 'Bij een string past ook een woord';
				
				attribute<string> att  (Domain)     := replace(source/C, 'Tes','Taar');
				attribute<bool>   test (Domain)     := eq_or_both_null(att, source/ReplaceC);
				parameter<bool>   test_attr         := all(test);
				
				attribute<string> attMultiple  (Domain) := replace(source/C, 'Tes','Taar', 'met', 'zonder');
				attribute<bool>   testMultiple (Domain) := eq_or_both_null(attMultiple, source/ReplaceCMultiple);
				parameter<bool>   test_attrMultiple     := all(testMultiple);
			}
			container replace_value: url = "http://www.objectvision.nl/geodms/operators-a-functions/string/replace_value"
			{
				parameter<string> param         := replace_value(source/teststring, 'In een string past ook een zin', 'Bij een string past ook een zin');
				parameter<bool>   test_param    := param = 'Bij een string past ook een zin';
				attribute<string> att  (Domain) := replace_value(LowerCase(source/C), 'test','taart');
				attribute<bool>   test (Domain) := eq_or_both_null(att, LowerCase(source/replace_valueC));
				parameter<bool>   test_attr     := all(test);
			}
			container repeat: url = "http://www.objectvision.nl/geodms/operators-a-functions/string/repeat"
			{
				parameter<string> param         := repeat('drie',3);
				parameter<bool>   test_param    := param = 'driedriedrie';
				attribute<string> att  (Domain) := repeat(source/repA, source/repNr);
				attribute<bool>   test (Domain) := MakeDefined(source/RepeatA,'') = att;
				parameter<bool>   test_attr     := all(test);
			}
			container trim: url = "http://www.objectvision.nl/geodms/operators-a-functions/string/trim"
			{
				parameter<string> test_l     := ltrim(source/TestTrimstring), url = "http://www.objectvision.nl/geodms/operators-a-functions/string/ltrim";
				parameter<string> test_r     := rtrim(source/TestTrimstring), url = "http://www.objectvision.nl/geodms/operators-a-functions/string/rtrim";
				parameter<string> test_p     :=  trim(source/TestTrimstring);
				parameter<bool>   test_param := test_l = 'string   met   spaties  ' && test_r = ' string   met   spaties' && test_p = 'string   met   spaties';

				attribute<string> att_l (Domain) := ltrim(source/A);
				attribute<string> att_r (Domain) := rtrim(source/A);
				attribute<string> att   (Domain) := trim(source/A);
				attribute<bool>   test  (Domain) := att_l = source/trimA && att_r = source/A && att = source/trimA;
				
				parameter<bool>   test_attr := all(test);
			}
			container sort_str: url = "http://www.objectvision.nl/geodms/operators-a-functions/string/sort_str"
			{
				attribute<string> att_asc   (Domain) := sort_str(source/A);
				attribute<bool>   test_asc  (Domain) := eq_or_both_null(att_asc, source/sortA_asc);
	
				attribute<string> att_desc  (Domain) := reverse(sort_str(source/A));
				attribute<bool>   test_desc (Domain) := eq_or_both_null(att_desc, source/sortA_desc);
				attribute<bool>   test      (Domain) := test_asc && test_desc;
				parameter<bool>   test_attr          := all(test);
			}
			container add:
				Using = "Source",
				url   ="http://www.objectvision.nl/geodms/operators-a-functions/string/add_str"
			{
			
				attribute<string> att_with_values     (Domain) := = #(Regions) > 0 ? 'add('+asItemList(Regions/regionnames)+')' : 'const('''',Domain)', DisableStorage = "True";
				attribute<string> att_without_values  (Domain) :[];
				attribute<string> att                 (Domain) := = #(Regions) == 0 ? 'att_without_values' : 'att_with_values' ;
				
				attribute<bool>   test (Domain) := att = source/SumProv;
				parameter<bool>   test_attr     := all(test);
			}
			container asList: url = "http://www.objectvision.nl/geodms/operators-a-functions/string/aslist"
			{
				parameter<string> param_att := asList(source/A, ';');
				parameter<string> param_exp_with_values    := 'Test;88hallo99;+);twee woorden; test met spatie';
				parameter<string> param_exp_without_values := '';
				parameter<string> param_exp                := = #Domain == 0 ? 'param_exp_without_values' : 'param_exp_with_values';
				
				attribute<string> att_asList (Prov) := asList(source/Steden_nrd/Stad, ';' , source/Steden_nrd/Provincie);
				attribute<bool>   test       (Prov) := att_asList = source/Prov_nrd/src_asList;
				parameter<bool>   test_attr             := param_att = param_exp && all(test);
			}
			container asExprList: url = "http://www.objectvision.nl/geodms/operators-a-functions/string/asexprlist"
			{
				parameter<bool>   test_param := asExprList(source/teststring) = quote(source/teststring) && asExprList(source/ValueToString) = String(source/ValueToString);
				parameter<string> param_att  := asExprList(source/A);
				parameter<string> param_exp_with_values    := quote('Test') +';' + quote ('88hallo99') + ';' + quote('+)') +';'+ quote('twee woorden') +';'+quote(' test met spatie');
				parameter<string> param_exp_without_values := '';
				parameter<string> param_exp                := = #Domain == 0 ? 'param_exp_without_values' : 'param_exp_with_values';

				attribute<string> att_asexprList (Prov) := asExprList(source/Steden_nrd/Stad, source/Steden_nrd/Provincie);
				attribute<bool>   test           (Prov) := att_asexprList = source/Prov_nrd/src_asexprList;
				parameter<bool>   test_attr  := param_att = param_exp && all(test);
			}
			container asItemList: url = "http://www.objectvision.nl/geodms/operators-a-functions/string/asitemlist"
			{
				parameter<bool>   test_param := asItemList(source/teststring) = source/teststring;
				parameter<string> param_att  := asItemList(source/A);
				parameter<string> param_exp_with_values    := 'Test' +',' + '88hallo99' + ',' + '+)' +','+ 'twee woorden'+','+' test met spatie';
				parameter<string> param_exp_without_values := '';
				parameter<string> param_exp                := = #Domain == 0 ? 'param_exp_without_values' : 'param_exp_with_values';
				attribute<string> att_asItemList (Prov) := asItemList(source/Steden_nrd/Stad, source/Steden_nrd/Provincie);
				attribute<bool>   test           (Prov) := att_asItemList = source/Prov_nrd/src_asItemList;
				parameter<bool>   test_attr  := param_att = param_exp && all(test);
			}
			container asDataString: url = "http://www.objectvision.nl/geodms/operators-a-functions/string/asdatastring"
			{
				parameter<bool>   test_param        := asDatastring(source/teststring) = '[' + quote(source/teststring) +']';
				parameter<string> param_att         := asDatastring(source/Steden_nrd/Stad);
//				parameter<string> param_att_float :=asDatastring(Conversion/Source/FloatAtt);
//				parameter<string> param_att_uint :=asDatastring(Conversion/Source/IntegerAtt);
//				parameter<string> param_att_bool :=asDatastring(Conversion/Source/BoolAtt);
//				parameter<string> param_att_string := asDatastring(Conversion/SPoint/att);
//				parameter<string> param_att_point :=asDatastring(Conversion/SPoint/att);
	
				parameter<string> param_exp_with_values :=
					'['+ 
						  quote('Groningen') +',' + quote('Delfzijl') + ',' + quote('Winschoten') +','+ quote('Leeuwarden') +',' 
						+ quote('Dokkum')    +',' + quote('Bolsward') + ',' + quote('Emmen')      +','+ quote('Assen')+',' 
						+ quote('Hoogeveen') 
					+']';
				parameter<string> param_exp_without_values := '[]';
				parameter<string> param_exp                := = #Domain == 0 ? 'param_exp_without_values' : 'param_exp_with_values';

				parameter<bool> test_attr := param_att == param_exp;
			}
			container expand: url = "http://www.objectvision.nl/geodms/operators-a-functions/string/expand"
			{
				parameter<string> LocalPath  := expand(.,'%localDataProjDir%/');
				parameter<bool>   test_param := strcount(LocalPath, '/') > 0;
			}
			container from_utf
			{
				parameter<bool> testA := from_utf(Source/special_characters/A)  == 'AAAAAAA';
				parameter<bool> testa_:= from_utf(Source/special_characters/a_) == 'aaaaaaa';
				parameter<bool> testC := from_utf(Source/special_characters/C)  == 'C';
				parameter<bool> testc_:= from_utf(Source/special_characters/c_) == 'c';
				parameter<bool> testE := from_utf(Source/special_characters/E)  == 'EEEE';
				parameter<bool> teste_:= from_utf(Source/special_characters/e_) == 'eeee';
				parameter<bool> testI := from_utf(Source/special_characters/I)  == 'IIII';
				parameter<bool> testi_:= from_utf(Source/special_characters/i_) == 'iiii';
				parameter<bool> testN := from_utf(Source/special_characters/N)  == 'N';
				parameter<bool> testn_:= from_utf(Source/special_characters/n_) == 'n';
				parameter<bool> testO := from_utf(Source/special_characters/O)  == 'OOOOOOO';
				parameter<bool> testo_:= from_utf(Source/special_characters/o_) == 'ooooooo';
				parameter<bool> testU := from_utf(Source/special_characters/U)  == 'UUUU';
				parameter<bool> testu_:= from_utf(Source/special_characters/u_) == 'uuuu';
				parameter<bool> testY := from_utf(Source/special_characters/Y)  == 'Y';
				parameter<bool> testy_:= from_utf(Source/special_characters/y_) == 'yy';
				
				parameter<bool> test_param := 
					   testA  && testa_ && testC  && testc_ && testE  && teste_ && testI 
					&& testi_ && testN  && testn_ && testO  && testo_ && testU  && testu_
					&& testY  && testy_;
			}
			container AsItemName
			{
				parameter<string> src   := '12&e @b naam';
				parameter<bool>   testA := AsItemName(src) == '_12_e_@b_naam';
			}
			container url_decode
			{
				parameter<string> srcOrg  := 'http://www.objectvision.nl';
// 				parameter<string> encoded := UrlEncode(srcOrg);
// 				parameter<string> decoded := UrlDecode(encoded);
				parameter<string> src  := 'http%3A%2F%2Fwww.objectvision.nl';
				parameter<string> attr := UrlDecode(src);
			}
			container results
			{
				parameter<bool> test_params := 
					   concatenation/test_param
					&& source/stringOperator/test_param
					&& strlen/test_param 
					&& strlen64/test_param 
					&& substr/test_param 
					&& substr2/test_param 
					&& left/test_param 
					&& right/test_param 
					&& quote/test_param  
					&& unquote/test_param 
					&& dquote/test_param  
					&& undquote/test_param 
					&& strpos/test_param 
					&& strrpos/test_param 
					&& strcount/test_param 
					&& replace/test_param 
					&& replace/test_paramM 
					&& replace_value/test_param 
					&& repeat/test_param 
					&& trim/test_param
					&& asExprList/test_param 
					&& asItemList/test_param 
					&& asDatastring/test_param 
					&& expand/test_param 
					&& from_utf/test_param
					&& AsItemName/testA;

				parameter<bool> test_attrs :=
					   concatenation/test_attr 
					&& strlen/test_attr  
					&& strlen64/test_attr  
					&& substr/test_attr 
					&& substr2/test_attr 
					&& left/test_attr 
					&& right/test_attr 
					&& quote/test_attr 
					&& unquote/test_attr 
					&& dquote/test_attr 
					&& undquote/test_attr 
					&& uppercase/test_attr 
					&& lowercase/test_attr 
					&& strpos/test_attr 
					&& strrpos/test_attr 
					&& strcount/test_attr 
					&& replace/test_attr 
					&& replace/test_attrMultiple
					&& replace_value/test_attr 
					&& repeat/test_attr 
					&& trim/test_attr
					&& sort_str/test_attr
					&& add/test_attr 
					&& asList/test_attr
					&& asExprList/test_attr 
					&& asItemList/test_attr 
					&& asDatastring/test_attr ;
				parameter<bool> tests := test_params && test_attrs;
			}
		}
	}
	container File
	{
		container CopyFileMakeDir
		{
			parameter<string> dir_proj   := FullPathName(., '%projDir%');
			parameter<string> dir_new    := dir_proj + '/test';
			parameter<string> MakeNewDir := makeDir(dir_new);
			parameter<string> file_org   := dir_proj + '/cfg/operator.dms';
			parameter<string> file_new   := dir_new + '/test.dms';
			parameter<string> CopyFile   := CopyFile(file_org, file_new)
			,	url = "http://www.objectvision.nl/geodms/operators-a-functions/file/copyfile"; //Error if source does not exists

			parameter<string> Initfile := InitFile (file_org, file_new),
				ExplicitSuppliers = "File/CopyFileMakeDir/MakeNewDir",
				url               = "http://www.objectvision.nl/geodms/operators-a-functions/file/initfile;//Does not copy if destination alerady exists";
			container CreateFile := CreateFile(file_org, file_new),
				url  = "http://www.objectvision.nl/geodms/operators-a-functions/file/createfile"; // To be added

			parameter<string> fullPathName := fullPathName(dir_new,  '/test.dms');

			parameter<bool> file_fullname := fullPathName(CopyFileMakeDir, dir_new + '/test.dms') = dir_new + '/test.dms',
				url  = "http://www.objectvision.nl/dms/Operator/fullPathName.htm";

			/*
			container Calc := EXEC('calc.exe'),
				url  = "http://www.objectvision.nl/geodms/operators-a-functions/file/exec";
			container ExecDLL:
				url  = "http://www.objectvision.nl/geodms/operators-a-functions/file/execdll"; // To be added
			*/
		}
		container do
		{
			container impl
			{
				parameter<string> Slash           : [ '/' ];
				parameter<string> BackSlash       : [ '\\' ];
				parameter<string> NewLine         : [ '\n' ];

				parameter<string> ComSpec         := Expand(., '%env:ComSpec%');
				parameter<string> FileNameDirInfo := '%LocalDataDir%/Operator/dirinfo.str';

				parameter<string> DirCmdOrg       := Expand(., 'dir %projDir%/data/*.shp > ' + FileNameDirInfo);
				parameter<string> DirCmd          := Replace(DirCmdOrg, Slash, BackSlash) + ' /B /S /A-D';
			}

			container writer := exec(impl/ComSpec, '/c ' + impl/DirCmd, Expand(., '%LocalDataDir%/Operator'));
			parameter<string> WrittenFile := do(writer, impl/FileNameDirInfo), KeepData="True";
			parameter<string> bestand: Storagename = "=WrittenFile";
			parameter<uint32> nr_shapefiles := strcount(bestand,impl/NewLine) ;
			parameter<bool> test := nr_shapefiles > 0 ;
		}
		container ExistingFile
		{
			parameter<string> Exists     := lowercase(ExistingFile('NoFile', CopyFileMakeDir/file_org));
			parameter<string> NotExists  := lowercase(ExistingFile('NoFile', CopyFileMakeDir/file_org + '___'));
			parameter<bool>   test_param := Exists == lowercase(CopyFileMakeDir/file_org) && NotExists == lowercase(expand(.,'%ConfigDir%/NoFile'));
		}
		container currentDir: url = "http://www.objectvision.nl/geodms/operators-a-functions/file/currentdir"
		{
			parameter<string> param      := currentDir();
			parameter<bool>   test_param := strcount(param,'cfg') > 0;
		}
		container storage_name: url  = "http://www.objectvision.nl/geodms/operators-a-functions/file/storage_name" // To be added
		{
			parameter<string> param      := storage_name(ReadAVLE/ReadValue/File);
			parameter<bool>   test_param := param == CopyFileMakeDir/dir_proj +'/data/demand.ini';
		}
		
		container parse_xml
		{
			parameter<String> XmlData
			:	StorageType = "str"
			,	StorageName = "%projDir%/data/standplaats.xml";
		
			/*	standplaats Schema, voorbeeld:
				<bag_LVC:standplaats>
					<bag_LVC:gerelateerdeAdressen>
						<bag_LVC:hoofdadres>
							<bag_LVC:identificatie>0003200000140496</bag_LVC:identificatie>
						</bag_LVC:hoofdadres>
					</bag_LVC:gerelateerdeAdressen>
					<bag_LVC:identificatie>0003020000000001</bag_LVC:identificatie>
					<bag_LVC:aanduidingRecordInactief>N</bag_LVC:aanduidingRecordInactief>
					<bag_LVC:aanduidingRecordCorrectie>0</bag_LVC:aanduidingRecordCorrectie>
					<bag_LVC:officieel>N</bag_LVC:officieel>
					<bag_LVC:standplaatsStatus>Plaats aangewezen</bag_LVC:standplaatsStatus>
					<bag_LVC:standplaatsGeometrie>
						<gml:Polygon srsName="urn:ogc:def:crs:EPSG::28992">
							<gml:exterior>
								<gml:LinearRing>
									<gml:posList srsDimension="3" count="8">
										252475.401 593758.074 0.0 252474.344 593760.335 0.0 252455.436 593751.494 0.0 252456.378 593749.18 0.0 252457.437 593746.915 0.0 252459.131 593743.291 0.0 252478.154 593752.186 0.0 252475.401 593758.074 0.0
									</gml:posList>
								</gml:LinearRing>
							</gml:exterior>
						</gml:Polygon>
					</bag_LVC:standplaatsGeometrie>
					<bag_LVC:tijdvakgeldigheid>
						<bagtype:begindatumTijdvakGeldigheid>2010072000000000</bagtype:begindatumTijdvakGeldigheid>
					</bag_LVC:tijdvakgeldigheid>
					<bag_LVC:inOnderzoek>N</bag_LVC:inOnderzoek>
					<bag_LVC:bron>
						<bagtype:documentdatum>20100720</bagtype:documentdatum>
						<bagtype:documentnummer>FB 2010/LIG001</bagtype:documentnummer>
					</bag_LVC:bron>
				</bag_LVC:standplaats>
			*/

			container schema// xml attributes are here modelled as sub units of the entity related unit.
			{
				unit<uint32> bag_LVC_standplaats
				{
					attribute<string> bag_LVC_identificatie (bag_LVC_standplaats);
					unit<uint32> bag_LVC_hoofdadres{
						attribute<string> bag_LVC_identificatie;
					}
					unit<uint32> bag_LVC_nevenadres{
						attribute<string> bag_LVC_identificatie;
					}
					unit<uint32> gml_Polygon { // 1-1 relationship is assumed/likely
	//						attribute<string> srsName;
	
	//						unit<uint32> gml_Exterior { // 1-1 relationship is prescibed by the gml schema
	//							unit<uint32> gml_LinearRing { // 1-1 relationship is prescibed by the gml schema
								unit<uint32> gml_posList // 1-1 relationship is assumed/likely
								{
									attribute<string> srsDimension; // attribute, must only have the value 3
									attribute<string> count;
								}
	//							} // </gml_LinearRing>
	//						}
						unit<uint32> gml_Interior {
	//							unit<uint32> gml_LinearRing { // 1-1 relationship is prescibed by the gml schema
								unit<uint32> gml_posList // 1-1 relationship is assumed/likely
								{
									attribute<string> srsDimension; // attribute, must only have the value 3
									attribute<string> count;
								}
	//							} // </gml_LinearRing>
						}
					} // </gml_Polygon>
					
					// Meta velden, nog eens kijken of dit niet generiek kan
					attribute<string> bag_LVC_standplaatsStatus (bag_LVC_standplaats);
	
					attribute<string> bag_LVC_aanduidingRecordInactief;
					attribute<string> bag_LVC_aanduidingRecordCorrectie;
					attribute<string> bag_LVC_officieel;
					attribute<string> bag_LVC_inOnderzoek;
					// attribute<string> bag_LVC_isIndicatie;
	
					attribute<string> bagtype_begindatumTijdvakGeldigheid;
					attribute<string> bagtype_einddatumTijdvakGeldigheid;
					attribute<string> bagtype_documentdatum;
					attribute<string> bagtype_documentnummer;
					
				}
			}
			container ParsedXML  := parse_xml(XmlData, schema);
			attribute<uint32> Parent_EntityTable_rel_ok (ParsedXML/bag_LVC_standplaats) := const(0, ParsedXML/bag_LVC_standplaats);
			attribute<bool>   test_att                  (ParsedXML/bag_LVC_standplaats) := MakeDefined(ParsedXML/bag_LVC_standplaats/Parent_EntityTable_rel,0) == Parent_EntityTable_rel_ok;
			parameter<bool>   test                                                      := all(test_att);
		}

		container results
		{
			parameter<bool> tests := 
				   currentDir/test_Param
				&& do/test
				&& ExistingFile/test_Param
				&& storage_name/test_param;
		}
	}
	container ReadAVLE
	{
		container source
		{
			attribute<string>  ReadArray1 (HDomain): ['6','9.02','Test','True'];
			attribute<float64> ReadArray2 (RDomain): [25000,27500,11000,6100,14400,300,70];
			attribute<float64> ReadArray3 (RDomain): [30000,32500,12000,6200,14500,320,72];
			attribute<float64> ReadArray4 (RDomain): [35000,37500,13000,6300,14600,340,74];
			attribute<float64> ReadArray5 (RDomain): [40000,42500,14000,6400,14700,360,76];
			attribute<float64> ReadArray6 (RDomain): [45000,47500,15000,6500,14800,380,78];
			attribute<uint32>  ReadElem1  (ReadLines/BodyDomain): [25000,30000,35000,40000,45000,50000];
			attribute<uint32>  ReadElem2  (ReadLines/BodyDomain): [70,72,74,76,78,80];
		}
		container ReadValue: url = "http://www.objectvision.nl/geodms/operators-a-functions/file/readvalue"
		{
			parameter<string>  File:   StorageName = "%projDir%/data/demand.ini", StorageType = "str", KeepData = "True";
			parameter<uint32>  Value1     := ReadValue(File, uint32,  0);
			parameter<float32> Value2     := ReadValue(File, float32, Value1/ReadPos);
			parameter<string>  Value3     := ReadValue(File, string,  Value2/ReadPos);
			parameter<bool>    Value4     := ReadValue(File, bool,    Value3/ReadPos);
			parameter<uint32>  Value5     := ReadValue(File, uint32,  Value4/ReadPos);
			parameter<bool>    test_param := Value1 = 6 && Value2 = float32(9.02) && Value3 = 'Test' && Value4  && Value5 = 25000;
		}
		container ReadArray: url = "http://www.objectvision.nl/geodms/operators-a-functions/file/readarray"
		{
			Attribute<String>  Row1  (HDomain) := ReadArray(ReadValue/File, HDomain, String, 0);
			Attribute<float64> Row2  (RDomain) := ReadArray(ReadValue/File, RDomain, float64, Row1/ReadPos);
			Attribute<float64> Row3  (RDomain) := ReadArray(ReadValue/File, RDomain, float64, Row2/ReadPos);
			Attribute<float64> Row4  (RDomain) := ReadArray(ReadValue/File, RDomain, float64, Row3/ReadPos);
			Attribute<float64> Row5  (RDomain) := ReadArray(ReadValue/File, RDomain, float64, Row4/ReadPos);
			Attribute<float64> Row6  (RDomain) := ReadArray(ReadValue/File, RDomain, float64, Row5/ReadPos);
			Attribute<bool>    testH (HDomain) := Row1 == Source/ReadArray1;
			Attribute<bool>    test  (RDomain) := 
				Row2 == Source/ReadArray2 && Row3 == Source/ReadArray3 && Row4 == Source/ReadArray4 && Row5 == Source/ReadArray5 && Row6 == Source/ReadArray6;
			parameter<bool>    test_attr       := all(testH) && all(test);
		}
		container ReadArrayII
		{
			parameter<string> Coordparam :
				['254059.737,593504.637,0.0,,254059.227,593500.0,0.0,,254059.216,593499.899,0.0,,254058.242,593500.0,0.0,,254057.914,593500.034,0.0,,254057.893,593500.0,0.0,,254057.807,593499.863,0.0,,254052.074,593490.692,0.0,,254052.182,593490.639,0.0,,254058.138,593490.002,0.0,,254057.932,593488.165,0.0,,254074.487,593486.413,0.0,,254075.981,593500.0,0.0,,254076.265,593502.583,0.0,,254076.561,593502.55,0.0,,254076.594,593502.847,0.0,,254059.737,593504.637,0.0,, 253822.701,593455.662,0.0,,253826.352,593500.0,0.0,,253827.457,593513.425,0.0,,253812.358,593514.669,0.0,,253812.12,593511.782,0.0,,253816.665,593511.408,0.0,,253815.726,593500.0,0.0,,253812.163,593456.738,0.0,,253810.619,593456.865,0.0,,253810.278,593452.716,0.0,,253816.1,593452.236,0.0,,253816.425,593456.179,0.0,,253822.701,593455.662,0.0,, 249943.307,593511.272,0.0,,249948.555,593512.791,0.0,,249946.234,593520.809,0.0,,249940.987,593519.29,0.0,,249943.307,593511.272,0.0,, 252002.1,593526.23,0.0,,252000.73,593522.9,0.0,,252003.1,593521.92,0.0,,252004.47,593525.26,0.0,,252002.1,593526.23,0.0,, 253227.559,593526.493,0.0,,253231.617,593526.03,0.0,,253233.488,593528.575,0.0,,253236.789,593533.066,0.0,,253233.641,593535.379,0.0,,253233.525,593535.221,0.0,,253228.886,593538.631,0.0,,253225.653,593534.232,0.0,,253222.628,593530.117,0.0,,253227.559,593526.493,0.0,, 253311.271,593541.787,0.0,,253310.818,593541.3,0.0,,253305.792,593545.973,0.0,,253298.856,593538.513,0.0,,253306.494,593531.412,0.0,,253313.703,593524.709,0.0,,253321.091,593532.656,0.0,,253320.205,593533.48,0.0,,253311.271,593541.787,0.0,, 253909.583,593544.124,0.0,,253985.736,593535.232,0.0,,253986.48,593535.145,0.0,,253986.936,593539.19,0.0,,253987.559,593544.714,0.0,,253991.329,593544.241,0.0,,253992.052,593549.793,0.0,,253988.001,593550.284,0.0,,253987.478,593545.818,0.0,,253910.933,593554.449,0.0,,253909.583,593544.124,0.0,, 254339.978,593500.0,0.0,,254338.865,593481.193,0.0,,254333.36,593388.145,0.0,,254332.792,593378.542,0.0,,254383.022,593375.569,0.0,,254390.304,593500.0,0.0,,254392.687,593540.725,0.0,,254383.845,593558.431,0.0,,254378.695,593557.207,0.0,,254378.682,593557.296,0.0,,254342.864,593548.797,0.0,,254339.978,593500.0,0.0,, 253822.613,593551.143,0.0,,253898.852,593542.245,0.0,,253899.556,593542.163,0.0,,253900.259,593548.221,0.0,,253900.631,593551.421,0.0,,253904.424,593550.98,0.0,,253905.084,593556.658,0.0,,253900.814,593557.155,0.0,,253900.699,593556.163,0.0,,253900.31,593552.814,0.0,,253826.529,593561.388,0.0,,253827.016,593565.586,0.0,,253824.333,593565.906,0.0,,253822.613,593551.143,0.0,, 252577.381,591006.123,0.0,,252577.17,591006.19,0.0,,252577.158,591006.15,0.0,,252576.48,591003.97,0.0,,252579.93,591002.89,0.0,,252580.62,591005.1,0.0,,252577.381,591006.123,0.0,, 252170.271,591000.0,0.0,,252169.092,590995.641,0.0,,252171.242,590995.06,0.0,,252170.65,590992.872,0.0,,252175.157,590991.653,0.0,,252175.753,590993.855,0.0,,252177.77,590993.31,0.0,,252179.578,591000.0,0.0,,252180.69,591004.113,0.0,,252172.017,591006.458,0.0,,252170.271,591000.0,0.0,, 252834.99,593531.368,0.0,,252834.924,593532.877,0.0,,252834.147,593534.172,0.0,,252832.846,593534.94,0.0,,252831.336,593534.995,0.0,,252829.983,593534.323,0.0,,252829.114,593533.088,0.0,,252828.564,593531.042,0.0,,252827.467,593531.296,0.0,,252826.533,593531.646,0.0,,252820.246,593534.239,0.0,,252813.74,593537.637,0.0,,252807.605,593541.604,0.0,,252801.833,593546.101,0.0,,252796.348,593551.217,0.0,,252795.518,593550.407,0.0,,252794.38,593551.599,0.0,,252803.93,593560.006,0.0,,252803.718,593560.238,0.0,,252803.094,593559.711,0.0,,252799.911,593563.35,0.0,,252796.159,593568.437,0.0,,252795.31,593569.911,0.0,,252782.908,593562.469,0.0,,252784.133,593560.447,0.0,,252788.613,593554.302,0.0,,252792.248,593550.17,0.0,,252791.645,593549.635,0.0,,252791.855,593549.4,0.0,,252793.145,593550.528,0.0,,252794.302,593549.335,0.0,,252784.581,593539.888,0.0,,252784.32,593540.143,0.0,,252784.007,593539.807,0.0,,252791.064,593533.117,0.0,,252798.081,593527.691,0.0,,252805.537,593522.924,0.0,,252813.422,593518.845,0.0,,252821.655,593515.514,0.0,,252830.136,593512.913,0.0,,252831.483,593512.884,0.0,,252832.71,593513.44,0.0,,252833.576,593514.472,0.0,,252833.91,593515.778,0.0,,252833.646,593517.099,0.0,,252832.837,593518.176,0.0,,252831.641,593518.797,0.0,,252834.99,593531.368,0.0,, 253854.014,593576.263,0.0,,253850.991,593576.476,0.0,,253850.541,593571.14,0.0,,253853.534,593570.93,0.0,,253854.014,593576.263,0.0,, 253317.862,593305.68,0.0,,253323.616,593303.621,0.0,,253327.079,593313.296,0.0,,253324.093,593314.362,0.0,,253325.283,593317.696,0.0,,253319.679,593319.696,0.0,,253317.628,593313.95,0.0,,253320.454,593312.942,0.0,,253317.862,593305.68,0.0,, 250224.34,592877.6,0.0,,250229.785,592860.576,0.0,,250197.702,592849.627,0.0,,250204.322,592830.234,0.0,,250231.296,592839.443,0.0,,250231.887,592837.711,0.0,,250235.206,592838.843,0.0,,250236.877,592833.866,0.0,,250243.15,592835.971,0.0,,250241.373,592840.974,0.0,,250246.506,592842.707,0.0,,250250.39,592831.018,0.0,,250277.522,592840.125,0.0,,250266.23,592872.94,0.0,,250242.67,592864.98,0.0,,250240.74,592870.71,0.0,,250236.2,592869.18,0.0,,250232.6,592880.24,0.0,,250224.34,592877.6,0.0,, 253997.494,593234.799,0.0,,253994.534,593235.286,0.0,,253993.543,593229.267,0.0,,253996.461,593228.787,0.0,,253997.494,593234.799,0.0,, 254093.426,593579.688,0.0,,254082.808,593580.782,0.0,,254078.436,593581.233,0.0,,254078.115,593578.414,0.0,,254082.543,593577.935,0.0,,254082.429,593576.89,0.0,,254078.755,593543.092,0.0,,254074.282,593543.697,0.0,,254073.735,593538.956,0.0,,254000.0,593547.368,0.0,,253997.451,593547.659,0.0,,253996.102,593537.136,0.0,,254000.0,593536.683,0.0,,254072.653,593528.244,0.0,,254073.058,593532.232,0.0,,254073.627,593537.833,0.0,,254078.43,593537.285,0.0,,254079.138,593542.244,0.0,,254085.832,593541.509,0.0,,254088.969,593541.164,0.0,,254088.995,593541.389,0.0,,254093.426,593579.688,0.0,, 250270.645,593568.57,0.0,,250289.579,593571.892,0.0,,250287.761,593582.255,0.0,,250268.827,593578.933,0.0,,250270.645,593568.57,0.0,, 254173.876,593396.885,0.0,,254173.334,593393.19,0.0,,254177.038,593392.647,0.0,,254177.58,593396.343,0.0,,254173.876,593396.885,0.0,, 251740.562,590337.748,0.0,,251741.87,590342.467,0.0,,251732.947,590344.941,0.0,,251731.639,590340.222,0.0,,251740.562,590337.748,0.0,, 252171.704,590967.069,0.0,,252174.56,590968.673,0.0,,252175.27,590971.818,0.0,,252173.827,590974.148,0.0,,252170.767,590975.094,0.0,,252167.886,590973.743,0.0,,252167.165,590970.804,0.0,,252168.241,590968.31,0.0,,252171.704,590967.069,0.0,, 252327.822,591585.103,0.0,,252324.718,591585.057,0.0,,252324.805,591579.127,0.0,,252327.91,591579.173,0.0,,252327.822,591585.103,0.0,, 253134.447,591644.881,0.0,,253132.462,591644.3,0.0,,253132.963,591642.547,0.0,,253134.955,591643.098,0.0,,253134.447,591644.881,0.0,, 250251.792,591643.263,0.0,,250256.962,591645.583,0.0,,250250.765,591659.398,0.0,,250245.594,591657.078,0.0,,250251.792,591643.263,0.0,, 254741.475,591692.58,0.0,,254741.487,591694.418,0.0,,254739.444,591694.454,0.0,,254739.403,591692.594,0.0,,254741.475,591692.58,0.0,, 254207.03,591782.62,0.0,,254210.49,591759.62,0.0,,254231.96,591762.86,0.0,,254238.278,591763.819,0.0,,254234.788,591786.809,0.0,,254228.47,591785.85,0.0,,254207.03,591782.62,0.0,, 252256.23,591809.89,0.0,,252252.45,591808.71,0.0,,252253.98,591803.79,0.0,,252257.77,591804.96,0.0,,252256.23,591809.89,0.0,, 254234.49,591831.79,0.0,,254231.99,591831.42,0.0,,254232.64,591826.97,0.0,,254235.16,591827.34,0.0,,254234.49,591831.79,0.0,, 250956.136,591851.813,0.0,,250955.946,591849.381,0.0,,250952.642,591849.639,0.0,,250952.145,591843.264,0.0,,250955.449,591843.007,0.0,,250954.153,591826.384,0.0,,250955.087,591826.311,0.0,,250954.763,591822.161,0.0,,250962.556,591821.553,0.0,,250962.88,591825.703,0.0,,250994.2,591823.26,0.0,,250996.184,591848.689,0.0,,250956.136,591851.813,0.0,, 252332.881,592127.146,0.0,,252329.341,592126.404,0.0,,252329.961,592123.445,0.0,,252333.501,592124.187,0.0,,252332.881,592127.146,0.0,,'];
			
			unit<uint32> coordset := range(uint32, 0, 1203)
			{
				Attribute<String> row := ReadArray(coordparam, coordset, string, 0);
			}
			parameter<bool> test := coordset/row[1200] = '252332.881' && coordset/row[1201] = '592127.146' && coordset/row[1202] = '0.0';
		}

		container ReadElems: url = "http://www.objectvision.nl/geodms/operators-a-functions/file/readelem"
		{
			attribute<uint32> FirstColum (ReadLines/BodyDomain) := ReadElems(ReadLines/Body, ReadLines/BodyDomain, const( 0, ReadLines/BodyDomain));
			attribute<uint32> LastCoumn  (ReadLines/BodyDomain) := ReadElems(ReadLines/Body, ReadLines/BodyDomain, const(32, ReadLines/BodyDomain));
			attribute<Bool>   test       (ReadLines/BodyDomain) := FirstColum = Source/ReadElem1 && LastCoumn = Source/ReadElem2;
			parameter<bool>   test_attr                         := all(test);
		}
		container ReadLines: url = "http://www.objectvision.nl/geodms/operators-a-functions/file/readline"
		{
			unit<uint32>      BodyDomain:         nrOfRows = 6;
			parameter<String> Header             := ReadLines(ReadValue/File, void, 0);
			parameter<Bool>   test_param         := Header = '6\t9.02\tTest\tTrue';
			Attribute<String> Body  (BodyDomain) := ReadLines(ReadValue/File, BodyDomain, Header/ReadPos);
			Parameter<bool>   test_attr
				 := substr(Body[0], 0, 5) = '25000' && substr(Body[0], strlen(Body[0]) - 3, 3) = '70\t' && substr(Body[5], 0, 5) = '50000' && substr(Body[5], strlen(Body[5]) - 3, 3) = '80\t';
		}

		container results
		{
			parameter<bool> tests := 
				   ReadValue/test_param
				&& ReadArray/test_attr
				&& ReadArrayII/test
				&& ReadElems/test_attr
				&& ReadLines/test_param
				&& ReadLines/test_attr
			;
		}
	}
	container MetaScript
	{
		unit <uint32> Region := ADomain
		{
			attribute<Region> RegionNr:         [0,1,2,3,4];
			attribute<string> MetaScriptName:   ['NoordHolland','ZuidHolland','Utrecht','NoordBrabant','Gelderland'];
			attribute<uint32> sumNrInhabitants: [550,1025,300,200,0];
			attribute<string> RegionLabel:      ['hoofdstad: Amterdam','hoofdstad: Den Bosch','hoofdstad: Utrecht','hoofdstad: Den Haag',null];
			attribute<string> RegionDescr:      ['Van Texel tot het Gooi','De locatie voor het carnaval','De dom is het hoogste gebouw',null,null];
		}

		unit <uint32> ERegion := EDomain
		{
			attribute<Region> RegionNr:         [];
			attribute<string> MetaScriptName:   [];
			attribute<uint32> sumNrInhabitants: [];
			attribute<string> RegionLabel:      [];
			attribute<string> RegionDescr:      [];
		}

		unit<uint32> PropValueSource := Region
		{
			parameter<uint32> label: ['ABC'];
			attribute<uint32> sumNrInhabitants: [2,5,3,2,0];
			unit<uint32>      domainA: nrofrows = 9;
			unit<float64>     valuesB := baseunit('b',float64);
		}

		container for_each: url = "http://www.objectvision.nl/geodms/operators-a-functions/metascript/for_each"
		{
			container regions := for_each_nedvld(
				 Region/MetaScriptName
				,'lookup(' + String(Region/RegionNr) + ', Region/sumNrInhabitants)'
				,void
				,uint32
				,Region/RegionLabel
				,Region/RegionDescr
			);

			parameter<bool> test := regions/NoordHolland = 550 && regions/ZuidHolland = 1025 && regions/Utrecht = 300 && regions/NoordBrabant = 200 && regions/Gelderland = 0;
		}

		container for_each_empty: url = "http://www.objectvision.nl/geodms/operators-a-functions/metascript/for_each"
		{
			container regions := for_each_nedvld(
				 ERegion/MetaScriptName
				,'lookup(' + String(ERegion/RegionNr) + ', ERegion/sumNrInhabitants)'
				,void
				,uint32
				,ERegion/RegionLabel
				,ERegion/RegionDescr
			);

			parameter<bool> test := PropValue(Regions,'name') == 'Regions' ;
		}

		container for_each_read_grid: url = "http://www.objectvision.nl/geodms/operators-a-functions/metascript/for_each"
		{
			container griddata := for_each_ind(
				'ndvatr'
				,Region/MetaScriptName
				,Grid/Tiled/GridDomain
				,uint8
				,'%projdir%/data/src.tif'
				,'gdal.grid'
				, True
			);

			parameter<bool> test := sum(griddata/NoordHolland) + sum(griddata/ZuidHolland) + sum(griddata/Utrecht) + sum(griddata/NoordBrabant) + sum(griddata/Gelderland) == 135b;
		}

		container for_each_ind
		{
			container regions := for_each_ind(
				'nedvld'
				,Region/MetaScriptName
				,'lookup(' + String(Region/RegionNr) + ', Region/sumNrInhabitants)'
				,void
				,uint32
				,Region/RegionLabel
				,Region/RegionDescr
			);

			parameter<bool> test := regions/NoordHolland = 550 && regions/ZuidHolland = 1025 && regions/Utrecht = 300 && regions/NoordBrabant = 200 && regions/Gelderland = 0;
		}

		container for_each_ind_empty: url = "http://www.objectvision.nl/geodms/operators-a-functions/metascript/for_each"
		{
			container regions := for_each_ind(
				'nedvld'
				,ERegion/MetaScriptName
				,'lookup(' + String(ERegion/RegionNr) + ', ERegion/sumNrInhabitants)'
				,void
				,uint32
				,ERegion/RegionLabel
				,ERegion/RegionDescr
			);

			parameter<bool> test := PropValue(Regions,'name') == 'Regions' ;
		}

		container loop := loop(LoopTemplate, uint16(5)),
			url  = "http://www.objectvision.nl/geodms/operators-a-functions/metascript/loop"
		{
			parameter<bool> test := loop/lastIter/results/LoopWaarde == uint16(4);
		}
		Template LoopTemplate
		{
			parameter<uint16> NrIter;
			container currValue;
			container nextValue;
			container results
			{
				parameter<uint16> LoopWaarde := NrIter; 
			}
		}
		container SubItem_PropValues
		{
			unit<uint32> Name := SubItem_PropValues(PropValueSource,'name')
			{
				attribute<string> ok: ['label','sumnrinhabitants','domaina','valuesb'];
				attribute<bool>   test      := lowercase(name) == ok;
				parameter<bool>   test_attr := all(test);
			}
			unit<uint32> Expr := SubItem_PropValues(PropValueSource,'expr')
			{
				attribute<string> ok7411: [
					'',
					'',
					'=''range(BaseUnit(Left(''+Quote(PropValue(., ''FullName'')+''/domainA'')+'',0),UInt32),UInt32(0),UInt32(9))''',
					'baseunit(''b'',float64)'
				];
			
				attribute<string> ok8001: [
					'',
					'',
					'',
					'baseunit(''b'',float64)'
				];
			
				attribute<string> ok := =(GeoDmsVersion() < 7.9) ? 'ok7411' : 'ok8001';
			
				attribute<bool>   test      := lowercase(Expr) == lowercase(ok);
				parameter<bool>   test_attr := all(test);
			}
			unit<uint32> PropValuesSet: nrofrows = 4;
			unit<uint32> MultipleAttributes := SubItem_PropValues(PropValueSource,union_data(PropValuesSet, 'name', 'fullname','ValuesUnit','DomainUnit'));

		}
		container Inherited_PropValues
		{
			unit<uint32> Name := Inherited_PropValues(PropValueSource,'name')
			{
				attribute<string> ok: ['label','sumnrinhabitants','domaina','valuesb','regionnr','metascriptname','sumnrinhabitants','regionlabel','regiondescr'];
				attribute<bool>   test      := lowercase(name) == ok;
				parameter<bool>   test_attr := all(test);
			}
			unit<uint32> Expr := Inherited_PropValues(PropValueSource,'expr')
			{
				attribute<string> ok7411: ['','',
				'=''range(BaseUnit(Left(''+Quote(PropValue(., ''FullName'')+''/domainA'')+'',0),UInt32),UInt32(0),UInt32(9))''',
				'baseunit(''b'',float64)','','','','',''
				];
				attribute<string> ok8001: ['','',
//				'=''range(BaseUnit(Left(''+Quote(PropValue(., ''FullName'')+''/domainA'')+'',0),UInt32),UInt32(0),UInt32(9))''',
				'',
				'baseunit(''b'',float64)','','','','',''
				];
				attribute<string> ok := =(GeoDmsVersion() < 7.9) ? 'ok7411' : 'ok8001';
				attribute<bool>   test      := lowercase(Expr) == LowerCase(ok);
				parameter<bool>   test_attr := all(test);
			}
		}
		container SubTree_PropValues
		{
			unit<uint32> Name := SubTree_PropValues(MetaScript/loop/iter0,'name')
			{
				attribute<string> ok: ['nriter','currvalue','nextvalue','results','loopwaarde'];
				attribute<bool>   test      := lowercase(name) == ok;
				parameter<bool>   test_attr := all(test);
			}
			
			unit<uint32> Property: nrofrows = 4
			{
				attribute<string> name: ['name','fullname','label','expr'];
			}

			unit<uint32> Multiple := SubTree_PropValues(MetaScript/loop/iter0, Property/name)
			{
				attribute<string> ok_name     : ['NrIter','currValue','nextvalue','results','loopwaarde'];
				attribute<string> ok_fullname : ['/metascript/loop/iter0/nriter','/metascript/loop/iter0/currvalue','/metascript/loop/iter0/nextvalue','/metascript/loop/iter0/results','/metascript/loop/iter0/results/loopwaarde'];
				attribute<string> ok_label    : ['','','','',''];
				attribute<string> ok_expr     : ['','','','','nriter'];

				attribute<bool>   test        := lowercase(name) == lowercase(ok_name) && lowercase(fullname) == lowercase(ok_fullname) && lowercase(label) == lowercase(ok_label) && lowercase(expr) == lowercase(ok_expr);
				parameter<bool>   test_attr   := all(test);
			}
		}
		container results
		{
			parameter<bool> tests :=
				   for_each/test 
				&& for_each_empty/test
				&& for_each_read_grid/test 
				&& loop/test
				&& for_each_ind/test
				&& for_each_ind_empty/test
				&& SubItem_PropValues/Name/test_attr   && SubItem_PropValues/Expr/test_attr 
				&& Inherited_PropValues/Name/test_attr && Inherited_PropValues/Expr/test_attr 
				&& SubTree_PropValues/Name/test_attr;
		}
	}
	container Allocation: url = "http://www.objectvision.nl/geodms/operators-a-functions/allocation"
	{
		unit<fpoint> TestCoords: Range = "[{100, 0}, {600, 600})";
		unit<spoint> DomainGrid :=
				range(
				  gridset(
					fpoint, 
					point(float32(  -500.0), float32(  500.0), TestCoords), 
					point(float32(625000.0), float32(10000.0), TestCoords), 
					SPoint
				  ),
				  point(int16(0), int16(0))
				, point(int16(6), int16(6))
				),
			DialogType = "Map";

		unit<spoint> EDomainGrid :=
				range(
				  gridset(
					fpoint, 
					point(float32(  -500.0), float32(  500.0), TestCoords), 
					point(float32(625000.0), float32(10000.0), TestCoords), 
					SPoint
				  ),
				  point(int16(0), int16(0))
				, point(int16(0), int16(0))
				),
			DialogType = "Map";

		container source
		{
			unit<float32> EurM2;

			attribute<lu_type> landuse (DomainGrid):
			[
			 2, 2, 2, 1, null, null,
			 2, 2, 0, 0, null, 1,
			 2, 0, 0, 1,    1, 1,
			 2, 0, 0, 0,    1, 1,
			 2, 0, 0, 1, null, 1,
			 2, 2, 2, 2,    2, 2
			];
			unit <uint8> lu_type: nrofrows = 3
			{
				attribute<string>  Name:           [ 'Living', 'Working', 'Nature' ], DialogType = "LabelText";
				attribute<string>  PartioningName: [ 'Living', 'Working', 'Nature' ];
				attribute<lu_type> partioning := id(lu_type);
				attribute<uint32>  BrushColor: [rgb(200,0,0),rgb(100,100,100),rgb(0,200,0)], DialogType = "BrushColor";
			}
			container SuitabilityMaps
			{
				attribute<EurM2> Living  (DomainGrid):
				[
				 1,  2,  5, 4,  3, -1,
				 2,  5,  8, 9,  7, 3,
				 4, 10, 12,13, 12, 6,
				 5, 11, 13,14, 12, 6,
				 4,  9,  9, 5,  3, 2,
				 2,  2,  4, 3,  1, 1
				];
				attribute<EurM2> Working (DomainGrid):
				[
				 1, 1, 2, 3,  4, -6,
				 2, 3, 4, 6,  8, 9,
				 2, 4, 9,11, 12,10,
				 1, 3, 5, 9, 10, 6,
				 2, 4, 5, 5,  3, 2,
				 1, 1, 2, 1,  1, 1
				];
				attribute<EurM2> Nature  (DomainGrid):
				[
				 3, 3, 3, 2, 2, -2,
				 3, 3, 2, 2, 2, 2,
				 3, 2, 1, 1, 1, 1,
				 3, 2, 1, 1 ,1, 2,
				 3, 3, 2, 1, 2, 2,
				 3, 3, 3, 3, 3, 3
				];
			}
			container regMaps
			{
				unit <uint8> p1: nrofrows = 1;
				unit <uint8> p2: nrofrows = 2;

				attribute<p1> p1Map (DomainGrid) := const(0, DomainGrid, p1);
				attribute<p2> p2Map (DomainGrid) := pointRow(ID(DomainGrid)) < int16(4) ? value(0,p2) : value(1,p2);
			}
			container claim_sources
			{
				unit<float32> Meter := BaseUnit('m', float32);
				unit<float32> Ha :=10000.0 * Meter * Meter;

				container p1
				{
					attribute<Ha> Nature_min (regMaps/p1): [12];
					attribute<Ha> Nature_max (regMaps/p1): [20];
					attribute<Ha> Living_min (regMaps/p1): [5];
					attribute<Ha> Living_max (regMaps/p1): [9];
				}
				container p2
				{
					attribute<Ha> Working_min (regMaps/p2): [6,2];
					attribute<Ha> Working_max (regMaps/p2): [10,4];
				}
			}
			parameter <float32> nrHaPerCel := value(1, claim_sources/Ha);
			container claims_min
			{
				attribute<uint32> Living (regMaps/p1) := uint32(claim_sources/p1/Living_min  / nrHaPerCel);
				attribute<uint32> Working(regMaps/p2) := uint32(claim_sources/p2/Working_min / nrHaPerCel);
				attribute<uint32> Nature (regMaps/p1) := uint32(claim_sources/p1/Nature_min  / nrHaPerCel);
			}
			container claims_max
			{
				attribute<uint32> Living (regMaps/p1) := uint32(claim_sources/p1/Living_max  / nrHaPerCel);
				attribute<uint32> Working(regMaps/p2) := uint32(claim_sources/p2/Working_max / nrHaPerCel);
				attribute<uint32> Nature (regMaps/p1) := uint32(claim_sources/p1/Nature_max  / nrHaPerCel);
			}
			container regionSets
			{
				attribute<regMaps/p1> Nature (DomainGrid) := regMaps/p1Map;
				attribute<regMaps/p1> Living (DomainGrid) := regMaps/p1Map;
				attribute<regMaps/p2> Working(DomainGrid) := regMaps/p2Map;
			}
			unit<uint16> AtomicRegions := overlay(lu_type/PartioningName, DomainGrid, regionSets);

			attribute<Bool> InRegio (DomainGrid):
			[
			 True, True, True,True,False,True,
			 True, True, True,True,False,True,
			 True, True, True,True,True,True,
			 True, True, True,True,True,True,
			 True, True, True,True,False,True,
			 True, True, True,True,True,True
			];
			attribute<Bool> FreeLand (DomainGrid) := InRegio;

			container Compacted
			{
				unit <uint32>      ADomain := Subset(FreeLand = True),
					label = "allocation domain";
				attribute<ADomain> BaseGrid (DomainGrid) :=invert(ADomain/nr_OrgEntity);
				
				container SuitabilityMaps
				{
					attribute<int32> Living  (ADomain) := int32(Allocation/source/SuitabilityMaps/Living)[ADomain/nr_orgEntity]  * int32(1000);
					attribute<int32> Working (ADomain) := int32(Allocation/source/SuitabilityMaps/Working)[ADomain/nr_orgEntity] * int32(1000);
					attribute<int32> Nature  (ADomain) := int32(Allocation/source/SuitabilityMaps/Nature)[ADomain/nr_orgEntity]  * int32(1000);
				}
				container SuitabilityMapsDiv
				{
					attribute<int32> Living  (ADomain) := int32(Allocation/source/SuitabilityMaps/Living  * float32(1000) / float32(12.46220836))[ADomain/nr_orgEntity];
					attribute<int32> Working (ADomain) := int32(Allocation/source/SuitabilityMaps/Working * float32(1000) / float32(12.46220836))[ADomain/nr_orgEntity];
					attribute<int32> Nature  (ADomain) := int32(Allocation/source/SuitabilityMaps/Nature  * float32(1000) / float32(12.46220836))[ADomain/nr_orgEntity];
				}
				attribute<AtomicRegions> AtomicRegionMap(ADomain) := AtomicRegions/UnionData[ADomain/nr_orgEntity];
			}
			parameter<int32> treshold := int32(0);
			container FeasibleSolution;
		}
		container Esource
		{
			unit<float32> EurM2;

			attribute<lu_type> landuse (EDomainGrid):
			[
			];
			unit <uint8> lu_type: nrofrows = 0
			{
				attribute<string>  Name:           [], DialogType = "LabelText";
				attribute<string>  PartioningName: [];
				attribute<lu_type> partioning := id(lu_type);
				attribute<uint32>  BrushColor: [], DialogType = "BrushColor";
			}
			container SuitabilityMaps
			{
				attribute<EurM2> Living  (DomainGrid):
				[
				];
				attribute<EurM2> Working (DomainGrid):
				[
				];
				attribute<EurM2> Nature  (DomainGrid):
				[
				];
			}
			container regMaps
			{
				unit <uint8> p1: nrofrows = 0;
				unit <uint8> p2: nrofrows = 0;

				attribute<p1> p1Map (DomainGrid) := const(0, DomainGrid, p1);
				attribute<p2> p2Map (DomainGrid) := pointRow(ID(DomainGrid)) < int16(4) ? value(0,p2) : value(1,p2);
			}
			container claim_sources
			{
				unit<float32> Meter := BaseUnit('m', float32);
				unit<float32> Ha :=10000.0 * Meter * Meter;

				container p1
				{
					attribute<Ha> Nature_min (regMaps/p1): [];
					attribute<Ha> Nature_max (regMaps/p1): [];
					attribute<Ha> Living_min (regMaps/p1): [];
					attribute<Ha> Living_max (regMaps/p1): [];
				}
				container p2
				{
					attribute<Ha> Working_min (regMaps/p2): [];
					attribute<Ha> Working_max (regMaps/p2): [];
				}
			}
			parameter <float32> nrHaPerCel := value(1, claim_sources/Ha);
			container claims_min
			{
				attribute<uint32> Living (regMaps/p1) := uint32(claim_sources/p1/Living_min  / nrHaPerCel);
				attribute<uint32> Working(regMaps/p2) := uint32(claim_sources/p2/Working_min / nrHaPerCel);
				attribute<uint32> Nature (regMaps/p1) := uint32(claim_sources/p1/Nature_min  / nrHaPerCel);
			}
			container claims_max
			{
				attribute<uint32> Living (regMaps/p1) := uint32(claim_sources/p1/Living_max  / nrHaPerCel);
				attribute<uint32> Working(regMaps/p2) := uint32(claim_sources/p2/Working_max / nrHaPerCel);
				attribute<uint32> Nature (regMaps/p1) := uint32(claim_sources/p1/Nature_max  / nrHaPerCel);
			}
			container regionSets
			{
				attribute<regMaps/p1> Nature (DomainGrid) := regMaps/p1Map;
				attribute<regMaps/p1> Living (DomainGrid) := regMaps/p1Map;
				attribute<regMaps/p2> Working(DomainGrid) := regMaps/p2Map;
			}
			unit<uint16> AtomicRegions := overlay(lu_type/PartioningName, DomainGrid, regionSets);

			attribute<Bool> InRegio (DomainGrid):
			[
			];
			attribute<Bool> FreeLand (DomainGrid) := InRegio;

			container Compacted
			{
				unit <uint32>      ADomain := Subset(FreeLand = True),
					label = "allocation domain";
				attribute<ADomain> BaseGrid (DomainGrid) :=invert(ADomain/nr_OrgEntity);
				
				container SuitabilityMaps
				{
					attribute<int32> Living  (ADomain) := int32(Allocation/source/SuitabilityMaps/Living)[ADomain/nr_orgEntity]  * int32(1000);
					attribute<int32> Working (ADomain) := int32(Allocation/source/SuitabilityMaps/Working)[ADomain/nr_orgEntity] * int32(1000);
					attribute<int32> Nature  (ADomain) := int32(Allocation/source/SuitabilityMaps/Nature)[ADomain/nr_orgEntity]  * int32(1000);
				}
				container SuitabilityMapsDiv
				{
					attribute<int32> Living  (ADomain) := int32(Allocation/source/SuitabilityMaps/Living  * float32(1000) / float32(12.46220836))[ADomain/nr_orgEntity];
					attribute<int32> Working (ADomain) := int32(Allocation/source/SuitabilityMaps/Working * float32(1000) / float32(12.46220836))[ADomain/nr_orgEntity];
					attribute<int32> Nature  (ADomain) := int32(Allocation/source/SuitabilityMaps/Nature  * float32(1000) / float32(12.46220836))[ADomain/nr_orgEntity];
				}
				attribute<AtomicRegions> AtomicRegionMap(ADomain) := AtomicRegions/UnionData[ADomain/nr_orgEntity];
			}
			parameter<int32> treshold := int32(0);
			container FeasibleSolution;
		}
		container allocate_discrete := 
			discrete_alloc(
				source/lu_type/name, 
				source/Compacted/ADomain, 
				source/Compacted/SuitabilityMaps, 
				source/lu_type/partioning,
				source/lu_type/PartioningName,
				source/AtomicRegions,
				source/Compacted/AtomicRegionMap, 
				source/claims_min, 
				source/claims_max, 
				source/treshold, 
				source/FeasibleSolution
			)
		{
			attribute<Source/lu_type> att       (DomainGrid) := landuse[Source/Compacted/BaseGrid];
			attribute<bool>           test      (DomainGrid) := eq_or_both_null(att, Source/landuse);
			parameter<bool>           test_attr              := all(test);
		}
		container allocate_discrete_empty := 
			discrete_alloc(
				Esource/lu_type/name, 
				Esource/Compacted/ADomain, 
				Esource/Compacted/SuitabilityMaps, 
				Esource/lu_type/partioning,
				Esource/lu_type/PartioningName,
				Esource/AtomicRegions,
				Esource/Compacted/AtomicRegionMap, 
				Esource/claims_min, 
				Esource/claims_max, 
				Esource/treshold, 
				Esource/FeasibleSolution
			)
		{
			parameter<bool> test := trim(lowercase(status)) == 'no suitability maps';
		}
		container allocate_discrete_div_constant := 
			discrete_alloc(
				source/lu_type/name,
				source/Compacted/ADomain,
				source/Compacted/SuitabilityMapsDiv,
				source/lu_type/partioning,
				source/lu_type/PartioningName,
				source/AtomicRegions,
				source/Compacted/AtomicRegionMap,
				source/claims_min,
				source/claims_max,
				source/treshold,
				source/FeasibleSolution
			)
		{
			attribute<Source/lu_type> att       (DomainGrid) := landuse[Source/Compacted/BaseGrid];
			attribute<bool>           test      (DomainGrid) := eq_or_both_null(att, Source/landuse);
			parameter<bool>           test_attr              := all(test);
		}
	}
	container UnitFunctions
	{
		container UnTiled := Template(RDomain);
		container Tiled   := Template(RTiledDomain);
	
		Template Template
		{
			unit<uint32> RDomain;

			container Source
			{
				unit<uint32>  Region := RDomain
				{
					attribute<DegreesCelsius> AvgDailyTemperature: [12,11,null,14,13];
				}
				unit<float32> m             := baseunit('m', float32);
				unit<float32> m2            := m * m;
				unit<float32> ha            := 10000.0 * m2;
				unit<float32> per_ha        := 1.0 / ha;
	
				unit<uint32>  nr_pers       := baseunit('persoon', uint32);
				unit<float32> nr_pers_pha   := float32(nr_pers) * per_ha;
	
// 				unit<uint32> NoordHollandBigCities: nrofrows = 3
// 				{
// 					attribute<string> CityNames: ['Amsterdam','Haarlem','Alkmaar'];
// 				}
// 				unit<uint32> ZuidHollandBigCities: nrofrows = 5
// 				{
// 					attribute<string> CityNames: ['Rotterdam','DenHaag','Leiden','Dordrecht','Leiden'];
// 				}
// 				unit<uint32> Years: nrofrows = 2
// 				{
// 					attribute<string> Names: ['1995','2005'];
// 				}
			}
			container Void
			{
				unit<void>      voidunit := void();
				parameter<bool> test     := PropValue(voidunit, 'expr') = 'void()';
			}
			container BaseUnit
			{
				unit<float32> m := BaseUnit('meter', float32);
				parameter<m> item_example := 7.0[m],
					Descr = "Example description",
					Label = "Example Label";
			}
			container metric
			{
				parameter<string> m2          := PropValue(source/m2, 'Metric');
				parameter<string> ha          := PropValue(source/ha, 'Metric');
				parameter<string> per_ha      := PropValue(source/per_ha, 'Metric');
				parameter<string> nr_pers_pha := PropValue(source/nr_pers_pha, 'Metric');
				parameter<bool>   test_param  := m2 == 'm^2' && ha == '10 kilo m^2' && per_ha ==' per 10 kilo m^2' && nr_pers_pha ='persoon per 10 kilo m^2' ; 
			}
			container nrofrows_op: url = "http://www.objectvision.nl/geodms/operators-a-functions/unit/nrofrows"
			{
				parameter<bool> test := #Source/Region = 7 && #Classifications/m_4K = 4;
			}
			container nrofrows: url = "http://www.objectvision.nl/geodms/operators-a-functions/unit/nrofrows"
			{
				parameter<bool> test := nrofrows(Source/Region) = 7 && nrofrows(Classifications/m_4K) = 4;
			}
			container range: url  = "http://www.objectvision.nl/geodms/operators-a-functions/unit/range"
			{
				unit<uint32> unit_regions := range(uint32, 1, 13)
				{
					attribute<unit_regions> id := id(unit_regions);
				}
				unit<spoint> unit_grid := range(spoint, point(int16(10),int16(14)), point(int16(15), int16(20)))
				{
					attribute<unit_grid> id := id(unit_grid);
				}
				attribute<int16> pointrow_unit_grid_test (unit_grid) := pointrow(ID(unit_grid));
				attribute<int16> pointcol_unit_grid_test (unit_grid) := pointcol(ID(unit_grid));
				parameter<bool> test_param :=
					nrofrows(unit_regions)       =       12  &&
					min(pointcol_unit_grid_test) = int16(14) &&
					min(pointrow_unit_grid_test) = int16(10) &&
					max(pointcol_unit_grid_test) = int16(19) &&
					max(pointrow_unit_grid_test) = int16(14) &&
					nrofrows(unit_grid)          =       30; 
			}
			container gridset: Descr ="to make a projection", url  = "http://www.objectvision.nl/geodms/operators-a-functions/unit/gridset"
			{
				unit<fpoint> rdc_meter:
					DialogData = "Geografie/top100/grid/Nl/achtergrond;Geografie/RegioIndelingen/Provincie/Shapes/Polygons",
					Range      = "[{300000, 0}, {625000, 280000})";
				unit<spoint> rdc_100 := 
					gridset(
						rdc_meter, 
						point(float32( -100.0), float32(100.0), rdc_meter), 
						point(float32(625000.0), float32(10000.0), rdc_meter), 
						spoint
					);
				unit<spoint> rdc_100_domain:= range(rdc_100,point(Int16(0), Int16(0)),point(Int16(3250), Int16(2700)));
				parameter<bool> test_param := nrofrows(rdc_100_domain) = 3250 * 2700; 
			}
			container boundaries
			{
				parameter<uint32> param_lb_defined := Lowerbound(RDomain),
					url  = "http://www.objectvision.nl/geodms/operators-a-functions/unit/lowerbound";
				parameter<uint32> param_ub_defined := Upperbound(RDomain),
					url  = "http://www.objectvision.nl/geodms/operators-a-functions/unit/upperbound";
	
				parameter<bool>    test_param := param_lb_defined = 0 && param_ub_defined = 7;
			}
			container boundcenter: url = "http://www.objectvision.nl/geodms/operators-a-functions/unit/boundcenter"
			{
				parameter<uint32>   param      := boundcenter(RDomain);
				parameter<bool>     test_param := param = 3;
			}
			container boundrange: url = "http://www.objectvision.nl/geodms/operators-a-functions/unit/boundrange"
			{
				parameter<uint32>   param      := boundrange(RDomain);
				parameter<bool>     test_param := param = 7;
			}
			container unit_domain: url  = "http://www.objectvision.nl/geodms/operators-a-functions/unit/domainunit"
			{
				unit<uint32>    RefADomain := domainUnit(source/Region/AvgDailyTemperature);
				parameter<bool> test_param := #(RefADomain) = 7;
			}
			container unit_values: url  = "http://www.objectvision.nl/geodms/operators-a-functions/unit/valuesunit"
			{
				unit<float32>   RefAValues := valuesUnit(source/Region/AvgDailyTemperature);
				parameter<bool> test_param := PropValue(RefAValues, 'Metric') = 'celsius';
			}
			container unit_default: url  = "http://www.objectvision.nl/geodms/operators-a-functions/unit/defaultunit"
			{
				unit<string>         unit_test  := DefaultUnit('string');
				parameter<unit_test> param      := 'Test';
				parameter<string>    param_unit := PropValue(param, 'ValuesUnit');
				parameter<Bool>      test_param := param_unit = 'unit_test';
			}
			container projection
			{
				container Source
				{
					unit<fpoint> rdc_meter: Range = "[{300000, 0}, {625000, 280000})";
					unit<spoint> rdc_100 := range(
						gridset(
							 rdc_meter
							,point(float32( - 100.0), float32(  100.0), rdc_meter)
							,point(float32(625000.0), float32(10000.0), rdc_meter)
							,spoint)
						,
							 point(int16(0)   , int16(0))
							,point(int16(3250), int16(2700)
						)
					);
				}
				container GetProjectionBase: url = "http://www.objectvision.nl/geodms/operators-a-functions/unit/getprojectionbase"
				{
					unit<fpoint>      ProjBase := GetProjectionBase(Source/rdc_100);
					parameter<fpoint> bcpb := boundcenter(ProjBase);
					parameter<fpoint> bcm := boundcenter(Source/rdc_meter);
					parameter<bool>   test     := bcpb = bcm;
				}
				container GetProjectionOffset: url = "http://www.objectvision.nl/geodms/operators-a-functions/unit/getprojectionoffset"
				{
					parameter<dpoint> projOffset := GetProjectionOffset(Source/rdc_100);
					parameter<bool>   test       := pointRow(projOffset) = 625000.0 && pointCol(projOffset) = 10000.0;
				}
				container GetProjectionFactor: url = "http://www.objectvision.nl/geodms/operators-a-functions/unit/getprojectionfactor"
				{
					parameter<dpoint> projFactor := GetProjectionFactor(Source/rdc_100);
					parameter<bool>   test       := pointRow(projFactor) = -100.0 && pointCol(projFactor) = 100.0;
				}
				container GridRelations
				{
					unit<uint32> DestDomain: nrofrows = 4
					{
						attribute<dpoint>         pointset: [{20427,69272},{17502,95885},{3188,80531},{12620,112190}];
						attribute<Source/rdc_100> gridrel:  [{6045,592},{6074,858},{6218,705},{6123,1021}];
					}
					attribute<Source/rdc_100> pointset_GridId_before_7015 (DestDomain) := 
						value(
							 (DestDomain/pointset - GetProjectionOffset/projOffset) / GetProjectionFactor/projFactor
							, Source/rdc_100
						);
					attribute<Source/rdc_100> pointset_GridId_7015_and_later (DestDomain) := DestDomain/pointset[Source/rdc_100];

					attribute<Source/rdc_100> pointset_GridId (DestDomain) := 
						='GeoDMSVersion() > 7.015
							? DestDomain/pointset[Source/rdc_100]
							: value(
								 (DestDomain/pointset - GetProjectionOffset/projOffset) / GetProjectionFactor/projFactor
								, Source/rdc_100
							  )';

					attribute<bool> test (DestDomain) := pointset_GridId == DestDomain/gridrel;
					parameter<bool> test_attr         := all(test);
				}
			}
			container GetMetricFactor: url = "http://www.objectvision.nl/geodms/operators-a-functions/unit/getmetricfactor"
			{
				parameter<float64> MetricFactor := GetMetricFactor(Source/per_ha);
				parameter<Bool>    test_param   := MetricFactor = 0.0001;
			}
			container TiledUnit
			{
				container gridunit
				{
					unit<spoint> gridcel_1km :=
						 range(
							gridset(
								 point_rd
								,point(float32(-1.0)  , float32(1.0) , point_rd )
								,point(float32(405600), float32(111300), point_rd )
								,spoint
							)
							,point(int16(0), int16(0))
							,point(int16(500), int16(400))
						);
				}
				unit<spoint> result := TiledUnit(Point(Int16(100), Int16(200), gridunit/gridcel_1km))
				{
					attribute<.>      nr   := id(.);
					attribute<int16>  att  := pointRow(nr);
					parameter<bool>   test := sum(uint32(att)) == 49900000;
				}
				container GetProjectionBase: url = "http://www.objectvision.nl/geodms/operators-a-functions/unit/getprojectionbase"
				{
					unit<fpoint>      ProjBase := GetProjectionBase(result);
					parameter<bool>   test     := boundcenter(ProjBase) = boundcenter(projection/Source/rdc_meter);
				}
				container GetProjectionOffset: url = "http://www.objectvision.nl/geodms/operators-a-functions/unit/getprojectionoffset"
				{
					parameter<dpoint> projOffset := GetProjectionOffset(result);
					parameter<bool>   test       := pointRow(projOffset) = 405600.0 && pointCol(projOffset) = 111300.0;
				}
				container GetProjectionFactor: url = "http://www.objectvision.nl/geodms/operators-a-functions/unit/getprojectionfactor"
				{
					parameter<dpoint> projFactor := GetProjectionFactor(result);
					parameter<bool>   test       := pointRow(projFactor) = -1.0 && pointCol(projFactor) = 1.0;
				}
				container arithmetic
				{
					attribute<spoint> plus      (result)               := result/nr + result/nr;
					attribute<spoint> plus_org  (gridunit/gridcel_1km) := id(gridunit/gridcel_1km) + id(gridunit/gridcel_1km);
					attribute<bool>   test      (result)               := rlookup(plus, plus_org[result])[result ] == result/nr;
					parameter<bool>   test_attr                        := all(test);
				}
			}
			container results
			{
				parameter<bool> tests :=
					   void/test
					&& metric/test_param
					&& nrofrows_op/test
					&& nrofrows/test
					&& range/test_param
					&& gridset/test_param
					&& boundaries/test_param
					&& BoundCenter/test_param
					&& BoundRange/test_param
					&& unit_domain/test_param
					&& unit_values/test_param
					&& unit_default/test_param
//					&& projection/GetProjectionBase/test
					&& projection/GetProjectionOffset/test
					&& projection/GetProjectionFactor/test
					&& projection/GridRelations/test_attr
					&& GetMetricFactor/test_param
					&& TiledUnit/arithmetic/test_attr;
			}
		}
	}
	container Miscellaneous
	{
		unit<float32> meter := BaseUnit('meter', float32);

//		parameter<meter> errorneous_metric_spec := float32(7.0),
//			Descr = "Example of an invalid specification of meter for a non-metric expression (since substitution would result in metric loss)";

		container PropValue: url = "http://www.objectvision.nl/geodms/operators-a-functions/miscellaneous/propvalue"
		{
			attribute<meter> A (ADomain):= value(Arithmetics/UnTiled/Source/B, meter) + value(Arithmetics/UnTiled/Source/C, meter),
				descr = "A is the sum of B and C"
			{
				parameter<string> name      := Uppercase(PropValue(A, 'name'));
				parameter<bool>   test_name := (name) = 'A';
			
				parameter<string> valuesunit     := LowerCase(PropValue(A, 'ValuesUnit'));
				parameter<bool>   test_valueunit := valuesunit = 'meter';
	
				parameter<string> expr      := LowerCase(PropValue(A, 'expr'));
				parameter<bool>   test_expr := expr == 'value(arithmetics/untiled/source/b, meter) + value(arithmetics/untiled/source/c, meter)';
	
				parameter<string> descr      := LowerCase(PropValue(A, 'descr'));
				parameter<bool>   test_descr := descr == 'a is the sum of b and c';
			}
			parameter<bool> test := A/test_name && A/test_valueunit && A/test_expr && A/test_descr;
		}
		container rnd_uniform: url = "http://www.objectvision.nl/geodms/operators-a-functions/miscellaneous/rnd_uniform"
		{
			parameter<float32> param          := rnd_uniform(0, void,    range(float32, 0f, 1f));
			parameter<bool>    test_param     := param >= 0f && param < 1f;
			attribute<float32> attr (Adomain) := rnd_uniform(0, Adomain, range(float32, 0f, 1f));
			// id;Attr
			// 0;0.719643
			// 1;0.781171
			// 2;0.974884
			// 3;0.446728
			// 4;0.0878883
			attribute<bool>    test (Adomain) := attr >= 0f && attr < 1f;
			parameter<bool>    test_attr      := all(test);
		}
		container rnd_uniform_empty: url = "http://www.objectvision.nl/geodms/operators-a-functions/miscellaneous/rnd_uniform"
		{
			attribute<float32> attr (EDomain) := rnd_uniform(0, EDomain, range(float32, 0f, 1f));
			attribute<bool>    test (EDomain) := attr >= 0f && attr < 1f;
			parameter<bool>    test_attr      := all(test);
		}
		container rnd_permutation: url  = "http://www.objectvision.nl/geodms/operators-a-functions/miscellaneous/random-permutation"
		{
			unit<uint32> ADomain := range(uint32, 0, 1000000);
			attribute<Adomain> attr (Adomain) := rnd_permutation(0, Adomain);  
			attribute<bool>    test (Adomain) := attr >= 0 && attr <= #Adomain  && Sum(attr) = Sum(id(Adomain));
			parameter<bool>    test_attr      := all(test);
		}
		container rnd_permutation_empty: url  = "http://www.objectvision.nl/geodms/operators-a-functions/miscellaneous/random-permutation"
		{
			attribute<EDomain> attr (EDomain) := rnd_permutation(0, EDomain);  
			attribute<bool>    test (EDomain) := attr >= 0 && attr <= #EDomain  && Sum(attr) = Sum(id(EDomain));
			parameter<bool>    test_attr      := all(test);
		}
		container subitem_op: url  = "http://www.objectvision.nl/geodms/operators-a-functions/miscellaneous/subitem"
		{
			attribute<uint32> att (Relational/UnTiled2UnTiled/unique/Regions) := Relational/UnTiled2UnTiled/unique/Regions!'Values';
			attribute<bool>   test(Relational/UnTiled2UnTiled/unique/Regions) := eq_or_both_null(att, Relational/UnTiled2UnTiled/unique/Regions/Values);
			parameter<bool>   test_attr                                       := all(test);
		}
		container subitem: url = "http://www.objectvision.nl/geodms/operators-a-functions/miscellaneous/subitem"
		{
			attribute<uint32> att (Relational/UnTiled2UnTiled/unique/Regions) := subitem(Relational/UnTiled2UnTiled/unique/Regions,'Values');
			attribute<bool>   test(Relational/UnTiled2UnTiled/unique/Regions) := eq_or_both_null(att, Relational/UnTiled2UnTiled/unique/Regions/Values);
			parameter<bool>   test_attr                                       := all(test);
		}
		container issue_915 {
			template A {
				container B {
					unit<uint32> C;
					parameter<C> P := 3; // the instantiated verion of this reference to C should be "C", and not "B/C"
					container B;
				}
			}
			container I := A();
			parameter<uint32> R := I/B/P;
			parameter<bool> test := (R == 3);
		}
		container diagram_mandelbrot
		{
			unit<uint32>        CountSet := range(uint32, uint32(0), uint32(300));
			unit<spoint>        grid100: Range = "[{-1000, -1000}, {1001, 1001})" ;
			attribute<CountSet> x1 (grid100) := Mandelbrot(grid100, CountSet, point(0.0, 0.0), point(0.002, 0.002));
		}
		Container GeoDMSVersion: url = "http://www.objectvision.nl/geodms/operators-a-functions/miscellaneous/geodmsversion"
		{
			parameter<float64> version := GeoDMSVersion();
			parameter<bool>    test    :=version >= 5.87;
		}
		Container GeoDMSBuildConfig: url = "http://www.objectvision.nl/geodms/operators-a-functions/miscellaneous/GeoDMSBuildConfig"
		{
			parameter<string> BuildConfig := GeoDMSBuildConfig();
			parameter<bool>   test        := BuildConfig == 'Release' || BuildConfig == 'Debug';
		}
		Container GeoDmsPlatform: url = "http://www.objectvision.nl/geodms/operators-a-functions/miscellaneous/GeoDmsPlatform"
		{
			parameter<string> BuildConfig := GeoDmsPlatform();
			parameter<bool>   test        := BuildConfig == 'Win32' || BuildConfig == 'x64';
		}
		Container GeoDmsTypeModel: url = "http://www.objectvision.nl/geodms/operators-a-functions/miscellaneous/GeoDmsTypeModel"
		{
			parameter<string> BuildConfig := GeoDmsTypeModel();
			parameter<bool>   test        := BuildConfig == 'Complete Edition' || BuildConfig == 'Express Edition';
		}
		Container Regex_match
		{
			parameter<String> TextOk          := dquote('Corop') + ';' + dquote('CoropLabel');
			parameter<String> TextSingleQuote :=  quote('Corop') + ';' +  quote('CoropLabel');
			parameter<String> TextComma       := dquote('Corop') + ',' + dquote('CoropLabel');

			parameter<Bool>   testOk          := regex_match(TextOk         , '\"[^\"]*+\"(;\"[^\"]*+\")*+');
			parameter<Bool>   testSingleQuote := regex_match(TextSingleQuote, '\"[^\"]*+\"(;\"[^\"]*+\")*+');
			parameter<Bool>   testCom         := regex_match(TextComma      , '\"[^\"]*+\"(;\"[^\"]*+\")*+');

			parameter<bool>   test_param      := testOk && !testSingleQuote && !testCom;
		}
		Container Regex_search
		{
			parameter<String> find           := regex_search(Regex_match/TextOk,'\"[^\"]*+\"',0);
			parameter<Bool>   test_param     := find ==  dquote('Corop');
		}
		Container Regex_replace
		{
			parameter<String> replace    := regex_replace(Regex_match/TextOk,'\"[^\"]*+\"',quote('NewLabel'));
			parameter<Bool>   test_param := replace ==  quote('NewLabel') + ';' + quote('NewLabel');
		}

		Container TemplateSyntax
		{
			Template Org
			{
				// begin case parameters
				parameter<uint32> A;
				// end case parameters
				
				parameter<uint32> B := A + 1;
			}
			Template New
			{
				// begin case parameters
				parameter<uint32> A;
				// end case parameters

				parameter<uint32> B := A + 1;
			}
			container OrgInst := Org(3);
			container NewInst := New(3);
			
			parameter<bool> test_org := OrgInst/B == 4;
			parameter<bool> test_new := NewInst/B == 4;

			parameter<bool> test_param := test_org && test_new;
		}
		
		container results
		{
			parameter<bool> tests := 
				   Propvalue/test
				&& rnd_uniform/test_param
				&& rnd_uniform/test_attr
				&& rnd_uniform_empty/test_attr
				&& rnd_permutation/test_attr
				&& rnd_permutation_empty/test_attr
				&& subitem_op/test_attr
				&& subitem/test_attr
				&& GeoDMSVersion/test
				&& GeoDMSBuildConfig/test
				&& GeoDmsPlatform/test
				&& GeoDmsTypeModel/test
				&& Regex_match/test_param
				&& Regex_search/test_param
				&& Regex_replace/test_param
				&& issue_915/test
				&& TemplateSyntax/test_param;

		}
	}
	container Trackers
	{
		parameter<String> NullStr := String(0/0);
		parameter<String> T5a     := iif(true, 'x', NullStr);
		parameter<String> T5b     := iif(false, 'x', NullStr);
		parameter<UInt32> T5c     := iif(true,  13/4, 0/0);
		parameter<UInt32> T5d     := iif(false, 13/4, 0/0);
		container Results
		{
			parameter<Bool> Tests := T5a=='x' && ! IsDefined(T5b) && T5c==3 && !IsDefined(T5d);
		}
	}
	
	container ExplicitNullvalues
	{
		parameter<uint8>  param_uint8  := 255b;
		parameter<uint16> param_uint16 := 65535w;
		parameter<uint32> param_uint32 := 4294967295;
		
		parameter<uint64> param_uint64_1 := 4294967295u64;
		parameter<uint64> param_uint64_2 := 42949672950000u64;
		parameter<uint64> param_uint64_3 := 18446744073709551614u64;
		parameter<uint64> param_uint64_4 := 18446744073709551615u64;

		parameter<int64> param_int64_1 := 9223372036854775806i64;
		parameter<int64> param_int64_2 := 9223372036854775807i64;
		
		parameter<int8>   param_int8  := -128c;
		parameter<int16>  param_int16 :=  -32768s;
		parameter<int32>  param_int32 := -2147483648i;

		parameter<bool>   test_uint8  := eq_or_both_null(param_uint8,  0b / 0b);
		parameter<bool>   test_uint16 := eq_or_both_null(param_uint16, 0w / 0w);
		parameter<bool>   test_uint32 := eq_or_both_null(param_uint32, 0 / 0);
		parameter<bool>   test_uint64 := eq_or_both_null(param_uint64_4, 0u64 / 0u64);

		parameter<bool>   test_int8  := eq_or_both_null(param_int8,  0c / 0c);
		parameter<bool>   test_int16 := eq_or_both_null(param_int16, 0s / 0s);
		parameter<bool>   test_int32 := eq_or_both_null(param_int32, 0i / 0i);
		parameter<bool>   test_int64 := eq_or_both_null(param_int64_2, 0i64 / 0i64);
		
		parameter<bool>   tests      := test_uint8 && test_uint16 && test_uint32 && test_int8 && test_int16 && test_int32;
	}
	
	container Utf8Characters
	{
		unit<float32>            := baseUnit('', float32);
		unit<float32>      euro   := baseUnit('', float32);
		unit<float32>            := baseUnit('', float32);
		unit<float32>      graadC := baseUnit('', float32);
		unit<float32>            := baseUnit('', float32);

		parameter<float32> bezineprijs1 := 2[];
		parameter<float32> bezineprijs2 := 2[euro];

		parameter<>      kookpunt_water1 := 100[];
		parameter<graadC> kookpunt_water2 := 100[graadC];

		parameter<float32>  := 1f;
		parameter<float64>  := pi();
		parameter<float64>  := 10d;
		parameter<float64>  := 10d;
		parameter<string>   := '';
		parameter<string>  @ := 'copyright';
		
		parameter<bool> tests := bezineprijs1 == bezineprijs2 && kookpunt_water1 == kookpunt_water2 &&  == 1f  &&  == pi() &&  == 10d &&  == 10d &&  == '' && @ == 'copyright';
	}

}